<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.0" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="分类">
<meta property="og:url" content="http://yoursite.com/categories/index.html">
<meta property="og:site_name" content="Just a blog">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-05-28T06:22:34.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="分类">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/categories/">





  <title>C++ Primer学习笔记：第15章 面向对象程序设计 | Just a blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Just a blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/21/C-Primer学习笔记：第15章-面向对象程序设计/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C++ Primer学习笔记：第15章 面向对象程序设计</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-21T22:53:00+08:00">2019-07-21</time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-07-30T13:35:25+08:00">2019-07-30</time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1>15.1 OOP：概述</h1>
<a id="more"></a>
<ul>
<li>
<p>继承</p>
<p>基类、派生类、虚函数、类派生列表、virtual、override</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> override</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>动态绑定</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">print_total</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> Quote &amp;item, <span class="keyword">size_t</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ret = item.net_price(n);</span><br><span class="line">    os &lt;&lt; <span class="string">"ISBN: "</span> &lt;&lt; item.isbn() </span><br><span class="line">        &lt;&lt; <span class="string">" # sold: "</span> &lt;&lt; n &lt;&lt; <span class="string">" total due: "</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>15.2 定义基类和派生类</h1>
<h2 id="15-2-1-定义基类"><a class="header-anchor" href="#15-2-1-定义基类">¶</a>15.2.1 定义基类</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Quote() = <span class="keyword">default</span>;</span><br><span class="line">    Quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;book, <span class="keyword">double</span> sales_price):</span><br><span class="line">            bookNo(book), price(sales_price) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>基类通常都应该定义一个虚析构函数</p>
</blockquote>
<ul>
<li>
<p>成员函数与继承</p>
<ul>
<li>virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义；</li>
<li>如果一个函数声明成虚函数，则在派生类中也隐式的是虚函数；</li>
<li>任何构造函数之外的非静态函数都可以是虚函数；</li>
</ul>
</li>
<li>
<p>访问控制</p>
<p>protected用于希望它的派生类有权访问，同时禁止其他用户访问</p>
</li>
</ul>
<h2 id="15-2-2-定义派生类"><a class="header-anchor" href="#15-2-2-定义派生类">¶</a>15.2.2 定义派生类</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Bulk_quote() = <span class="keyword">default</span>;</span><br><span class="line">    Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;, <span class="keyword">double</span>, <span class="built_in">std</span>::<span class="keyword">size_t</span>, <span class="keyword">double</span>);</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> override</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> min_qty = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> discount = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>访问说明符的作用是控制派生类从基类继承而来的成员是否对派生类的用户可见</p>
</blockquote>
<ul>
<li>
<p>派生类中的虚函数</p>
<p>在形参列表后面、或者在const成员函数的const关键字后面、或者在引用成员函数的引用限定符后面添加一个关键字</p>
</li>
<li>
<p>派生类对象及派生类向基类的类型转换</p>
<p>派生类对象中含有基类对应的组成部分，这是继承的关键所在</p>
</li>
<li>
<p>派生类构造函数</p>
<p>除非特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化；</p>
<p>如果想使用其他的基类构造函数，需要以类名加圆括号内的实参列表的形式为构造函数提供初始值；</p>
</li>
<li>
<p>派生类使用基类的成员</p>
<blockquote>
<p>每个类负责定义各自的接口。要想与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类部分</p>
</blockquote>
</li>
<li>
<p>继承与静态成员</p>
<p>静态成员在整个继承体系中只存在该成员的唯一定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">statmem</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> Derived&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Derived::f(<span class="keyword">const</span> Derived &amp;derived_obj)&#123;</span><br><span class="line">    Base::statmem();</span><br><span class="line">    Derived::statmem();</span><br><span class="line">    derived_obj.statmem();</span><br><span class="line">    statmem();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>派生类的声明</p>
<blockquote>
<p>声明语句的目的是令程序知晓某个名字的存在以及该名字表示什么样的实体。</p>
</blockquote>
</li>
<li>
<p>被用作基类的类</p>
<ul>
<li>
<p>想使用类作为基类，则该类必须已经定义而非仅仅声明；</p>
</li>
<li>
<p>直接基类、间接基类；</p>
</li>
</ul>
</li>
<li>
<p>防止继承（类名后的final关键字）</p>
</li>
</ul>
<h2 id="15-2-3-类型转换与继承"><a class="header-anchor" href="#15-2-3-类型转换与继承">¶</a>15.2.3 类型转换与继承</h2>
<blockquote>
<p>可以将一个派生类对象的指针存储在一个基类的智能指针内</p>
</blockquote>
<ul>
<li>
<p>静态类型与动态类型</p>
<ul>
<li>
<p>如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致；</p>
</li>
<li>
<p>基类的指针或引用的静态类型可能与其动态类型不一致；</p>
</li>
</ul>
</li>
<li>
<p>不存在从基类向派生类的隐式类型转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line">Quote *itemP = &amp;bulk;</span><br><span class="line">Bulk_quote *bulkP = itemP;<span class="comment">//错误：不能将基类转换成派生类</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在对象之间不存在类型转换</p>
<blockquote>
<p>当我们用一个派生类型对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动赋值，它的派生类部分将被忽略掉。</p>
</blockquote>
<p>派生类向基类的自动类型转换只对指针或引用有效，在派生类类型和基类类型之间不存在这样的转换</p>
</li>
</ul>
<h1>15.3 虚函数</h1>
<ul>
<li>
<p>对虚函数的调用可能在运行时才被解析</p>
<ul>
<li>
<p>对非虚函数的调用和通过对象进行的函数调用在编译时绑定；</p>
</li>
<li>
<p>只有通过指针或引用调用虚函数，才会在运行时解析该调用，也只有这种情况动态类型才有可能和静态类型不同；</p>
</li>
</ul>
</li>
<li>
<p>派生类中的虚函数</p>
<ul>
<li>派生类的虚函数必须和基类的虚函数形参完全一致；</li>
<li>返回类型也该完全一致；该规则存在例外，当类的虚函数的返回类型是类本身的指针或引用，这样的返回类型要求从派生类到基类的类型转换是可访问的；</li>
</ul>
</li>
<li>
<p>final和override说明符</p>
<ul>
<li>派生类可以定义一个与基类虚函数名字相同但是形参列表不同的函数。这种错误往往难以发现，可以用override声明此函数为虚函数的覆盖来避免这样的错误</li>
<li>通过final声明，任何尝试覆盖该函数的操作都将发生错误</li>
</ul>
</li>
<li>
<p>虚函数与默认实参</p>
<p>通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中函数版本也是如此。</p>
<blockquote>
<p>如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。</p>
</blockquote>
</li>
<li>
<p>回避虚函数的机制</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> undiscounted = baseP-&gt;Quote::net_price(<span class="number">42</span>);</span><br><span class="line"><span class="comment">//强行调用基类中定义的函数版本而不管baseP的动态类型是什么</span></span><br><span class="line"><span class="comment">//只有成员函数（或友元）中的代码才需要使用作用域运算符来回避虚函数机制</span></span><br></pre></td></tr></table></figure>
<p>当一个派生类的虚函数调用它覆盖的基类的虚函数版本时，需要回避虚函数的默认机制。如果一个派生类虚函数调用它的基类版本，但是没有使用作用域运算符，则该调用将在运行时被解析为对派生类版本自身的调用，从而导致无限递归。</p>
</li>
</ul>
<h1>15.4 抽象基类</h1>
<ul>
<li>
<p>纯虚函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Disc_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Disc_quote() = <span class="keyword">default</span>;</span><br><span class="line">    Disc_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> price, <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc):</span><br><span class="line">            Quote(book, price),</span><br><span class="line">            quantity(qty), discount(disc) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> quantity = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> discount = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>纯虚函数无须定义；</p>
<p>= 0 只能出现在类内部的虚函数声明语句处；</p>
<p>也可以为纯虚函数提供定义，函数体必须定义在类外部</p>
</li>
<li>
<p>含有纯虚函数的类是抽象基类</p>
<p>不能直接创建抽象基类的对象</p>
</li>
<li>
<p>派生类构造函数只初始化它的直接基类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Disc_quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Bulk_quote() = <span class="keyword">default</span>;</span><br><span class="line">    Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> price,</span><br><span class="line">               <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc):</span><br><span class="line">        Disc_quote(book, price, qty, disc) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> override</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在Quote的继承体系中增加Disc_quote类是重构的一个典型示例。</p>
</blockquote>
</li>
</ul>
<h1>15.5 访问控制与继承</h1>
<ul>
<li>
<p>受保护的成员</p>
<ul>
<li>
<p>和私有成员类似，受保护的成员对于类的用户来说是不可访问的</p>
</li>
<li>
<p>和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的</p>
</li>
<li>
<p>派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于基类对象中的受保护成员没有任何访问特权</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> prot_mem;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sneaky</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>; <span class="comment">//能访问Sneaky::prot_mem</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base&amp;)</span></span>; <span class="comment">//不能访问Base::prot_mem</span></span><br><span class="line">    <span class="keyword">int</span> j; <span class="comment">//j默认是private</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确：clobber能访问Sneaky对象的private和protected成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span> </span>&#123; s.j = s.prot_mem = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">//错误：clobber不能访问Base的protected成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span> </span>&#123; b.prot_mem = <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员；对于普通基类对象中的成员不具有特殊的访问权限。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>公有、私有和受保护继承</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pub_mem</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> prot_mem;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> priv_mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pub_Derv</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="comment">//正确，派生类能访问protected成员</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123; reurn prot_mem; &#125;</span><br><span class="line">    <span class="comment">//错误，private成员对于派生类不可见</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> priv_mem; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Priv_Derv</span> :</span> <span class="keyword">private</span> Base &#123;</span><br><span class="line">    <span class="comment">//private不影响派生类的访问权限</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; reutrn prot_mem; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pub_Derv d1;<span class="comment">//继承自Base的成员是public</span></span><br><span class="line">Priv_Derv d2;<span class="comment">//继承自Base的成员是private</span></span><br><span class="line">d1.pub_mem();<span class="comment">//正确，pub_mem在派生类中是public的</span></span><br><span class="line">d2.pub_mem();<span class="comment">//错误，pub_mem在派生类中是private的</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived_from_Public</span> :</span> <span class="keyword">public</span> Pub_Derv &#123;</span><br><span class="line">    <span class="comment">//正确，Base::prot_mem在Pub_Derv中仍然是protected的</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">use_base</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> prot_mem; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived_from_Private</span> :</span> <span class="keyword">public</span> Priv_Derv &#123;</span><br><span class="line">    <span class="comment">//错误，Base::prot_mem在Priv_Derv中是private的</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">use_base</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> prot_mem; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生访问说明符对于派生类的成员（及友元）能否访问其直接基类的成员没什么影响</span></span><br><span class="line"><span class="comment">//对基类成员的访问权限只与基类中的访问说明符有关</span></span><br><span class="line"><span class="comment">//派生访问说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>
<p>派生类向基类转换的可访问性</p>
<p>假设Derived继承自Base：</p>
<ul>
<li>
<p>只有当Derived公有继承Base时，用户代码才能使用派生类向基类的转换；如果Derived继承Base是protected或private，则用户代码不能使用该转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// code segment...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// code segment...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">protected</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// code segment...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D3</span> :</span> <span class="keyword">private</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// code segment...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D1 d1 = <span class="keyword">new</span> D1();</span><br><span class="line">    D2 d2 = <span class="keyword">new</span> D2();</span><br><span class="line">    D3 d3 = <span class="keyword">new</span> D3();</span><br><span class="line"></span><br><span class="line">    Base B1 = d1;     <span class="comment">// publiuc继承，正确</span></span><br><span class="line">    Base B2 = d2;     <span class="comment">// protected继承，错误</span></span><br><span class="line">    Base B3 = d3;     <span class="comment">// privat继承，错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>不论Derived以什么方式继承Base，Derived的成员函数和友元都能使用派生类向基类的转换；派生类对于其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    fun();</span><br><span class="line">    <span class="comment">// others...    </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">UseBaseFun</span><span class="params">(Base b)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TestFun</span><span class="params">(Base b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseBaseFun</span><span class="params">(Base b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b.fun();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Derived::TestFun(Base b)</span><br><span class="line">&#123;</span><br><span class="line">    b.fun();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived d1 = <span class="keyword">new</span> Derived();</span><br><span class="line">    Derived d2 = <span class="keyword">new</span> Derived();</span><br><span class="line">    <span class="comment">// 参数是派生类向基类的转换，正确</span></span><br><span class="line">    d2.UseBaseFun(d1);   </span><br><span class="line">    d2.TestBase(d1);     </span><br><span class="line"></span><br><span class="line">    retunr <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果Derived继承Base的方式是public或protected，则Derived的派生类的成员和友元可以使用Derived向Base的类型转换；反之，如果Derived继承Base的方式是private，则不能使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    fun();</span><br><span class="line">    <span class="comment">// others...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span>/<span class="keyword">protected</span>/<span class="keyword">private</span> Base</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">subDerived</span> :</span> <span class="keyword">public</span> Derived</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Test3rdSen</span><span class="params">(Base b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test3rdSen</span><span class="params">(Base b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b.fun();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived d = <span class="keyword">new</span> Derived();</span><br><span class="line">    subDerived sd = <span class="keyword">new</span> subDerived();</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 如果subDerived继承Derived的方式是public或protected下面这句                        </span></span><br><span class="line"><span class="comment">        话正确,如果继承方式是private，则下面这句话是错误的 */</span></span><br><span class="line">     sd.Test3rdSen(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>类有三种用户：</p>
<p>普通用户编写代码使用类的对象，这部分只能访问类的公有成员；</p>
<p>类的实现者负责编写类的成员和友元的代码，成员既能访问类的公有，也能访问类的私有（实现）部分；</p>
<p>派生类，基类把它希望派生类能够使用的部分声明为受保护的。普通用户不能访问受保护成员，而派生类及其友元仍旧不能访问私有成员；</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>友元与继承</p>
<ul>
<li>
<p>友元关系不能继承</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(Base b)</span> </span>&#123; <span class="keyword">return</span> b.prot_mem; &#125; <span class="comment">//正确，Pal是Base的友元</span></span><br><span class="line">  <span class="comment">//class Sneaky : public Base &#123;...&#125;</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">(Sneaky s)</span> </span>&#123; <span class="keyword">return</span> s.j; &#125; <span class="comment">//错误，Pal不是Sneaky的友元</span></span><br><span class="line">  <span class="comment">//对基类的访问权限由基类本身控制，即使对于派生类的基类部分也是如此</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">f3</span><span class="params">(Sneaky s)</span> </span>&#123;<span class="keyword">return</span> s.prot_mem; &#125; <span class="comment">//正确，Pal是Base的友元</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>当一个类将另一个类声明为友元时，这种友元关系只对做出声明的类有效。对原来的那个类来说，其友元的基类或者派生类不具有特殊访问能力</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> Pal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mem</span><span class="params">(Base b)</span> </span>&#123; <span class="keyword">return</span> b.prot_mem; &#125;<span class="comment">//错误，友元关系不能继承</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>改变个别成员的可访问性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> size() <span class="keyword">const</span> &#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::size;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>默认情况下，继承来的size和n是Derived的私有成员。然而，使用using可以改变成员的可访问性，使得Derived的用户可以使用size成员，而Derived的派生类将能使用n</li>
<li>通过在类的内部使用using，可以将直接间接基类的任何可访问成员标记出来。using声明语句中的访问权限由该using语句之前的访问说明符来决定，比如如果using出现在类的private部分，则该名字只能被成员和友元访问</li>
</ul>
<blockquote>
<p>派生类只能为那些它可以访问的名字提供using声明</p>
</blockquote>
</li>
<li>
<p>默认的继承保护级别</p>
<blockquote>
<p>struct关键字和class关键字定义的类之间唯一的差别就是默认成员访问说明符和默认派生说明符。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span> :</span> Base &#123; <span class="comment">/* ... */</span> &#125;; <span class="comment">//默认public继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> Base &#123; <span class="comment">/* ... */</span> &#125;; <span class="comment">//默认private继承</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>15.6 继承中的类作用域</h1>
<p>派生类作用域位于基类作用域之内</p>
<ul>
<li>
<p>编译时进行名字查找</p>
<p>能使用哪些成员仍然是<strong>由静态类型决定</strong>的</p>
</li>
<li>
<p>名字冲突与继承</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    Base() : mem(<span class="number">0</span>) &#123; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> mem;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line">    Derived(<span class="keyword">int</span> i) : mem(i) &#123; &#125; <span class="comment">//用i初始化Derived::mem，Base::mem进行默认初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_mem</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mem; &#125; <span class="comment">//返回Derived::mem</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>派生类的成员将隐藏同名的基类成员</p>
</blockquote>
</li>
<li>
<p>通过作用域运算符来使用隐藏成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_base_mem</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Base::mem; &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字</p>
</blockquote>
<p>类型查找与继承(p-&gt;mem()或obj.mem())</p>
<ul>
<li>首先确定p或obj的静态类型</li>
<li>在p或obj的静态类型对应的类中查找mem。找不到，则依次在基类的继承链中查找，没找到则编译报错</li>
<li>一旦找到mem，进行常规的类型检查以确认对于当前的mem，本次调用是否合法
<ul>
<li>如果mem是虚函数且我们通过指针或引用调用，则动态确定运行哪个虚函数版本</li>
<li>如果mem不是虚函数或者我们是通过对象进行的调用，则产生一个常规的函数调用</li>
</ul>
</li>
</ul>
</li>
<li>
<p>一如往常，名字查找先于类型检查</p>
<ul>
<li>
<p>派生类的函数不会重载基类的成员；</p>
</li>
<li>
<p>如果派生类的成员和基类的成员同名，则派生类将在其作用域隐藏该基类成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">memfcn</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">memfcn</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">//隐藏基类的memfcn</span></span><br><span class="line">&#125;;</span><br><span class="line">Derived d; Base b;</span><br><span class="line">b.memfcn();</span><br><span class="line">d.memfcn(<span class="number">10</span>);</span><br><span class="line">d.memfcn(); <span class="comment">//错误</span></span><br><span class="line">d.Base::memfcn();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>虚函数与作用域</p>
<p>假如基类与派生类的虚函数接受的实参不同，则我们就无法通过基类的引用或指针调用派生类的虚函数了</p>
</li>
<li>
<p>通过基类调用隐藏的虚函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> D1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Base bobj; D1 d1obj; D2 d2obj;</span><br><span class="line"> </span><br><span class="line">Base *bp1 = &amp;bobj; *bp2 = &amp;d1obj; *bp3 = &amp;d2obj;</span><br><span class="line">bp1-&gt;fcn();    <span class="comment">//Base::fcn</span></span><br><span class="line">bp2-&gt;fcn();    <span class="comment">//Base::fcn</span></span><br><span class="line">bp3-&gt;fcn();    <span class="comment">//D2::fcn</span></span><br><span class="line"> </span><br><span class="line">D1 *d1p = &amp;d1obj; D2 *d2p = &amp;d2obj;</span><br><span class="line">bp2-&gt;f2();    <span class="comment">//错误，Base没有f2()</span></span><br><span class="line">d1p-&gt;f2();    <span class="comment">//虚调用，运行时调用D1::f2()</span></span><br><span class="line">d2p-&gt;f2();    <span class="comment">//虚调用，运行时调用D2::f2()</span></span><br><span class="line"> </span><br><span class="line">Base *p1 = &amp;d2obj; D1 *p2 = &amp;d2obj; D2 *p3 = &amp;d2obj;</span><br><span class="line">p1-&gt;fcn(<span class="number">42</span>);    <span class="comment">//错误，Base没有fcn(int)</span></span><br><span class="line">p2-&gt;fcn(<span class="number">42</span>);    <span class="comment">//静态绑定，调用D1::fcn(int)</span></span><br><span class="line">p3-&gt;fcn(<span class="number">42</span>);    <span class="comment">//静态绑定，调用D2::fcn(int)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>覆盖重载的函数</p>
<p>如果派生类希望所有重载版本对于它都是可见的，那么它就需要覆盖所有版本或者一个也不覆盖；</p>
<p>有时仅需要覆盖集合中的一些而非全部函数，此时可以为重载成员提供using声明语句；</p>
<p>类内using声明的规则同样适用于重载函数的名字；</p>
<p>基类函数的每个实例在派生类中都必须是可访问的；</p>
<p>对派生类没有重新定义的重载版本的访问其实是对using声明点的访问；</p>
</li>
</ul>
<h1>15.7 构造函数与拷贝控制</h1>
<h2 id="15-7-1-虚析构函数"><a class="header-anchor" href="#15-7-1-虚析构函数">¶</a>15.7.1 虚析构函数</h2>
<p>如果一个类需要析构函数，那么它也同样需要拷贝和赋值操作；基类的析构函数并不遵循这个规则，它是一个重要的例外。基类总是需要析构函数，且为了成为虚函数而令内容为空，无法推断基类是否还需要赋值或拷贝运算符。</p>
<p>虚析构函数将阻止合成移动操作，如果一个类定义了析构函数，即使它通过=default的形式使用了合成版本，编译器也不会为这个类合成移动操作。（不太理解？？？）</p>
<h2 id="15-7-2-合成拷贝控制与继承"><a class="header-anchor" href="#15-7-2-合成拷贝控制与继承">¶</a>15.7.2 合成拷贝控制与继承</h2>
<p>合成的成员对类本身的成员依次进行初始化、赋值或销毁的操作；</p>
<p>合成的成员还负责使用基类中的对应的操作对一个对象的直接基类部分进行初始化、赋值或者销毁操作；</p>
<p>Quote基类定义了析构函数不能拥有合成的移动操作，移动Quote对象实际上使用的是合成的拷贝操作；</p>
<p>Quote没有移动操作意味着它的派生类也没有；</p>
<ul>
<li>
<p>派生类中删除的拷贝控制与基类的关系</p>
<p>某些定义基类的方式可能导致有的派生类成员成为被删除的对象：</p>
<ol>
<li>
<p>如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或者析构函数是被删除的函数或者是不可访问的，则派生类中<strong>对应的成员</strong>将是被删除的，原因是编译器不能使用基类成员来执行派生类对象中基类部分的构造、赋值或销毁操作；</p>
</li>
<li>
<p>如果在基类中有一个不可访问或删除的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分；</p>
</li>
<li>
<p>和之前一样，编译器不会合成一个删除掉的移动操作。 当使用=default操作请求一个移动操作时，如果基类中对应的操作时被删除的或者是不可访问的，那么派生类中该函数将是被删除的，原因是派生类中基类部分不可移动，同样，如果基类的析构函数是删除的或是不可访问的，则派生类的移动构造函数也将是被删除的。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	B();</span><br><span class="line">	B(<span class="keyword">const</span> B&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="comment">//没有声明任何构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line">D d;			<span class="comment">//正确：D的合成默认构造函数使用B的合成默认构造函数</span></span><br><span class="line"><span class="function">D <span class="title">d2</span><span class="params">(d)</span></span>;		<span class="comment">//错误：D的合成拷贝构造函数是被删除的</span></span><br><span class="line"><span class="function">D <span class="title">d3</span><span class="params">(<span class="built_in">std</span>::move(d))</span></span>;		<span class="comment">//错误，隐式的使用D的被删除的拷贝构造函数</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在实际编程过程中，如果在基类中没有默认、拷贝和移动构造函数，则一般情况下派生类也不会定义相应操作</p>
</blockquote>
</li>
<li>
<p>移动操作与继承</p>
<ul>
<li>
<p>大多数基类都会定义一个虚析构函数，因此在默认情况下，基类通常不含有合成的移动函数，而且它的派生类中也没有合成的移动操作。因为<strong>基类缺少移动操作会阻止派生类拥有自己的合成移动操作</strong>，所以当确实需要执行移动操作时<strong>应当首先在基类中定义</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Quote() = <span class="keyword">default</span>;<span class="comment">//成员依次默认初始化（为什么需要显示default？可以不吗？）</span></span><br><span class="line">    Quote(<span class="keyword">const</span> Quote&amp;) = <span class="keyword">default</span>;<span class="comment">//成员依次拷贝</span></span><br><span class="line">    Quote(Quote&amp;&amp;) = <span class="keyword">default</span>;<span class="comment">//成员依次拷贝</span></span><br><span class="line">    Quote&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Quote&amp;) = <span class="keyword">default</span>;<span class="comment">//拷贝赋值</span></span><br><span class="line">    Quote&amp; <span class="keyword">operator</span>=(Quote&amp;&amp;) = <span class="keyword">default</span>;<span class="comment">//移动赋值</span></span><br><span class="line">    <span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">//其他与之前版本一致</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//除非Quote的派生类有排斥移动的成员，否则它们将自动获得合成的移动操作</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="15-7-3-派生类的拷贝控制成员"><a class="header-anchor" href="#15-7-3-派生类的拷贝控制成员">¶</a>15.7.3 派生类的拷贝控制成员</h2>
<blockquote>
<p>派生类的构造函数要初始化自己和基类部分的成员；</p>
<p>派生类的拷贝和移动构造函数要拷贝和移动自己和基类部分的成员；</p>
</blockquote>
<ul>
<li>
<p>定义派生类的拷贝或移动构造函数</p>
<p>当为派生类定义拷贝或移动构造函数时，通常使用对应的基类的构造函数初始化派生类对象的基类的部分</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span><span class="comment">/*...*/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	D(<span class="keyword">const</span> D&amp; d):Base(d)&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">	D(D&amp;&amp; d):Base(<span class="built_in">std</span>::move(d))&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>派生类赋值运算符</p>
<p>与拷贝和移动构造函数一样，派生类的赋值运算符也必须显示的为派生类对象的基类部分赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D&amp; D::<span class="keyword">operator</span>=(<span class="keyword">const</span> D&amp; rhs)&#123;</span><br><span class="line">	Base::<span class="keyword">operator</span>=(rhs);          <span class="comment">//为基类部分赋值</span></span><br><span class="line">	<span class="comment">/*......*/</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>派生类析构函数</p>
<p>派生类析构函数只负责销毁自己的资源，<code>Base::~Base</code>自动执行</p>
</li>
<li>
<p>在构造和析构函数中调用虚函数</p>
<p>如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本</p>
</li>
</ul>
<h2 id="15-7-4-继承的构造函数"><a class="header-anchor" href="#15-7-4-继承的构造函数">¶</a>15.7.4 继承的构造函数</h2>
<blockquote>
<p>在C++11新标准中，派生类能够重用其直接基类定义的构造函数；</p>
<p>因为<strong>一个类只初始化它的直接基类，所以一个类也只继承其直接基类的构造函数</strong>；</p>
<p>类<strong>不能继承默认、拷贝和移动构造函数</strong>，如果派生类没有直接定义这些构造函数，编译器将为派生类合成它们；</p>
<p>派生类继承基类的构造函数的方式是<strong>提供一条注明了直接基类名的using声明语句</strong>；</p>
<p>通常情况下，using声明语句只是令某个名字在当前作用域可见，但当作用于构造函数的时候，using语句将令编译器产生代码；</p>
<p>对于基类的每一个构造函数，编译器都生成一个与之对应的派生类的构造函数，即对于基类的每个构造函数，在派生类中都有一个<strong>形参列表完全相同</strong>的构造函数；</p>
</blockquote>
<p>继承的构造函数的特点</p>
<ul>
<li>与普通成员的using声明不同，一个构造函数的using声明不会改变该构造函数的访问等级。例如，不管using声明出现在哪里，基类的私有构造函数在派生类中还是一个私有构造函数</li>
<li>一个using声明语句不能指定<strong>explicit</strong>（声明为explicit的构造函数不能在隐式转换中使用）或<strong>consexpr</strong>（constexpr表示一个函数或者表达式可以在编译时就求出值,constexpr构造函数的函数体一般为空，使用初始化列表或者其他的constexpr构造函数初始化所有数据成员。）。如果基类的构造函数是explicit或consexpr的，则在派生类中继承来的构造函数也有同样的属性</li>
<li>当一个基类构造函数含有默认实参时，这些实参并不会被继承，派生类将获得<strong>多个</strong>继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参，例如，当基类的构造函数有两个形参，其中第二个形参含有默认实参，则派生类将获得两个继承的构造函数：其中一个构造函数接受两个参数（没有默认形参）；另一个构造函数只接受一个参数，既基类中没有默认值的那个形参</li>
<li>如果基类中含有多个构造函数，大多数时候派生类会继承所有这些构造函数，但是有两个例外：一个是派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本。如果派生类定义的构造函数与基类中的构造函数具有相同的参数列表，则该构造函数不会被继承。另一个例外是默认、拷贝和移动构造函数不会被继承，这些函数按照正常的规则被合成</li>
<li>继承的构造函数不会被作为用户定义的构造函数使用，因此，如果一个类只含有继承的构造函数，则它也将拥有一个合成的默认构造函数</li>
</ul>
<h1>15.8 容器与继承</h1>
<blockquote>
<p>在容器中存放智能指针而非对象</p>
</blockquote>
<h2 id="15-8-1-编写basket类"><a class="header-anchor" href="#15-8-1-编写basket类">¶</a>15.8.1 编写Basket类</h2>
<ul>
<li>
<p>隐藏指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Basket bsk;</span><br><span class="line">bsk.add_item(make_shared&lt;Quote&gt;(<span class="string">"123"</span>, <span class="number">45</span>));</span><br><span class="line"><span class="comment">//该形式比较麻烦，新版本的add_item将处理内存分配</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_item</span><span class="params">(<span class="keyword">const</span> Quote&amp; sale)</span></span>; <span class="comment">//拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_item</span><span class="params">(Quote&amp;&amp; sale)</span></span>; <span class="comment">//移动</span></span><br><span class="line"><span class="comment">//问题是add_item不知道要分配的类型</span></span><br><span class="line"><span class="comment">//new Quote(sale)会切掉一部分非Quote的部分，所以可能不正确</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>模拟虚拷贝</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//该虚函数返回当前对象的一份动态分配的拷贝</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Quote* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> &amp; </span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> Quote(*<span class="keyword">this</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Quote* <span class="title">clone</span><span class="params">()</span> &amp;&amp; </span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> Quote(<span class="built_in">std</span>::move(*<span class="keyword">this</span>));&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Bulk_quote* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> &amp; </span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> Bulk_quote(*<span class="keyword">this</span>);&#125;</span><br><span class="line">    <span class="function">Bulk_quote* <span class="title">clone</span><span class="params">()</span> &amp;&amp; </span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> Bulk_quote(<span class="built_in">std</span>::move(*<span class="keyword">this</span>));&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Basket</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_item</span><span class="params">(<span class="keyword">const</span> Quote&amp; sale)</span></span>&#123;</span><br><span class="line">        items.insert(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Quote&gt;(sale.clone()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_item</span><span class="params">(Quote&amp;&amp; sale)</span></span>&#123;</span><br><span class="line">        items.insert(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Quote&gt;(<span class="built_in">std</span>::move(sale).clone()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>15.9 文本查询程序再探</h1>
<h2 id="15-9-1-面向对象的解决方案"><a class="header-anchor" href="#15-9-1-面向对象的解决方案">¶</a>15.9.1 面向对象的解决方案</h2>
<ul>
<li>
<p>继承体系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">	A(Query_base)</span><br><span class="line">	B(WordQuery)</span><br><span class="line">	C(NotQuery)</span><br><span class="line">	D(BinaryQuery)</span><br><span class="line">	E(AndQuery)</span><br><span class="line">	F(OrQuery)</span><br><span class="line">	A---B</span><br><span class="line">	A---C</span><br><span class="line">	A---D</span><br><span class="line">	D---E</span><br><span class="line">	D---F</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将层次关系隐藏于接口中</p>
<p>定义一个Query接口类，保存一个Query_base指针，该指针绑定到派生类对象上。用户通过Query对象的操作间接地创建并处理Query_base对象。定义Query的三个重载运算符和一个接受string参数的Query构造函数，这些函数动态分配一个新的Query_base派生类对象</p>
<ul>
<li>&amp;生成绑定到AndQuery对象上的Query对象；</li>
<li>|生成绑定到OrQuery对象上的Query对象；</li>
<li>~生成绑定到NotQuery对象上的Query对象；</li>
<li>接受string的构造函数生成一个新的WordQuery对象</li>
</ul>
</li>
<li>
<p>理解这些类的工作机理</p>
<ul>
<li>
<p>很大一部分工作是构建代表用户查询的对象；理解的关键是理解程序设计思路；</p>
</li>
<li>
<p>Query程序接口类和操作</p>
<ul>
<li>TextQuery</li>
<li>QueryResult</li>
<li>Query</li>
<li>Query q(s)</li>
<li>q1 &amp; q2</li>
<li>q1 | q2</li>
<li>~q</li>
</ul>
</li>
<li>
<p>Query程序实现类</p>
<ul>
<li>Query_base</li>
<li>WordQuery</li>
<li>NotQuery</li>
<li>BinaryQuery</li>
<li>AndQuery</li>
<li>OrQuery</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="15-9-2-query-base类和query类"><a class="header-anchor" href="#15-9-2-query-base类和query类">¶</a>15.9.2 Query_base类和Query类</h2>
<ul>
<li>
<p>Query_base类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Query_base</span> &#123;</span></span><br><span class="line">    <span class="comment">//派生类和用户都不能直接使用Query_base，所以要把友元类给Query</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Query</span>;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">using</span> line_no = TextQuery::lineNo;</span><br><span class="line">    <span class="keyword">virtual</span> ~Query_base() = <span class="keyword">default</span>;<span class="comment">//要隐式的在派生类的析构函数中使用，就最低要求是受保护的</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//返回与当前Query匹配的QueryResult</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> QueryResult <span class="title">eval</span><span class="params">(<span class="keyword">const</span> TextQuery&amp;)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;<span class="comment">//虚函数</span></span><br><span class="line">    <span class="comment">//rep表示查询的是一个string</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">rep</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//抽象基类，不希望直接用户或者派生类直接使用，所以没有public成员</span></span><br><span class="line"><span class="comment">//所有对Query_base的使用都需要通过Query对象，Query需要调用Query_base的虚函数，所以将Query声明为Query_base的友元</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Query类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Query对外提供接口，同时隐藏了Query_base的继承体系</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">	<span class="keyword">friend</span> Query <span class="keyword">operator</span>~(<span class="keyword">const</span> Query &amp;);</span><br><span class="line">	<span class="keyword">friend</span> Query <span class="keyword">operator</span>|(<span class="keyword">const</span> Query &amp;, <span class="keyword">const</span> Query &amp;);</span><br><span class="line">	<span class="keyword">friend</span> Query <span class="keyword">operator</span>&amp;(<span class="keyword">const</span> Query &amp;, <span class="keyword">const</span> Query &amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Query(<span class="keyword">const</span> <span class="built_in">string</span> &amp;);<span class="comment">//构建一个新的WordQuery</span></span><br><span class="line">	<span class="comment">//接口函数：调用对应的Query_base</span></span><br><span class="line">	<span class="function">QueryResult <span class="title">eval</span><span class="params">(<span class="keyword">const</span> TextQuery &amp;t)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> q-&gt;eval(t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">rep</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> q-&gt;rep();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Query(<span class="built_in">shared_ptr</span>&lt;Query_base&gt; query) :q(query) &#123;&#125;<span class="comment">//一个只能内部使用的构造函数，用Query_base构造的指针</span></span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;Query_base&gt; q;<span class="comment">//指向Query_base的智能指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Query的输出运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> Query &amp;query) &#123;</span><br><span class="line">	<span class="comment">//Query::rep通过它的Query_base指针对rep()进行了虚调用</span></span><br><span class="line">	<span class="keyword">return</span> os &lt;&lt; query.rep();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义完WordQuery类才可以定义这个构造函数</span></span><br><span class="line"><span class="keyword">inline</span> Query::Query(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s) :q(<span class="keyword">new</span> WordQuery(s)) &#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="15-9-3-派生类"><a class="header-anchor" href="#15-9-3-派生类">¶</a>15.9.3 派生类</h2>
<ul>
<li>
<p>WordQuery类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现Query_base的派生类，实现真正的查询</span></span><br><span class="line"><span class="comment">//我们所有的查询：基类和派生类的实际操作都是被封装隐藏的，只有通过Query类接口才能被外接访问</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordQuery</span> :</span><span class="keyword">public</span> Query_base&#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Query</span>;</span><span class="comment">//给Query开放接口</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	WordQuery(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s):query_word(s)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//具体的类：WordQuery将覆盖所有继承而来的纯虚函数</span></span><br><span class="line">	<span class="function">QueryResult <span class="title">eval</span><span class="params">(<span class="keyword">const</span> TextQuery &amp;t)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> t.query(query_word);<span class="comment">//</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">rep</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> query_word;<span class="comment">//</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">string</span> query_word;<span class="comment">//要查询的词</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>NotQuery类及~运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//~运算符生成一个NotQuery，其中保存着一个需要对其取反的Query</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotQuery</span> :</span><span class="keyword">public</span> Query_base &#123;</span><br><span class="line">	<span class="keyword">friend</span> Query <span class="keyword">operator</span>~(<span class="keyword">const</span> Query &amp;);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	NotQuery(<span class="keyword">const</span> Query &amp;q):query(q)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">QueryResult <span class="title">eval</span><span class="params">(<span class="keyword">const</span> TextQuery &amp;t)</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">rep</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">string</span>() + <span class="string">"~("</span> + query.rep() + <span class="string">")"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//具体的类：WordQuery将覆盖所有继承而来的纯虚函数</span></span><br><span class="line">	Query query;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Query <span class="keyword">operator</span>~(<span class="keyword">const</span> Query &amp;operand) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;Query_base&gt;(<span class="keyword">new</span> NotQuery(operand));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//复杂的eval在类的外部实现它</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>BinaryQuery类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也是一个抽象基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryQuery</span> :</span><span class="keyword">public</span> Query_base&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	BinaryQuery(<span class="keyword">const</span> Query &amp;l, <span class="keyword">const</span> Query &amp;r, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s):</span><br><span class="line">		lhs(l), rhs(r), opSym(s)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//抽象类，BinaryQuery不定义eval，继承了纯虚函数</span></span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">rep</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"("</span> + lhs.rep() + <span class="string">" "</span></span><br><span class="line">			+ opSym + <span class="string">" "</span></span><br><span class="line">			+ rhs.rep() +  <span class="string">")"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Query lhs, rhs;<span class="comment">//左侧和右侧运算对象</span></span><br><span class="line">	<span class="built_in">string</span> opSym;<span class="comment">//运算符的名字</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>AndQuery类、OrQuery类及相应的运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndQuery</span> :</span><span class="keyword">public</span> BinaryQuery &#123;</span><br><span class="line">	<span class="keyword">friend</span> Query <span class="keyword">operator</span>&amp;(<span class="keyword">const</span> Query&amp;, <span class="keyword">const</span> Query &amp;);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	AndQuery(<span class="keyword">const</span> Query &amp;left, <span class="keyword">const</span> Query &amp;right) :</span><br><span class="line">		BinaryQuery(left, right, <span class="string">"&amp;"</span>) &#123;&#125;</span><br><span class="line">	<span class="comment">//具体的类，继承了rep并且定义其他的虚函数</span></span><br><span class="line">	<span class="function">QueryResult <span class="title">eval</span><span class="params">(<span class="keyword">const</span> TextQuery &amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Query <span class="keyword">operator</span>&amp;(<span class="keyword">const</span> Query &amp;lhs, <span class="keyword">const</span> Query &amp;rhs) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;Query_base&gt;(<span class="keyword">new</span> AndQuery(lhs, rhs));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrQuery</span> :</span><span class="keyword">public</span> BinaryQuery &#123;</span><br><span class="line">	<span class="keyword">friend</span> Query <span class="keyword">operator</span>|(<span class="keyword">const</span> Query&amp;, <span class="keyword">const</span> Query &amp;);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	OrQuery(<span class="keyword">const</span> Query &amp;left, <span class="keyword">const</span> Query &amp;right) :</span><br><span class="line">		BinaryQuery(left, right, <span class="string">"|"</span>) &#123;&#125;</span><br><span class="line">	<span class="comment">//具体的类，继承了rep并且定义其他的虚函数</span></span><br><span class="line">	<span class="function">QueryResult <span class="title">eval</span><span class="params">(<span class="keyword">const</span> TextQuery &amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Query <span class="keyword">operator</span>|(<span class="keyword">const</span> Query &amp;lhs, <span class="keyword">const</span> Query &amp;rhs) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;Query_base&gt;(<span class="keyword">new</span> OrQuery(lhs, rhs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="15-9-4-eval函数"><a class="header-anchor" href="#15-9-4-eval函数">¶</a>15.9.4 eval函数</h2>
<blockquote>
<p>查询系统的核心</p>
</blockquote>
<ul>
<li>
<p>OrQuery::eval</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QueryResult OrQuery::eval(<span class="keyword">const</span> TextQuery &amp;text)<span class="keyword">const</span> &#123;</span><br><span class="line">	<span class="keyword">auto</span> right = rhs.eval(text), left = lhs.eval(text);</span><br><span class="line">	<span class="keyword">auto</span> ret_lines = make_shared&lt;<span class="built_in">set</span>&lt;TextQuery::lineNo&gt;&gt;(left.begin(), left.end());</span><br><span class="line">	ret_lines-&gt;insert(right.begin(), right.end());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> QueryResult(rep(), left.get_files(), ret_lines);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>AndQuery::eval</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QueryResult AndQuery::eval(<span class="keyword">const</span> TextQuery &amp;text) <span class="keyword">const</span> &#123;</span><br><span class="line">	<span class="keyword">auto</span> right = rhs.eval(text), left = lhs.eval(text);<span class="comment">//得到的QueryResult</span></span><br><span class="line">	<span class="keyword">auto</span> ret_lines = make_shared&lt;<span class="built_in">set</span>&lt;TextQuery::lineNo&gt;&gt;();<span class="comment">//空的</span></span><br><span class="line">	set_intersection(left.begin(), left.end(), right.begin(), right.end(), inserter(*ret_lines, ret_lines-&gt;begin()));</span><br><span class="line">	<span class="keyword">return</span> QueryResult(rep(), right.get_files(), ret_lines);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>NotQuery::eval</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">QueryResult NotQuery::eval(<span class="keyword">const</span> TextQuery &amp;text) <span class="keyword">const</span> &#123;</span><br><span class="line">	<span class="comment">//对text进行查询</span></span><br><span class="line">	<span class="keyword">auto</span> result = query.eval(text);<span class="comment">//查询得到QueryResult,,得到名字、set、文本的每一行</span></span><br><span class="line">	<span class="keyword">auto</span> ret_lines = make_shared&lt;<span class="built_in">set</span>&lt;TextQuery::lineNo&gt;&gt;();<span class="comment">//得到空的set指针，用来存返回结果</span></span><br><span class="line">	<span class="keyword">auto</span> beg = result.begin(), end = result.end();</span><br><span class="line">	<span class="keyword">auto</span> sz = result.get_files()-&gt;size();<span class="comment">//得到文本的行数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> n = <span class="number">0</span>; n != sz; ++n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (beg == end || *beg != n) &#123;</span><br><span class="line">			ret_lines-&gt;insert(n);<span class="comment">//如果不在result当中，就添加这一行</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (beg != end) &#123;</span><br><span class="line">			++beg;<span class="comment">//</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> QueryResult(rep(), result.get_files(), ret_lines);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>TextQuery和QueryResult的实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TextQuery.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryResult</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextQuery</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> lineNo = <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::size_type;</span><br><span class="line">	TextQuery() = <span class="keyword">default</span>;</span><br><span class="line">	TextQuery(ifstream &amp;infile);</span><br><span class="line"></span><br><span class="line">	<span class="function">QueryResult <span class="title">query</span><span class="params">(<span class="built_in">string</span> word)</span> <span class="keyword">const</span></span>;<span class="comment">//查询得到的是 QueryResult </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; text;<span class="comment">//装文本的每一行</span></span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">shared_ptr</span>&lt;<span class="built_in">set</span>&lt;lineNo&gt;&gt;&gt; wordMap;<span class="comment">//每个单词对应一个set</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryResult</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> ostream &amp;<span class="title">print</span><span class="params">(ostream&amp;, <span class="keyword">const</span> QueryResult&amp;)</span></span>;</span><br><span class="line">	<span class="comment">//构造函数 </span></span><br><span class="line">	QueryResult() = <span class="keyword">default</span>;</span><br><span class="line">	QueryResult(<span class="built_in">string</span> sword, <span class="built_in">shared_ptr</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; stext, <span class="built_in">shared_ptr</span>&lt;<span class="built_in">set</span>&lt;TextQuery::lineNo&gt;&gt; slines) :</span><br><span class="line">		sought(sword), text(stext), lines(slines) &#123;&#125;</span><br><span class="line">	<span class="built_in">set</span>&lt;TextQuery::lineNo&gt;::<span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> lines-&gt;begin();<span class="comment">//返回指向set的（存在位置）迭代器</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">set</span>&lt;TextQuery::lineNo&gt;::<span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> lines-&gt;end();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; get_files() <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> text;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">string</span> sought;<span class="comment">//查询单词 </span></span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; text;<span class="comment">//指向文本的指针</span></span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;<span class="built_in">set</span>&lt;TextQuery::lineNo&gt;&gt; lines;<span class="comment">//指向set的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runQueries</span><span class="params">(ifstream &amp;infile)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TextQuery.cpp</span></span><br><span class="line">TextQuery::TextQuery(ifstream &amp;infile) :text(<span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;)<span class="comment">//构造的时候动态新建内存 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">string</span> line;</span><br><span class="line">	lineNo lineNum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (getline(infile, line)) &#123;</span><br><span class="line">		text-&gt;push_back(line);</span><br><span class="line">		<span class="function"><span class="built_in">istringstream</span> <span class="title">iss</span><span class="params">(line)</span></span>;</span><br><span class="line">		<span class="built_in">string</span> word;</span><br><span class="line">		<span class="keyword">while</span> (iss &gt;&gt; word) &#123;</span><br><span class="line">			<span class="keyword">auto</span> &amp;lines = wordMap[word];<span class="comment">//得到shared_ptr的引用</span></span><br><span class="line">			<span class="keyword">if</span> (!lines) &#123;</span><br><span class="line">				lines.reset(<span class="keyword">new</span> <span class="built_in">set</span>&lt;lineNo&gt;);<span class="comment">//分配一个新的set </span></span><br><span class="line">			&#125;</span><br><span class="line">			lines-&gt;insert(lineNum);</span><br><span class="line">		&#125;</span><br><span class="line">		lineNum++;<span class="comment">//行号增加 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QueryResult TextQuery::query(<span class="built_in">string</span> word)<span class="keyword">const</span> &#123;</span><br><span class="line">	<span class="comment">//先在map中查是否存在这个单词，如果不存在的话应该返回空的set </span></span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">shared_ptr</span>&lt;<span class="built_in">set</span>&lt;TextQuery::lineNo&gt;&gt; nodata(<span class="keyword">new</span> <span class="built_in">set</span>&lt;TextQuery::lineNo&gt;);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//用find函数来查询，避免向map中插入新的</span></span><br><span class="line">	<span class="keyword">auto</span> loc = wordMap.find(word);</span><br><span class="line">	<span class="keyword">if</span> (loc == wordMap.cend()) &#123;</span><br><span class="line">		<span class="keyword">return</span> QueryResult(word, text, nodata);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> QueryResult(word, text, loc-&gt;second);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> QueryResult &amp;qr)</span> </span>&#123;</span><br><span class="line">	os &lt;&lt; qr.sought &lt;&lt; <span class="string">"occurs "</span> &lt;&lt; qr.lines-&gt;size() &lt;&lt; <span class="string">" times :"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> pos : (*qr.lines)) &#123;</span><br><span class="line">		os &lt;&lt; <span class="string">"line "</span> &lt;&lt; pos + <span class="number">1</span> &lt;&lt; <span class="string">":"</span> &lt;&lt; (*qr.text)[pos] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runQueries</span><span class="params">(ifstream &amp;infile)</span> </span>&#123;</span><br><span class="line">	<span class="function">TextQuery <span class="title">tq</span><span class="params">(infile)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"enter word to look for, q to quit:"</span>;</span><br><span class="line">		<span class="built_in">string</span> s;</span><br><span class="line">		<span class="keyword">if</span> (!(<span class="built_in">cin</span> &gt;&gt; s) || s == <span class="string">"q"</span>)<span class="keyword">break</span>;</span><br><span class="line">		print(<span class="built_in">cout</span>, tq.query(s)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C-Primer/" rel="tag"><i class="fa fa-tag"></i> C++ Primer</a>
          
            <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/20/C-Primer学习笔记：第14章-操作重载和类型转换/" rel="next" title="C++ Primer学习笔记：第14章 操作重载和类型转换">
                <i class="fa fa-chevron-left"></i> C++ Primer学习笔记：第14章 操作重载和类型转换
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/07/23/C-Primer学习笔记：第16章-模板与泛型编程/" rel="prev" title="C++ Primer学习笔记：第16章 模板与泛型编程">
                C++ Primer学习笔记：第16章 模板与泛型编程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">lidanyang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">211</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">83</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/lidanyang" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1261727840@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">1.</span> <span class="nav-text">15.1 OOP：概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">2.</span> <span class="nav-text">15.2 定义基类和派生类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#15-2-1-定义基类"><span class="nav-number">2.1.</span> <span class="nav-text">¶15.2.1 定义基类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-2-2-定义派生类"><span class="nav-number">2.2.</span> <span class="nav-text">¶15.2.2 定义派生类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-2-3-类型转换与继承"><span class="nav-number">2.3.</span> <span class="nav-text">¶15.2.3 类型转换与继承</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">3.</span> <span class="nav-text">15.3 虚函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">4.</span> <span class="nav-text">15.4 抽象基类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">5.</span> <span class="nav-text">15.5 访问控制与继承</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">6.</span> <span class="nav-text">15.6 继承中的类作用域</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">7.</span> <span class="nav-text">15.7 构造函数与拷贝控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#15-7-1-虚析构函数"><span class="nav-number">7.1.</span> <span class="nav-text">¶15.7.1 虚析构函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-7-2-合成拷贝控制与继承"><span class="nav-number">7.2.</span> <span class="nav-text">¶15.7.2 合成拷贝控制与继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-7-3-派生类的拷贝控制成员"><span class="nav-number">7.3.</span> <span class="nav-text">¶15.7.3 派生类的拷贝控制成员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-7-4-继承的构造函数"><span class="nav-number">7.4.</span> <span class="nav-text">¶15.7.4 继承的构造函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">8.</span> <span class="nav-text">15.8 容器与继承</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#15-8-1-编写basket类"><span class="nav-number">8.1.</span> <span class="nav-text">¶15.8.1 编写Basket类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">9.</span> <span class="nav-text">15.9 文本查询程序再探</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#15-9-1-面向对象的解决方案"><span class="nav-number">9.1.</span> <span class="nav-text">¶15.9.1 面向对象的解决方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-9-2-query-base类和query类"><span class="nav-number">9.2.</span> <span class="nav-text">¶15.9.2 Query_base类和Query类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-9-3-派生类"><span class="nav-number">9.3.</span> <span class="nav-text">¶15.9.3 派生类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-9-4-eval函数"><span class="nav-number">9.4.</span> <span class="nav-text">¶15.9.4 eval函数</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lidanyang</span>

  

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.0.0</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.0"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=6.0.0"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=6.0.0"></script>


  

</body>
</html>
