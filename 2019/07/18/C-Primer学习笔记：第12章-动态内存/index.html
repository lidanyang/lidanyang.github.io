<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.0" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="标签">
<meta property="og:url" content="http://yoursite.com/tags/index.html">
<meta property="og:site_name" content="Just a blog">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-05-28T06:22:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="标签">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/tags/">





  <title>C++ Primer学习笔记：第12章 动态内存 | Just a blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Just a blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/18/C-Primer学习笔记：第12章-动态内存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C++ Primer学习笔记：第12章 动态内存</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-18T18:51:00+08:00">2019-07-18</time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-07-30T13:35:38+08:00">2019-07-30</time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1>12.1 动态内存与智能指针</h1>
<a id="more"></a>
<ul>
<li>定义在memory头文件中的三种智能指针
<ul>
<li>shared_ptr允许多个指针指向同一个对象</li>
<li>unique_ptr则独占所指向的对象</li>
<li>weak_ptr是弱引用，指向shared_ptr所管理的对象</li>
</ul>
</li>
</ul>
<h2 id="12-1-1-shared-ptr类"><a class="header-anchor" href="#12-1-1-shared-ptr类">¶</a>12.1.1 shared_ptr类</h2>
<ul>
<li>shared和unique都支持
<ul>
<li>shared_ptr<t> sp</t></li>
<li>unique_ptr<t> up</t></li>
<li>p //用作条件判断</li>
<li>*p</li>
<li>p-&gt;mem</li>
<li>p.get()</li>
<li>swap(p,q)</li>
<li>p.swap(q)</li>
</ul>
</li>
<li>shared_ptr独有的
<ul>
<li>make_shared<t>(args)</t></li>
<li>shared_ptr<t>p(q)</t></li>
<li>p=q</li>
<li>p.unique()</li>
<li>p.use_count()</li>
</ul>
</li>
<li>make_shared函数
<ul>
<li>最安全的分配和使用动态内存的方法</li>
<li>使用方法<code>shared_ptr&lt;int&gt; p3 = make_shared&lt;int&gt;(42);</code>
<ul>
<li>不传参，对象会值初始化</li>
<li>用auto定义对象，保存make_shared的结果</li>
</ul>
</li>
</ul>
</li>
<li>shared_ptr的拷贝和赋值
<ul>
<li>当进行拷贝或赋值，每个shared_ptr会记录有多少其他shared_ptr指向相同对象</li>
<li>每个shared_ptr有引用计数
<ul>
<li>用一个初始化另一个、作为参数传递、作为函数返回值会递增</li>
<li>离开局部作用域、销毁、赋予新值会递减</li>
<li>一旦变为0，它就会释放管理的对象</li>
</ul>
</li>
<li>shared_ptr自动销毁管理的对象
<ul>
<li>通过析构函数实现销毁工作</li>
</ul>
</li>
<li>shared_ptr还会自动释放相关联的内存
<ul>
<li>如果将shared_ptr存放于容器中，而后不需要某些元素（比如重排了容器），此时要用erase删除不再需要的元素</li>
</ul>
</li>
<li>使用了动态生存期的资源的类
<ul>
<li>程序使用动态内存的原因
<ul>
<li>程序不知道自己需要使用多少对象</li>
<li>程序不知道所需对象的准确类型</li>
<li>程序需要在多个对象间共享数据</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="12-1-2-直接管理内存"><a class="header-anchor" href="#12-1-2-直接管理内存">¶</a>12.1.2 直接管理内存</h2>
<p><strong>自己直接管理内存的类与使用智能指针的类不同，不能依赖类对对象拷贝、赋值和销毁操作的任何默认定义</strong></p>
<ul>
<li>
<p>使用new动态分配和初始化对象</p>
<ul>
<li>
<p>动态分配的对象是默认初始化的，内置类型和组合类型的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化</p>
</li>
<li>
<p>为动态分配的对象进行值初始化，只需在类型名后跟一对空括号即可；对于定义了自己构造函数的类类型，要求值初始化没有意义，不管采用什么形式，对象都会通过默认构造函数来初始化；对于内置类型，值初始化的内置类型对象有良好的定义的值，默认初始化的对象的值则是未定义的。对于类中的依赖于合成默认构造函数的内置类型成员，如果未在类内初始化，则它们的值也是未定义的</p>
</li>
<li>
<p>如果提供一个括号包围的初始化器，就可以使用auto从此初始化器推断我们想要分配的对象类型，要求括号中仅有单一初始化器才可以使用auto</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p1 = <span class="keyword">new</span> <span class="keyword">auto</span>(obj);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>动态分配的const对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> *pcs = <span class="keyword">new</span> <span class="keyword">const</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="comment">//必须初始化，有默认构造函数的类类型，其const动态对象可以隐式初始化，其他类型必须显示初始化。返回的是指向const的指针</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>内存耗尽</p>
<ul>
<li>bad_alloc异常</li>
<li>定位new:<code>int *p2 = new (nothrow) int;//不能抛出异常，如果不能分配所需内存，会返回空指针</code></li>
</ul>
</li>
<li>
<p>释放动态内存（delete表达式）</p>
<ul>
<li>销毁指针指向的对象</li>
<li>释放对应内存</li>
</ul>
</li>
<li>
<p>指针值和delete</p>
<ul>
<li><strong>释放空指针总是没有错误的</strong></li>
<li>const对象可以被销毁</li>
</ul>
</li>
<li>
<p>动态对象的生存期直到被释放时为止</p>
<ul>
<li>内置指针管理的动态内存必须显示释放</li>
</ul>
</li>
<li>
<p>delete之后重置指针值</p>
<ul>
<li>空悬指针问题</li>
<li>delete后，将nullptr赋予指针</li>
</ul>
</li>
<li>
<p>只提供了有限的保护</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line"><span class="keyword">auto</span> q = p;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">p = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="12-1-3-shared-ptr和new结合使用"><a class="header-anchor" href="#12-1-3-shared-ptr和new结合使用">¶</a>12.1.3 shared_ptr和new结合使用</h2>
<ul>
<li>
<p>接收指针参数的智能指针构造函数是explicit的，必须用直接初始化形式初始化智能指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;T&gt; p(q); <span class="comment">//q必须指向new分配的内存，能够转换为T*类型，p管理q指向的对象</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;T&gt; p(u); <span class="comment">//u代表unique_ptr，p从u接管所有权，将u置位空</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;T&gt; p(q, d); <span class="comment">//p接管q对象的所有权，q必须能够转为T*类型，p将使用可调用对象d代替delete  </span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;T&gt; p(p2, d);</span><br><span class="line"></span><br><span class="line">p.reset();</span><br><span class="line">p.reset(q);</span><br><span class="line">p.reset(q, d);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>不要混合使用普通指针和智能指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr)</span></span>&#123;</span><br><span class="line">	<span class="comment">//使用ptr</span></span><br><span class="line">&#125;<span class="comment">//ptr离开作用域，被销毁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">x</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>))</span></span>; <span class="comment">//危险：x是普通指针，不是智能指针</span></span><br><span class="line">process(x); <span class="comment">//错误，不能将int *转换为一个shared_ptr&lt;int&gt;</span></span><br><span class="line">process(<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;(x)); <span class="comment">//合法的，但内存会被释放</span></span><br><span class="line"><span class="keyword">int</span> j = *x; <span class="comment">//未定义：x是悬空指针</span></span><br></pre></td></tr></table></figure>
<p>使用一个内置指针访问一个智能指针所负责的对象是很危险的，因为不知道对象何时会被销毁</p>
</li>
<li>
<p>不要用get初始化另一个智能指针或为智能指针赋值</p>
<ul>
<li>使用get返回的指针的代码不要delete此指针</li>
<li>永远不要用get初始化另一个智能指针或者为另一个智能指针赋值</li>
</ul>
</li>
<li>
<p>其他shared_ptr操作</p>
<p>用reset将一个新的指针赋予一个shared_ptr</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!p.unique())</span><br><span class="line">	p.reset(<span class="keyword">new</span> <span class="built_in">string</span>(*p));</span><br><span class="line">*p += newVal;</span><br><span class="line"><span class="comment">//reset和unique一起使用，控制多个shared_ptr共享的对象</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="12-1-4-智能指针和异常"><a class="header-anchor" href="#12-1-4-智能指针和异常">¶</a>12.1.4 智能指针和异常</h2>
<ul>
<li>
<p>智能指针和哑类</p>
<ul>
<li>分配了资源又没定义析构函数来释放资源的类，可能会遇到与使用动态内存相同的错误——忘记释放资源</li>
<li>使用shared_ptr保证资源的释放</li>
</ul>
</li>
<li>
<p>使用自己的释放操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">end_connection</span><span class="params">(connection *p)</span> </span>&#123; disconnect(*p) &#125;; <span class="comment">//定义自己的删除器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(destination &amp;d <span class="comment">/* 其他参数 */</span>)</span></span>&#123;</span><br><span class="line">    connection c = connect(&amp;d);</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;connection&gt; p(&amp;c, end_connection);</span><br><span class="line">    <span class="comment">//使用连接</span></span><br><span class="line">    <span class="comment">//即使由于异常而退出，connection也会被正确关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不使用相同的内置指针值(reset)初始化多个智能指针</li>
<li>不delete get()返回的指针</li>
<li>不使用get()初始化或reset另一个智能指针</li>
<li>如果使用get()返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了</li>
<li>如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器</li>
</ul>
</li>
</ul>
<h2 id="12-1-5-unique-ptr"><a class="header-anchor" href="#12-1-5-unique-ptr">¶</a>12.1.5 unique_ptr</h2>
<blockquote>
<p>一个unique_ptr独占它所指向的对象</p>
</blockquote>
<ul>
<li>
<p>unique_ptr必须使用直接初始化形式</p>
</li>
<li>
<p>没有类似make_shared的标准库函数返回一个unique_ptr</p>
</li>
<li>
<p>unique_ptr不支持普通的拷贝或赋值操作</p>
</li>
<li>
<p>可以通过release或reset将指针所有权从一个（非const）unique_ptr转移给另一个unique</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p1(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Stegosaurus"</span>));</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p2(p1.release()); <span class="comment">//所有权从p1转移给p2</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p3(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Trex"</span>));</span><br><span class="line">p2.reset(p3.release()); <span class="comment">//将所有权从p3转移给p2，reset释放了p2原来指向的内存</span></span><br><span class="line"></span><br><span class="line">p2.release(); <span class="comment">//错误：p2不释放内存，而且我们丢失了指针</span></span><br><span class="line"><span class="keyword">auto</span> p = p2.release(); <span class="comment">//正确，必须记得delete(p)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>传递unique_ptr参数和返回unique_ptr</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; clone(<span class="keyword">int</span> p)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="keyword">int</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; clone(<span class="keyword">int</span> p)&#123;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; ret(<span class="keyword">new</span> <span class="keyword">int</span>(p));</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译器知道要返回的对象将被销毁，所以会执行特殊的拷贝</span></span><br><span class="line"><span class="comment">//向后兼容：auto_ptr具有unique_ptr部分特性，但不是全部。不能在容器中保存auto_ptr，也不能从函数中返回auto_ptr</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>向unique_ptr传递删除器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;objT, delT&gt; p(<span class="keyword">new</span> objT, fcn);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(destination &amp;d <span class="comment">/* 其他需要的参数 */</span>)</span></span>&#123;</span><br><span class="line">    connection c = connect(&amp;d);</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;connection, delctype(end_connection)*&gt; p(&amp;c, end_connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="12-1-6-weak-ptr"><a class="header-anchor" href="#12-1-6-weak-ptr">¶</a>12.1.6 weak_ptr</h2>
<blockquote>
<p>不控制所指对象生存期的智能指针，指向一个由shared_ptr管理的对象，将weak_ptr绑定到shared_ptr不会改变shared_ptr的引用计数</p>
</blockquote>
<p>由于对象可能不存在，不能使用weak_ptr直接访问对象，必须调用lock</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">weak_ptr&lt;<span class="keyword">int</span>&gt; wp(p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; np = wp.lock())&#123;</span><br><span class="line">	<span class="comment">//在if中，np与p共享对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>核查指针类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlob</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> size_type = <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::size_type;</span><br><span class="line">    StrBlob();</span><br><span class="line">    StrBlob(<span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; il);</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;size(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;empty(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回string的引用，是因为调用点会使用该string</span></span><br><span class="line">    <span class="comment">//如b.front() = "first";</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span>&amp; <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span>&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//只有const StrBlob对象才会调用以下函数</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">StrBlobPtr <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">StrBlobPtr <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; data;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="keyword">const</span> <span class="built_in">string</span> &amp;msg)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">StrBlob::StrBlob(): data(make_shared&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;())</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">StrBlob::StrBlob(<span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; il): data(make_shared&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;(il))</span><br><span class="line">&#123;   </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> StrBlob::check(size_type i, <span class="keyword">const</span> <span class="built_in">string</span> &amp;msg) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= data-&gt;size())</span><br><span class="line">        <span class="keyword">throw</span> out_of_range(msg);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> StrBlob::push_back(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">    data-&gt;push_back(s);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> StrBlob::pop_back()</span><br><span class="line">&#123;</span><br><span class="line">    check(<span class="number">0</span>, <span class="string">"此StrBlob对象指向一个空vector！\n"</span>);</span><br><span class="line">    data-&gt;pop_back();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">string</span>&amp; StrBlob::front()</span><br><span class="line">&#123;</span><br><span class="line">    check(<span class="number">0</span>, <span class="string">"此StrBlob对象指向一个空vector！\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> data-&gt;front();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">string</span>&amp; StrBlob::back()</span><br><span class="line">&#123;</span><br><span class="line">    check(<span class="number">0</span>, <span class="string">"此StrBlob对象指向一个空vector！\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> data-&gt;back();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span>&amp; StrBlob::front() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    check(<span class="number">0</span>, <span class="string">"此StrBlob对象指向一个空vector！\n"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用对象为const StrBlob！\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> data-&gt;front();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span>&amp; StrBlob::back() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    check(<span class="number">0</span>, <span class="string">"此StrBlob对象指向一个空vector！\n"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用对象为const StrBlob！\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> data-&gt;back();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StrBlobPtr(): curr(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    StrBlobPtr(StrBlob &amp;b, <span class="keyword">size_t</span> sz = <span class="number">0</span>): wptr(b.data), curr(sz) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span>&amp; <span class="title">deref</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">StrBlobPtr&amp; <span class="title">incr</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    weak_ptr&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; wptr;</span><br><span class="line">    <span class="keyword">size_t</span> curr;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; check(<span class="keyword">size_t</span> i, <span class="keyword">const</span> <span class="built_in">string</span> &amp;msg) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; StrBlobPtr::check(<span class="keyword">size_t</span> i, <span class="keyword">const</span> <span class="built_in">string</span> &amp;msg) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = wptr.lock();</span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">        <span class="keyword">throw</span> runtime_error(<span class="string">"要访问的vector&lt;string&gt;对象不存在！\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= ret-&gt;size())</span><br><span class="line">        <span class="keyword">throw</span> out_of_range(msg);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">string</span>&amp; StrBlobPtr::deref() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = check(curr, <span class="string">"当前下标不合法！\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> (*p)[curr];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::incr()</span><br><span class="line">&#123;</span><br><span class="line">    check(curr, <span class="string">"不能继续递增了\n"</span>);</span><br><span class="line">    ++curr;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">StrBlobPtr StrBlob::begin()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> StrBlobPtr(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">StrBlobPtr StrBlob::end()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> StrBlobPtr(*<span class="keyword">this</span>, data-&gt;size());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StrBlob b1&#123;<span class="string">"mon"</span>, <span class="string">"tue"</span>, <span class="string">"wed"</span>, <span class="string">"thu"</span>, <span class="string">"fri"</span>&#125;;</span><br><span class="line">    <span class="function">StrBlobPtr <span class="title">p</span><span class="params">(b1, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p.deref() &lt;&lt; <span class="built_in">endl</span>;            <span class="comment">//访问p当前指向的元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p.incr().deref() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//先递增p，再访问元素</span></span><br><span class="line">    p = b1.begin();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p.deref() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>12.2 动态数组</h1>
<h2 id="12-2-1-new和数组"><a class="header-anchor" href="#12-2-1-new和数组">¶</a>12.2.1 new和数组</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[get_size()];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">42</span>];</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> arrT;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>分配一个数组会得到一个元素类型的指针</p>
<p>当用new分配一个数组，并未得到一个数组类型的对象，而是得到一个数组元素类型的指针。所以不能对动态数组调用begin或end（这些函数使用数组维度返回首元素和尾后元素的指针）。也不能用for处理动态数组</p>
</li>
<li>
<p>初始化动态分配对象的数组</p>
<p>new分配的都是默认初始化。</p>
<p>可以在大小之后跟一对空括号进行值初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pia2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]();</span><br></pre></td></tr></table></figure>
<p>还可以提供初始化器花括号列表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pia3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>动态分配一个空数组是合法</p>
<ul>
<li>类比尾后指针，可以像使用尾后迭代器一样使用这个指针</li>
</ul>
</li>
<li>
<p>释放动态数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">delete</span> [] pa; </span><br><span class="line"><span class="comment">//数组中元素逆序销毁</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>智能指针和动态数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>[]&gt; up(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]);</span><br><span class="line">up.release();</span><br><span class="line"><span class="comment">//当一个unique_ptr指向数组时，不能使用点和箭头成员运算符</span></span><br><span class="line"><span class="comment">//unique_ptr指向的是一个数组，而不是单个对象</span></span><br><span class="line"><span class="comment">//可以用下标来访问数组元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">    up[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//shared_ptr不支持直接管理动态数组，必须提供一个删除器。因为默认情况下，shared_ptr使用delete销毁它指向的对象</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>], [](<span class="keyword">int</span> *p) &#123; <span class="keyword">delete</span>[] p; &#125;);</span><br><span class="line">sp.reset(); <span class="comment">//使用提供的delete</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//shared_ptr不直接支持动态数组管理，不支持指针算术运算，未定义下标运算符</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">0</span>; ++i)</span><br><span class="line">    *(sp.get() + i) = i;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="12-2-2-allocator类"><a class="header-anchor" href="#12-2-2-allocator类">¶</a>12.2.2 allocator类</h2>
<ul>
<li>
<p>内存分配和对象构造组合在一起可能导致不必要的浪费</p>
</li>
<li>
<p>两次初始化，第一次在默认初始化，第二次在赋值时。没有默认构造函数的类就不能动态分配数组</p>
</li>
<li>
<p>allocator类</p>
<ul>
<li>
<p>头文件memory</p>
</li>
<li>
<p>将内存分配和对象构造分开</p>
</li>
<li>
<p>提供类型感知的内存分配，它分配的内存是原始的、未构造的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allocator&lt;<span class="built_in">string</span>&gt; alloc;</span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">const</span> p = alloc.allocate(n);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>allocator分配未构造的内存</p>
<ul>
<li>不能在未构造的情况下直接使用</li>
<li>用完对象必须用destroy来销毁它们</li>
<li>我们只能对真正构造了的元素进行destroy操作，元素销毁后可以重新构造对象，也可以通过deallocate归还给系统</li>
<li>释放内存通过deallocate完成，deallocate的大小参数必须和allocated分配内存时提供的大小具有一样的值</li>
</ul>
</li>
<li>
<p>拷贝和填充未初始化内存的算法</p>
<blockquote>
<p>用来在未初始化内存中创建对象。在目的位置创建元素，而不是由系统分配内存给它们。</p>
</blockquote>
<ul>
<li>uninitialized_copy(b,e,b2);</li>
<li>uninitialized_copy_n(b,n,b2)</li>
<li>uninitialized_fill(b,e,t)</li>
<li>uninitialized_fill_n(b,n,t)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1>12.3 使用标准库：文本查询程序</h1>
<h2 id="12-3-1-文本查询程序设计"><a class="header-anchor" href="#12-3-1-文本查询程序设计">¶</a>12.3.1 文本查询程序设计</h2>
<ul>
<li>
<p>列出程序操作</p>
<ul>
<li>逐行读取，分解为独立单词</li>
<li>输出时要能提取每个单词关联的行号，行号必须升序出现且无重复，必须能打印给定行号中的文本</li>
</ul>
</li>
<li>
<p>数据结构</p>
<ul>
<li>TextQuery类
<ul>
<li>成员：包含保存输入文件文本的vector，用来关联每个单词和它出现的行号的set的map</li>
<li>操作：用来读取给定输入文件的构造函数和一个执行查询的操作</li>
<li>查询操作：查找map，检查给定单词是否出现。一旦找到单词，需要知道它出现了多少次、行号以及每行的文本。</li>
</ul>
</li>
<li>QueryResult类，保存查询结果。这个类有一个print函数，打印结果</li>
</ul>
</li>
<li>
<p>类之间共享数据</p>
<ul>
<li>QueryResult需要知道给定单词的行号set和行对应的文本</li>
<li>返回指向TextQuery对象内部的迭代器或指针避免拷贝。考虑到TextQuery在QueryResult之前被销毁的情况和两种对象生存期应该同步的观察结果，可以使用shared_ptr反映这种共享关系</li>
</ul>
</li>
<li>
<p>使用TextQuery类</p>
<ul>
<li>
<p>实现之前先编写程序使用这个类，是很有用的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runQueries</span><span class="params">(ifstream &amp;infile)</span></span>&#123;</span><br><span class="line">	<span class="function">TextQuery <span class="title">tq</span><span class="params">(infile)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"enter word to query or q to quit: "</span>;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">if</span> (!(<span class="built_in">cin</span> &gt;&gt; s) || s == <span class="string">"q"</span>) <span class="keyword">break</span>;</span><br><span class="line">        print(<span class="built_in">cout</span>, tq.query(s)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="12-3-2-文本查询程序类的定义"><a class="header-anchor" href="#12-3-2-文本查询程序类的定义">¶</a>12.3.2 文本查询程序类的定义</h2>
<p>QueryResult需要共享保存输入文件的vector和保存单词关联行号的set。所以，TextQuery需要有一个指向动态分配的vector的shared_ptr和一个string到shared_ptr<set>的map</set></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryResult</span>;</span> <span class="comment">// declaration needed for return type in the query function</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextQuery</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> line_no = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::size_type;</span><br><span class="line">	TextQuery(<span class="built_in">std</span>::ifstream&amp;);</span><br><span class="line">	<span class="function">QueryResult <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt; file; <span class="comment">// input file</span></span><br><span class="line">	<span class="comment">// map of each word to the set of the lines in which that word appears</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;line_no&gt;&gt;&gt; wm;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>TextQuery构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read the input file and build the map of lines to line numbers</span></span><br><span class="line">TextQuery::TextQuery(ifstream &amp;is): file(<span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">string</span> text;</span><br><span class="line">	<span class="keyword">while</span> (getline(is, text)) &#123; <span class="comment">// for each line in the file</span></span><br><span class="line">		file-&gt;push_back(text); <span class="comment">// remember this line of text</span></span><br><span class="line">		<span class="keyword">int</span> n = file-&gt;size() - <span class="number">1</span>; <span class="comment">// the current line number</span></span><br><span class="line">		<span class="function"><span class="built_in">istringstream</span> <span class="title">line</span><span class="params">(text)</span></span>; <span class="comment">// separate the line into words</span></span><br><span class="line">		<span class="built_in">string</span> word;</span><br><span class="line">		<span class="keyword">while</span> (line &gt;&gt; word) &#123; <span class="comment">// for each word in that line</span></span><br><span class="line">            <span class="comment">// if word isn't already in wm, subscripting adds a new entry</span></span><br><span class="line">			<span class="keyword">auto</span> &amp;lines = wm[word]; <span class="comment">// lines is a shared_ptr</span></span><br><span class="line">			<span class="keyword">if</span> (!lines) <span class="comment">// that pointer is null the first time we see word</span></span><br><span class="line">				lines.reset(<span class="keyword">new</span> <span class="built_in">set</span>&lt;line_no&gt;); <span class="comment">// allocate a new set</span></span><br><span class="line">			lines-&gt;insert(n); <span class="comment">// insert this line number</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>QueryResult类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryResult</span> &#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="built_in">std</span>::<span class="function">ostream&amp; <span class="title">print</span><span class="params">(<span class="built_in">std</span>::ostream&amp;, <span class="keyword">const</span> QueryResult&amp;)</span></span>;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		QueryResult(<span class="built_in">std</span>::<span class="built_in">string</span> s,</span><br><span class="line">					<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;line_no&gt;&gt; p,</span><br><span class="line">						<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt; f): </span><br><span class="line">    			sought(s), lines(p), file(f) &#123; &#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> sought; <span class="comment">// word this query represents</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;line_no&gt;&gt; lines; <span class="comment">// lines it's on</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt; file; <span class="comment">// input file</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造函数唯一工作是将参数保存在对应的数据成员中</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>query函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">QueryResult</span><br><span class="line">TextQuery::query(<span class="keyword">const</span> <span class="built_in">string</span> &amp;sought) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// we'll return a pointer to this set if we don't find sought</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">shared_ptr</span>&lt;<span class="built_in">set</span>&lt;line_no&gt;&gt; nodata(<span class="keyword">new</span> <span class="built_in">set</span>&lt;line_no&gt;);</span><br><span class="line">    <span class="comment">// use find and not a subscript(下标) to avoid adding words to wm!</span></span><br><span class="line">    <span class="keyword">auto</span> loc = wm.find(sought);</span><br><span class="line">	<span class="keyword">if</span> (loc == wm.end())</span><br><span class="line">		<span class="keyword">return</span> QueryResult(sought, nodata, file); <span class="comment">// not found</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> QueryResult(sought, loc-&gt;second, file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>print函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp; os, <span class="keyword">const</span> QueryResult &amp;qr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// if the word was found, print the count and all occurrences</span></span><br><span class="line">    os &lt;&lt; qr.sought &lt;&lt; <span class="string">" occurs "</span> &lt;&lt; qr.lines-&gt;size() &lt;&lt; <span class="string">" "</span></span><br><span class="line">    	&lt;&lt; make_plural(qr.lines-&gt;size(), <span class="string">"time"</span>, <span class="string">"s"</span>) &lt;&lt;</span><br><span class="line">    		<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// print each line in which the word appeared</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> num : *qr.lines) <span class="comment">// for every element in the set</span></span><br><span class="line">		<span class="comment">// don't confound the user with text lines starting at 0</span></span><br><span class="line">		os &lt;&lt; <span class="string">"\t(line "</span> &lt;&lt; num + <span class="number">1</span> &lt;&lt; <span class="string">") "</span></span><br><span class="line">			&lt;&lt; *(qr.file-&gt;begin() + num) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C-Primer/" rel="tag"><i class="fa fa-tag"></i> C++ Primer</a>
          
            <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/18/C-Primer学习笔记：第11章-关联容器/" rel="next" title="C++ Primer学习笔记：第11章 关联容器">
                <i class="fa fa-chevron-left"></i> C++ Primer学习笔记：第11章 关联容器
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/07/19/C-Primer学习笔记：第13章-拷贝控制/" rel="prev" title="C++ Primer学习笔记：第13章 拷贝控制">
                C++ Primer学习笔记：第13章 拷贝控制 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">lidanyang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">136</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">58</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/lidanyang" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1261727840@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">1.</span> <span class="nav-text">12.1 动态内存与智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#12-1-1-shared-ptr类"><span class="nav-number">1.1.</span> <span class="nav-text">¶12.1.1 shared_ptr类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-1-2-直接管理内存"><span class="nav-number">1.2.</span> <span class="nav-text">¶12.1.2 直接管理内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-1-3-shared-ptr和new结合使用"><span class="nav-number">1.3.</span> <span class="nav-text">¶12.1.3 shared_ptr和new结合使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-1-4-智能指针和异常"><span class="nav-number">1.4.</span> <span class="nav-text">¶12.1.4 智能指针和异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-1-5-unique-ptr"><span class="nav-number">1.5.</span> <span class="nav-text">¶12.1.5 unique_ptr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-1-6-weak-ptr"><span class="nav-number">1.6.</span> <span class="nav-text">¶12.1.6 weak_ptr</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">2.</span> <span class="nav-text">12.2 动态数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#12-2-1-new和数组"><span class="nav-number">2.1.</span> <span class="nav-text">¶12.2.1 new和数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-2-2-allocator类"><span class="nav-number">2.2.</span> <span class="nav-text">¶12.2.2 allocator类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">3.</span> <span class="nav-text">12.3 使用标准库：文本查询程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#12-3-1-文本查询程序设计"><span class="nav-number">3.1.</span> <span class="nav-text">¶12.3.1 文本查询程序设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-3-2-文本查询程序类的定义"><span class="nav-number">3.2.</span> <span class="nav-text">¶12.3.2 文本查询程序类的定义</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lidanyang</span>

  

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.0.0</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.0"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=6.0.0"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=6.0.0"></script>


  

</body>
</html>
