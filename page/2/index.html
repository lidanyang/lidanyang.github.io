<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.0" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="分类">
<meta property="og:url" content="http://yoursite.com/categories/index.html">
<meta property="og:site_name" content="Just a blog">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-05-28T06:22:34.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="分类">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/categories/">





  <title>Just a blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Just a blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/17/C-Primer学习笔记：第9章-顺序容器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/17/C-Primer学习笔记：第9章-顺序容器/" itemprop="url">C++ Primer学习笔记：第9章 顺序容器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-17T14:54:00+08:00">2019-07-17</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>9.1 顺序容器概述</h1>
<ul>
<li>
<p>顺序容器类型</p>
<ul>
<li>
<p>vector</p>
<p>可变大小数组，随机访问，尾部之外的位置插入或删除元素可能很慢</p>
</li>
<li>
<p>deque</p>
<p>双端队列，随机访问，头尾插入删除元素很快</p>
</li>
<li>
<p>list</p>
<p>双向链表，双向顺序访问，任何位置插入删除元素都很快</p>
</li>
<li>
<p>forward_list</p>
<p>单向链表，单向顺序访问，任何位置插入删除元素都很快</p>
</li>
<li>
<p>array</p>
<p>固定大小数组，快速随机访问，不能添加删除元素</p>
</li>
<li>
<p>string</p>
<p>vector相似的容器，专门用于保存字符，随机访问快，尾部插入删除速度快</p>
</li>
</ul>
</li>
<li>
<p>新标准库的容器比旧版本快得多，现代C++程序应该使用标准库容器，而不是更原始的数据结构，如内置数组</p>
</li>
<li>
<p>确定使用哪种顺序容器</p>
<ul>
<li>
<p>通常，使用vector时最好的选择，除非你有很好的理由选择其他容器</p>
</li>
<li>
<p>如果是你的程序有很多小的元素，而空间的额外开销很重要，否则不需要使用list或forward_list</p>
</li>
<li>
<p>如果程序要求在容器的中间插入或删除元素，应使用list或forward_list</p>
</li>
<li>
<p>如果程序要写随机访问元素，应使用vector或deque</p>
</li>
<li>
<p>如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用deque</p>
</li>
<li>
<p>如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则</p>
<ul>
<li>
<p>首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向vector追加数据，然后在 调用标准库的sort函数来重排容器中的元素，从而避免在中间位置添加元素</p>
</li>
<li>
<p>如果必须在中间位置插入元素，考虑在输入阶段使用list，一旦输入完成，将list中的内容拷贝到一个vector</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1>9.2 容器库概览</h1>
<ul>
<li>元素可以保存的元素类型的限制
<ul>
<li>某些特定操作对元素类型有自己的特殊要求</li>
</ul>
</li>
</ul>
<h2 id="9-2-1-迭代器"><a class="header-anchor" href="#9-2-1-迭代器">¶</a>9.2.1 迭代器</h2>
<ul>
<li>迭代器范围（左闭右开）</li>
<li>使用左闭合范围蕴含的编程假定
<ul>
<li>如果begin与end相等，则范围为空</li>
<li>如果begin与end不等，则范围至少包含一个元素，且begin指向范围中第一个元素</li>
<li>可以对begin递增若干次，使得begin==end</li>
</ul>
</li>
</ul>
<h2 id="9-2-2-容器类型成员"><a class="header-anchor" href="#9-2-2-容器类型成员">¶</a>9.2.2 容器类型成员</h2>
<ul>
<li>
<p>类型成员</p>
<ul>
<li>size_type</li>
<li>iterator</li>
<li>const_iterator</li>
<li>value_type</li>
<li>reference</li>
<li>const_reference</li>
</ul>
</li>
<li>
<p>这种元素相关的类型别名在泛型编程中非常有用</p>
</li>
<li>
<p>反向迭代器</p>
</li>
<li>
<p>使用这些类型，要显示使用其类名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator iter;<span class="comment">//list&lt;string&gt;定义的一个迭代器类型</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::difference_type count;<span class="comment">//vector&lt;int&gt;定义的一个difference_type类型</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="9-2-3-begin和end成员"><a class="header-anchor" href="#9-2-3-begin和end成员">¶</a>9.2.3 begin和end成员</h2>
<ul>
<li>
<p>不以c开头的函数都被重载过，根据对象是否常量决定是否返回常量版本的返回值</p>
</li>
<li>
<p>以c开头的版本是C++新标准引入的，用以支持auto与begin和end结合使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示指定类型</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator it5 = a.begin();</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::const_iterator it6 = a.begin();</span><br><span class="line"></span><br><span class="line"><span class="comment">//是iterator还是const_iterator依赖于a的类型，但是以c开头的版本还是可以获得const_iterator的</span></span><br><span class="line"><span class="keyword">auto</span> it7 = a.begin(); <span class="comment">//仅当a是const，it7是const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it8 = a.cbegin(); <span class="comment">//it8是const_iterator</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="9-2-4-容器定义和初始化"><a class="header-anchor" href="#9-2-4-容器定义和初始化">¶</a>9.2.4 容器定义和初始化</h2>
<ul>
<li>
<p>将一个容器初始化另一个容器的拷贝</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C <span class="title">c1</span><span class="params">(c2)</span></span>;</span><br><span class="line">C c1 = c2;</span><br><span class="line"><span class="function">C <span class="title">c</span><span class="params">(b, e)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>直接拷贝整个容器，要求<strong>容器类型及其元素类型必须匹配</strong></li>
<li>拷贝迭代器对指定的元素范围（array除外），不要求容器类型相同，而且元素类型也可以不同</li>
</ul>
</li>
<li>
<p>列表初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C c&#123;a,b,c...&#125;;</span><br><span class="line">C c = &#123;a,b,c...&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于除array之外的类型，初始化列表还隐含指定了容器大小</li>
<li>对array来说，遗漏元素进行值初始化</li>
</ul>
</li>
<li>
<p>与顺序容器大小相关的构造函数</p>
<ul>
<li>接受一个容器大小和一个元素初始值。如果不提供初始值，则标准库会创建一个值初始化器</li>
<li>内置类型或者有默认构造函数的类类型，可以只提供一个容器大小参数</li>
<li>没有默认构造函数，还必须指定一个显示元素初始值</li>
</ul>
</li>
<li>
<p>标准库array具有固定大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 42&gt;;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="built_in">string</span>, 10&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>可以对array进行拷贝和赋值操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; digits = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; copy = digits;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="9-2-5-赋值和swap"><a class="header-anchor" href="#9-2-5-赋值和swap">¶</a>9.2.5 赋值和swap</h2>
<ul>
<li>
<p>赋值相关运算符可以用于所有容器，将左边容器中全部元素替换成右边容器元素的拷贝</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1 = c2;</span><br><span class="line">c1 = &#123;a,b,c&#125;;</span><br></pre></td></tr></table></figure>
<p>标准array类型允许赋值，左右两边必须具有相同的类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; a1 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; a2 = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">a1 = a2; <span class="comment">//替换a1中的元素</span></span><br><span class="line">a2 = &#123;<span class="number">0</span>&#125;; <span class="comment">//错误:不能将一个花括号列表赋予数组</span></span><br><span class="line"><span class="comment">//因为右边运算对象大小可能与左边运算对象大小不同，所以array类型不支持assign，也不允许用花括号包围的值列表进行赋值</span></span><br></pre></td></tr></table></figure>
<p>赋值相关运算符会导致指向左边容器内部的迭代器、引用和指针失效。而swap则不会导致失效（容器类型为array和string除外）</p>
</li>
<li>
<p>使用assign</p>
<ul>
<li>
<p>允许从一个不同但相容类型赋值，或者从容器的子序列赋值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; names;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; oldstyle;</span><br><span class="line">names = oldstyle;<span class="comment">//错误:容器类型不匹配</span></span><br><span class="line"><span class="comment">//正确:可以将const char *转换为string</span></span><br><span class="line">names.assign(oldstyle.cbegin(), oldstyle.cend());</span><br><span class="line"><span class="comment">//传递给assign的迭代器不能指向调用assign的容器</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>用指定数目且具有相同给定值的元素替换容器中原有元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; slist1(<span class="number">1</span>); </span><br><span class="line">slist1.assign(<span class="number">10</span>, <span class="string">"Hiya!"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>使用swap</p>
<ul>
<li>swap交换两个相同类型容器的内容</li>
<li><strong>除array外</strong>，交换两个容器内容的操作很快，元素本身未交换，只是交换两个容器的内部数据结构</li>
<li><strong>除了string外</strong>，指向容器的迭代器、引用和指针在swap后都不会失效。但是迭代器所指元素已经属于不同容器了</li>
<li>array的swap会真正交换它们的元素，指针、引用和迭代器绑定的元素保持不变，但是元素值和另一个array中对应元素值进行了交换</li>
<li>统一使用非成员版本的swap是一个好习惯</li>
</ul>
</li>
</ul>
<h2 id="9-2-6-容器大小操作"><a class="header-anchor" href="#9-2-6-容器大小操作">¶</a>9.2.6 容器大小操作</h2>
<p>size返回元素数目，empty判断是否为空，max_size返回大于等于该类型容器所能容纳的最大元素数的值</p>
<p>forward_list支持max_size和empty，但不支持size</p>
<h2 id="9-2-7-关系运算符"><a class="header-anchor" href="#9-2-7-关系运算符">¶</a>9.2.7 关系运算符</h2>
<p>每个容器都支持相等运算符；除了无序关联容器外的所有容器都支持关系运算符。左右必须保存相同类型元素的相同类型容器</p>
<ul>
<li>容器的关系运算符使用元素的关系运算符完成比较
<ul>
<li>只有元素类型也定义了比较运算符，才可以使用比较运算符比较两个容器</li>
</ul>
</li>
</ul>
<h1>9.3 顺序容器操作</h1>
<blockquote>
<p>上一节介绍了所有容器都支持的操作，本章剩余部分介绍顺序容器特有操作</p>
</blockquote>
<h2 id="9-3-1-向顺序容器添加元素"><a class="header-anchor" href="#9-3-1-向顺序容器添加元素">¶</a>9.3.1 向顺序容器添加元素</h2>
<ul>
<li>
<p>除array外，所有标准库容器都提供灵活的内存管理</p>
</li>
<li>
<p>添加元素的操作</p>
<ul>
<li>这些操作会改变容器大小；array不支持这些操作</li>
<li>forward_list有自己专有的insert和emplace，并且不支持push_back和emplace_back</li>
<li>vector和string不支持push_front和emplace_front</li>
<li>c.push_back(t)，c.emplace_back(args) //在c的尾部创建一个值为t或由args创建的元素。返回void</li>
<li>c.push_front(t)，c.emplace_front(t) //在c的头部创建一个值为t或由args创建的元素。返回void</li>
<li>c.insert(p,t)，c.emplace(p,args) //在迭代器p指向的元素之前创建一个元素，返回指向新元素的迭代器</li>
<li>c.insert(p,n,t) //在p之前插入n个值为t的元素，返回指向新添加的第一个元素的迭代器</li>
<li>c.insert(p,b,e) //将迭代器b和e指定的范围内的元素插入p之前，b和e不能指向c中的元素</li>
<li>c.insert(p,il) //il是一个花括号包围的值列表，将这些值插入p之前</li>
</ul>
<blockquote>
<p>向vector、string或deque插入元素会使指向容器的迭代器、引用和指针失效</p>
</blockquote>
</li>
<li>
<p>使用push_back</p>
<ul>
<li>array和forward_list不支持push_back</li>
<li>把对象插入容器，实际放入的是对象值的拷贝，不是对象本身</li>
</ul>
</li>
<li>
<p>使用push_front</p>
<ul>
<li>forward_list,deque,list支持push_front</li>
</ul>
</li>
<li>
<p>在容器中特定位置添加元素</p>
<ul>
<li>vector、deque、list、string都支持insert，forward_list提供了特殊版本的insert</li>
<li>有些不支持push_front的容器对insert并无类似限制，所以可以将元素插入开头，而不用担心容器是否支持</li>
</ul>
</li>
<li>
<p>插入范围元素</p>
<ul>
<li>如果插入范围为空，不插入任何元素，insert操作会将第一个参数返回</li>
</ul>
</li>
<li>
<p>使用insert的返回值</p>
<ul>
<li>使用insert的返回值，可以在容器中一个特定位置反复插入元素</li>
</ul>
</li>
<li>
<p>使用emplace操作</p>
<ul>
<li>
<p>emplace_front、emplace、emplace_back这些操作构造而不是拷贝元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确，调用emplace_back会在容器管理的内存空间中直接创建对象</span></span><br><span class="line">c.emplace_back(<span class="string">"978-0590353403"</span>, <span class="number">25</span>, <span class="number">15.99</span>);</span><br><span class="line"><span class="comment">//错误</span></span><br><span class="line">c.push_back(<span class="string">"978-0590353403"</span>, <span class="number">25</span>, <span class="number">15.99</span>);</span><br><span class="line"><span class="comment">//正确，push_back会创建一个局部临时对象，将其压入容器中</span></span><br><span class="line">c.push_back(Sales_data(<span class="string">"978-0590353403"</span>, <span class="number">25</span>, <span class="number">15.99</span>));</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="9-3-2-访问元素"><a class="header-anchor" href="#9-3-2-访问元素">¶</a>9.3.2 访问元素</h2>
<ul>
<li>包括array在内的每个顺序容器都有front成员函数，除forward_list之外的所有顺序容器都有一个back成员函数，分别返回首元素和尾元素的引用（forward_list的迭代器不能递减）</li>
<li>front、back、下标和at返回的是引用。const对象，返回const引用；普通对象，返回普通引用</li>
<li>下标操作和安全的随机访问
<ul>
<li>at成员函数如果下标越界，会抛出out_of_range异常</li>
</ul>
</li>
</ul>
<h2 id="9-3-3-删除元素"><a class="header-anchor" href="#9-3-3-删除元素">¶</a>9.3.3 删除元素</h2>
<ul>
<li>pop_front和pop_back
<ul>
<li>vector和string不支持pop_front和push_front</li>
<li>forward_list不支持pop_back</li>
</ul>
</li>
<li>容器内部删除元素
<ul>
<li>erase§ //p是待删除元素的迭代器</li>
<li>erase(b,e) //b,e是待删除范围的元素，返回最后一个被删除的元素之后元素的迭代器</li>
</ul>
</li>
</ul>
<h2 id="9-3-4-特殊的forward-list操作"><a class="header-anchor" href="#9-3-4-特殊的forward-list操作">¶</a>9.3.4 特殊的forward_list操作</h2>
<ul>
<li>forward_list未定义insert、emplace和erase操作
<ul>
<li>lst.before_begin</li>
<li>lst.insert_after</li>
<li>lst.erase_after</li>
</ul>
</li>
</ul>
<h2 id="9-3-5-改变容器大小"><a class="header-anchor" href="#9-3-5-改变容器大小">¶</a>9.3.5 改变容器大小</h2>
<ul>
<li>array不支持resize</li>
<li>c.resize(n)</li>
<li>c.resize(n,t)</li>
<li>resize缩小容器，则指向被删除元素的迭代器、引用和指针都会失效；对vector、string或deque进行resize可能会导致迭代器、指针和引用失效</li>
</ul>
<h2 id="9-3-6-容器操作可能使迭代器失效"><a class="header-anchor" href="#9-3-6-容器操作可能使迭代器失效">¶</a>9.3.6 容器操作可能使迭代器失效</h2>
<ul>
<li>添加删除可能会导致指针、引用或迭代器失效</li>
<li>添加元素
<ul>
<li>vector或string，且空间重新分配；未重新分配，则插入位置之前有效，之后无效</li>
<li>deque，插入首尾之外任意位置都会导致迭引指失效；在首尾插入，迭失效，引指不失效</li>
<li>list和forward_list，迭引指仍有效</li>
</ul>
</li>
<li>删除元素
<ul>
<li>list和forward_list，其他位置的迭引指仍有效</li>
<li>deque，删除首尾之外任意位置都会导致其他位置的迭引指失效；尾删除，尾后迭代器失效，其他迭引指不影响；首删除，这些也不会受影响</li>
<li>vector和string，被删元素之前元素的迭引指仍有效。删除元素时尾后迭总失效</li>
</ul>
</li>
<li>编写改变容器的循环程序
<ul>
<li>利用inset和erase的返回值</li>
</ul>
</li>
<li>不要保存end返回的迭代器
<ul>
<li>如果在一个循环中插入删除deque、string或vector中的元素，不要缓存end返回的迭代器</li>
</ul>
</li>
</ul>
<h1>9.4 vector对象是如何增长的</h1>
<ul>
<li>管理容量的成员函数
<ul>
<li>capacity获得不扩张内存空间情况下可以容纳多少元素，只适用vector和string</li>
<li>reserve通知容器它应该保存多少元素，只适用vector和string
<ul>
<li>只有需要的内存空间超过当前容量，reserve才会改变vector容量</li>
</ul>
</li>
<li>shrink_to_fit请将capacity()减少为和size()相同的大小，只适用vector、string和deque
<ul>
<li>具体实现可以选择忽略此请求</li>
</ul>
</li>
</ul>
</li>
<li>resize 只改变容器中元素数目，而不是容器的容量。不能使用resize减少容器预留的内存空间</li>
</ul>
<h1>9.5 额外的string操作</h1>
<h2 id="9-5-1-构造string的其他方法"><a class="header-anchor" href="#9-5-1-构造string的其他方法">¶</a>9.5.1 构造string的其他方法</h2>
<ul>
<li>string s(cp, n)</li>
<li>string s(s2,pos2)</li>
<li>string s(s2,pos2,len2)</li>
<li>substr(pos,n)</li>
</ul>
<h2 id="9-5-2-改变string的其他方法"><a class="header-anchor" href="#9-5-2-改变string的其他方法">¶</a>9.5.2 改变string的其他方法</h2>
<ul>
<li>
<p>支持assign、insert和erase操作</p>
</li>
<li>
<p>接收下标的insert和erase版本</p>
</li>
<li>
<p>接收C风格字符数组的insert和assign版本</p>
</li>
<li>
<p>append和replace函数</p>
</li>
<li>
<p>改变string的多种重载函数</p>
<ul>
<li>assign总是替换string中所有内容</li>
<li>append总是将新字符追加到string末尾</li>
</ul>
</li>
</ul>
<h2 id="9-5-3-string搜索操作"><a class="header-anchor" href="#9-5-3-string搜索操作">¶</a>9.5.3 string搜索操作</h2>
<ul>
<li>搜索失败返回值是string::size_type的静态成员string::npos，值为-1</li>
<li>查找子字符串find，rfind</li>
<li>查找给定字符串中任何一个字符匹配的位置find_first_of</li>
<li>查找第一个不在参数中的字符find_first_not_of</li>
<li>find_first都有find_last的版本</li>
</ul>
<h2 id="9-5-4-compare函数"><a class="header-anchor" href="#9-5-4-compare函数">¶</a>9.5.4 compare函数</h2>
<ul>
<li>参数形式
<ul>
<li>s2</li>
<li>pos1,n1,s2</li>
<li>pos1,n1,s2,pos2,n2</li>
<li>cp</li>
<li>pos1,n1,cp</li>
<li>pos1,n1,cp,n2</li>
</ul>
</li>
</ul>
<h2 id="9-5-5-数值转换"><a class="header-anchor" href="#9-5-5-数值转换">¶</a>9.5.5 数值转换</h2>
<ul>
<li>to_string(val)</li>
<li>stoi(s,p,b) //p用来保存s第一个非数值字符的下标，默认为0，即不保存下标；b表示转换用的基数，默认为10</li>
<li>stol(s,p,b)</li>
<li>stoul(s,p,b)</li>
<li>stoll(s,p,b)</li>
<li>stoull(s,p,b)</li>
<li>stof(s,p)</li>
<li>stod(s,p)</li>
<li>stold(s,p)</li>
</ul>
<h1>9.6 容器适配器</h1>
<blockquote>
<p>一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型</p>
</blockquote>
<ul>
<li>
<p>定义一个适配器</p>
</li>
<li>
<p>可以创建适配器时将命名的顺序容器作为第二个类型参数，来重载默认容器类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; str_stk;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; str_stk2(svec);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对容器的限制</p>
<ul>
<li>适配器不能构造在array之上</li>
<li>不能用forward_list构造适配器，因为所有适配器都要求容器有添加删除及访问尾元素的能力</li>
<li>stack可以用除array和forward_list之外任何容器类型构造</li>
<li>queue可以构造于list或deque之上，不能基于vector</li>
<li>priority_queue可以构造于vector或deque，不能基于list构造</li>
</ul>
</li>
<li>
<p>栈适配器</p>
</li>
<li>
<p>队列适配器</p>
<ul>
<li>注意队列的pop函数不返回删除的元素
<ul>
<li>如果调用的时候发生异常，并没有返回正确的值，但是栈顶元素已经弹出了，这时就丢失了栈顶数据</li>
</ul>
</li>
<li>queue默认基于deque，priority_queue基于vector实现</li>
<li>queue可以用list或vector实现，priority_queue也可以用deque实现</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/16/C-Primer学习笔记：第8章-IO库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/16/C-Primer学习笔记：第8章-IO库/" itemprop="url">C++ Primer学习笔记：第8章 IO库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-16T15:43:00+08:00">2019-07-16</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>8.1 IO类</h1>
<h2 id="8-1-1-io对象无拷贝或赋值"><a class="header-anchor" href="#8-1-1-io对象无拷贝或赋值">¶</a>8.1.1 IO对象无拷贝或赋值</h2>
<ul>
<li>不能将形参或返回类型设置为流类型</li>
<li>进行IO操作的函数通常是以引用方式传递和返回流</li>
<li>读写IO对象会改变其状态，所以传递和返回的引用不能是const的</li>
</ul>
<h2 id="8-1-2-条件状态"><a class="header-anchor" href="#8-1-2-条件状态">¶</a>8.1.2 条件状态</h2>
<blockquote>
<p>strm::iostate     strm是一种IO类型。iostream是一种机器相关的整型提供了表达条件状态的完整功能</p>
<p>strm::badbit      strm::badbit用来指出流已崩溃</p>
<p>strm::failbit       strm::failbit用来指出一个IO操作失败了</p>
<p>strm::eofbit       strm::eofbit用来指出流达到了文件结束</p>
<p>strm::goodbit    strm::goodbit用来指出流未处于错误状态。此值保证为零</p>
<p>s.eof()               流 s 的 eofbit 置位，则返回 true</p>
<p>s.fail()               流 s 的 failbit 或 badbit 置位，则返回 true</p>
<p>s.bad()              流 s 的 badbit 置位，则返回 true</p>
<p>s.good()            若流 s 处于有效状态，则返回 true</p>
<p>s.clear()            将流 s 中的所有条件状态位复位，将流的状态设置为有效。返回void</p>
<p>s.clear(flags)     根据给定的 flags 标志位，将流 s 中对于条件状态位复位。 flag 的类型是strm::iostate。返回 void</p>
<p>s.setstate(flags) 根据给定的 flags 标志位，将流 s 中对于条件状态位置位。 flag 的类型是strm::iostate。返回 void</p>
<p>s.rdstate()          返回流 s 的当前条件，返回值类型为 strm::iostate</p>
</blockquote>
<ul>
<li>
<p>查询流的状态</p>
<ul>
<li>badbit不可恢复，failbit可修正，文件结束eofbit、failbit会被置位</li>
<li>如果到达文件结束位置，eofbit和failbit都会被置位</li>
<li>将流当作条件使用等价于!fail()，bad、fail、eof在对应错误位置位时返回true。此外，badbit置位时，fail也会返回true</li>
</ul>
</li>
<li>
<p>管理条件状态</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复位failbit和badbit，保持其他标志位不变</span></span><br><span class="line"><span class="comment">//cin.failbit和cin.badbit是常量，不要误以为是变量</span></span><br><span class="line"><span class="built_in">cin</span>.clear(<span class="built_in">cin</span>.rdstate() &amp; ~<span class="built_in">cin</span>.failbit&amp; ~<span class="built_in">cin</span>.badbit);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="8-1-3-管理输出缓冲"><a class="header-anchor" href="#8-1-3-管理输出缓冲">¶</a>8.1.3 管理输出缓冲</h2>
<ul>
<li>
<p>导致缓冲刷新</p>
<ul>
<li>程序正常结束，作为main函数的return操作的一部分，缓冲刷新被执行</li>
<li>缓冲区满时，刷新缓冲，而后新的数据才能继续写入缓冲区</li>
<li>endl显示刷新</li>
<li>每个输出操作之后，可以用操纵符unitbuf设置流内部状态，清空缓冲区。默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新</li>
<li>一个输出流被关联到另一个流。当读写被关联的流，关联到的流的缓冲会被刷新。如，默认情况下，cin和cerr都关联到cout，读cin或者写cerr都会导致cout缓冲区被刷新</li>
</ul>
</li>
<li>
<p>刷新输出缓冲区</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hi!"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出hi和一个换行，然后刷新缓冲</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hi!"</span> &lt;&lt; flush; <span class="comment">//输出hi，然后刷新缓冲，不附加任何字符</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hi!"</span> &lt;&lt; ends; <span class="comment">//输出hi和一个空字符，然后刷新缓冲</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>unitbuf操纵符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每次输出后都刷新缓冲区，可以用unitbuf；nounitbuf则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; unitbuf; <span class="comment">//所有输出操作都会立即刷新缓冲区</span></span><br><span class="line"><span class="comment">//无缓冲</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; nounitbuf;<span class="comment">//回到正常</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>关联输入输出流</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span>.tie(&amp;<span class="built_in">cout</span>);</span><br><span class="line">ostream *old_tie = <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(&amp;<span class="built_in">cerr</span>);<span class="comment">//读取cin会刷新cerr而不是cout</span></span><br><span class="line"><span class="built_in">cin</span>.tie(old_tie);<span class="comment">//重建cin和cout的关联</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>8.2 文件输入输出</h1>
<blockquote>
<p>fstream fstrm;</p>
<p>fstream fstrm(s); //explicit的构造函数，默认mode依赖于fstream的类型</p>
<p>fstream fstrm(s, mode); //与前一个类似，按指定mode打开文件</p>
<p>fstrm.open(s);</p>
<p>fstrm.close();</p>
<p>fstrm.is_open();</p>
</blockquote>
<h2 id="8-2-1-使用文件流对象"><a class="header-anchor" href="#8-2-1-使用文件流对象">¶</a>8.2.1 使用文件流对象</h2>
<ul>
<li>用fstream代替iostream&amp;</li>
<li>成员函数open和close
<ul>
<li>可以用流作条件来检测操作是否成功</li>
<li>文件成功关闭，可以打开新的文件</li>
</ul>
</li>
<li>自动构造和析构
<ul>
<li>当一个fstream对象销毁时，close会自动被调用</li>
</ul>
</li>
</ul>
<h2 id="8-2-2-文件模式"><a class="header-anchor" href="#8-2-2-文件模式">¶</a>8.2.2 文件模式</h2>
<ul>
<li>文件模式
<ul>
<li>in</li>
<li>out</li>
<li>app 每次写操作前均定位到文件末尾</li>
<li>ate 打开文件后立即定位到文件末尾</li>
<li>trunc</li>
<li>binary</li>
</ul>
</li>
<li>限制
<ul>
<li>只有当out被设定时才可设定trunc模式</li>
<li>只要trunc没被指定，就可以设定app模式。在app模式下，即使没有显示指定out模式，文件也总是以输出方式被打开</li>
<li>默认情况下，即使没有指定trunc，以out模式打开的文件也会被截断</li>
<li>ate和binary模式可用于任何类型的文件流对象，可以与其他任何文件模式组合使用</li>
</ul>
</li>
<li>默认文件模式
<ul>
<li>ifstream以in模式打开</li>
<li>ofstream以out模式打开</li>
<li>fstream默认以in和out模式打开</li>
</ul>
</li>
<li>以out模式打开文件会丢弃已有数据
<ul>
<li>阻止方法是同时指定app模式</li>
</ul>
</li>
<li>每次调用open都会确定文件模式</li>
</ul>
<h1>8.3 string流</h1>
<blockquote>
<p>sstream strm;</p>
<p>sstream strm(s);</p>
<p>strm.str();	返回strm保存的string拷贝</p>
<p>strm.str(s);	将string s拷贝到strm中。返回void</p>
</blockquote>
<h2 id="8-3-1-使用istringstream"><a class="header-anchor" href="#8-3-1-使用istringstream">¶</a>8.3.1 使用istringstream</h2>
<h2 id="8-3-2-使用ostringstream"><a class="header-anchor" href="#8-3-2-使用ostringstream">¶</a>8.3.2 使用ostringstream</h2>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/15/C-Primer学习笔记：第7章-类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/15/C-Primer学习笔记：第7章-类/" itemprop="url">C++ Primer学习笔记：第7章 类 </a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-15T23:31:00+08:00">2019-07-15</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>7.1 定义抽象数据类型</h1>
<blockquote>
<p>基本思想是数据抽象和封装；</p>
<p>数据抽象是依赖接口和实现分离的编程技术；</p>
<p>类的接口包括用户能执行的操作；</p>
<p>类的实现包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数；</p>
</blockquote>
<h2 id="7-1-1-设计sales-data类"><a class="header-anchor" href="#7-1-1-设计sales-data类">¶</a>7.1.1 设计Sales_data类</h2>
<h2 id="7-1-2-定义改进的sales-data类"><a class="header-anchor" href="#7-1-2-定义改进的sales-data类">¶</a>7.1.2 定义改进的Sales_data类</h2>
<blockquote>
<p>定义在类内部的函数是隐式的inline函数</p>
</blockquote>
<ul>
<li>
<p>定义成员函数</p>
<ul>
<li>
<p>成员函数通过名为this的额外隐式参数访问调用它的那个对象</p>
</li>
<li>
<p>仍何对类成员的访问都被看作this的隐式引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">( )</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">( )</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo; &#125;</span><br><span class="line"> <span class="comment">//二者是等价的</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>this是一个常量指针，不允许改变this中保存的地址</p>
</li>
</ul>
</li>
<li>
<p>引入const成员函数</p>
<ul>
<li>
<p>this是一个指向类类型非常量版本的常量指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_data  * <span class="keyword">const</span> <span class="keyword">this</span>;</span><br><span class="line"><span class="comment">//所以我们不能把this绑定到一个常量对象上。所以我们不能在一个常量对象上调用普通的成员函数</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>const 常量成员函数：C++允许把const关键字写在函数的参数列表后面表示this是一个指向常量对象的指针。</p>
</li>
</ul>
<blockquote>
<p>常量对象，以及常量对象的指针或者引用都只能调用常量成员函数。</p>
</blockquote>
</li>
<li>
<p>类作用域和成员函数</p>
<ul>
<li>类本身就是一个作用域，类的成员函数的定义嵌套在类的作用域之内。其次，类的成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序，因为编译器首先编译成员的声明，然后才轮到成员函数体。</li>
</ul>
</li>
<li>
<p>在类的外部定义成员函数</p>
<ul>
<li>
<p>当我们在类的外部定义成员函数时，成员函数的定义必须与它的声明匹配。也就是说，返回类型、参数列表和函数名都得与内部的声明保持一致。</p>
</li>
<li>
<p>如果成员被声明成常量成员函数，那么它的定义也必须在参数列表后明确指定 const 属性。同时，类外部定义的成员的名字必须包含它所属的类名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> Sales_data::avg_price() <span class="keyword">const</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (units_sold)</span><br><span class="line">		<span class="keyword">return</span> revenue/units_sold;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该函数被声明在类 Sales_data 的作用域内。一旦编译器看到这个函数名，就能理解剩余的代码是位于类的作用域内的</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>定义一个返回this对象的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Sales_data&amp; Sales_data::combine(<span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	units_sold += rhs.units_sold;  <span class="comment">// add the members of rhs into</span></span><br><span class="line">	revenue += rhs.revenue;  <span class="comment">// the members of ''this'' object</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// return the object on which the function was called</span></span><br><span class="line">&#125;</span><br><span class="line">total.combine(trans)</span><br><span class="line"><span class="comment">//上面这个 return 返回 total 的调用</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="7-1-3-定义类相关的非成员函数"><a class="header-anchor" href="#7-1-3-定义类相关的非成员函数">¶</a>7.1.3 定义类相关的非成员函数</h2>
<ul>
<li>一般来说，如果非成员函数时类接口的组成部分，则这些函数的声明应该与类在同一个头文件内。</li>
</ul>
<h2 id="7-1-4-构造函数"><a class="header-anchor" href="#7-1-4-构造函数">¶</a>7.1.4 构造函数</h2>
<ul>
<li>
<p>构造函数没有返回类型</p>
</li>
<li>
<p><strong>不同于其他成员函数，构造函数不能被声明成 const 的</strong></p>
</li>
<li>
<p>当我们创建类的一个 const 对象时，直到构造函数完成初始化过程，对象才能真正取得其 “常量” 属性。因此，构造函数在 const 对象的构造过程中可以向其写值</p>
</li>
<li>
<p>默认构造函数</p>
<ul>
<li>如果我们的类没有显示地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数</li>
<li>编译器创建的构造函数被称为合成的默认构造函数（synthesized default constructor）。这个合成的默认构造函数将按照如下规则初始化类的数据成员
<ul>
<li>如果存在类内的初始值，用它来初始化成员。</li>
<li>否则，默认初始化该成员。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>某些类不能依赖于合成的默认构造函数。合成的默认构造函数只适合非常简单的类。对于一个普通的类来说，必须定义它自己的默认构造函数，原因由三：</p>
<ul>
<li>编译器只有在发现类不包含任何构造函数的情况下才会替我们生成了一个默认的构造函数</li>
<li>合成的默认构造函数可能执行错误的操作。如果定义在块中的内置类型或复合类型（比如数组和指针）的对象被默认初始化，则它们的值将是未定义的。该准则同样适用于默认初始化的内置类型成员</li>
<li>有的时候编译器不能因为某些类合成默认的构造函数。例如，如果类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员</li>
</ul>
</li>
<li>
<p>= default的含义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sales_data() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 C++11 中，如果我们需要默认的行为，那么可以通过在参数列表后面写上 = default 来要求编译器生成构造函数</li>
<li>= default 既可以和声明一起出现在类的内部，也可以定义出现在类的外部</li>
<li>和其他函数一样，如果 = default 在类的内部，则默认构造函数是内联的；如果它在类的外部，则该成员默认情况下不是内联的</li>
</ul>
</li>
<li>
<p>构造函数初始值列表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s): bookNo(s) &#123; &#125;</span><br><span class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p): bookNo(s), units_sold(n), revenue(p*n) &#123; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>构造函数初始值是成员名字的一个列表，每个名字后面紧跟括号括起来的（包括在花括号内的）成员初始值。不同成员的初始化通过逗号分隔开来</li>
<li>当某个数据成员被构造函数初始值列表忽略时，它将以与合成默认构造函数相同的方式隐式初始化</li>
<li>如果你的编译器不支持类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员</li>
</ul>
</li>
<li>
<p>在类外部定义构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sales_data::Sales_data(<span class="built_in">std</span>::istream &amp;is)</span><br><span class="line">&#123;</span><br><span class="line">	read(is, *<span class="keyword">this</span>);  <span class="comment">// read will read a transaction from is into this 					  // object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="7-1-5-拷贝-赋值和析构"><a class="header-anchor" href="#7-1-5-拷贝-赋值和析构">¶</a>7.1.5 拷贝、赋值和析构</h2>
<ul>
<li>拷贝
<ul>
<li>初始化变量</li>
<li>以值方式传递对象</li>
<li>返回一个对象</li>
</ul>
</li>
<li>赋值
<ul>
<li>赋值运算符</li>
</ul>
</li>
<li>销毁
<ul>
<li>一个局部对象会在创建它的块结束时被销毁</li>
<li>vector销毁时在其中的对象也会被销毁</li>
</ul>
</li>
<li>某些类不能依赖于合成的版本
<ul>
<li>当类需要分配类对象之外的资源时，合成版本常常会失效</li>
<li>管理动态内存的类通常不能依赖于上述操作的合成版本</li>
<li>使用vector或者string能避免分配和释放内存带来的复杂性</li>
</ul>
</li>
</ul>
<h1>7.2 访问控制与封装</h1>
<ul>
<li>使用 class 或 struct 关键字</li>
<li>使用 class 和 struct 定义类的唯一区别就是默认的访问权限</li>
<li>类可以在它的第一个访问说明符之前定义成员，对这种成员的访问权限依赖于类定义的方式
<ul>
<li>如果我们使用 struct 关键字，则定义在第一个访问说明符之前的成员是 public 的</li>
<li>相反，如果我们使用 class 关键字，则这些成员是 private 的</li>
</ul>
</li>
</ul>
<h2 id="7-2-1-友元"><a class="header-anchor" href="#7-2-1-友元">¶</a>7.2.1 友元</h2>
<ul>
<li>
<p>类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元（friend）</p>
</li>
<li>
<p>如果类想把一个函数作为它的友元，只需要增加一条以 friend 关键字开始的函数声明语句即可</p>
</li>
<li>
<p>友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限</p>
</li>
<li>
<p>友元不是类的成员也不受它所在区域访问控制级别的约束</p>
</li>
<li>
<p>一般来说，最好在类定义开始或结束前的位置集中声明友元</p>
</li>
<li>
<p>友元的声明</p>
<ul>
<li>
<p>友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外在专门对函数进行一次声明</p>
</li>
<li>
<p>为了使友元对类的用户可见，我们通常把友元的声明与类本身放置在同一个头文件中（类的外部）。因此，我们的 Sales_data 头文件应该为 read、print 和 add 提供独立的声明（除了类内部的友元声明之外）</p>
</li>
<li>
<p>许多编译器并未强制限定友元函数必须在使用之前在类的外部声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;   <span class="comment">//此处并不是通常意义的函数声明</span></span><br><span class="line">    X()&#123; f(); &#125;        <span class="comment">//错误，f还没有被声明</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> X::g() &#123;<span class="keyword">return</span> f(); &#125;<span class="comment">//错误，f还没有被声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;                 <span class="comment">//声明那个定义在X中的友元函数</span></span><br><span class="line"><span class="keyword">void</span> X::h() &#123; <span class="keyword">return</span> f(); &#125;<span class="comment">//正确，f的声明在作用域中</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1>7.3 类的其他特性</h1>
<h2 id="7-3-1-类成员再探"><a class="header-anchor" href="#7-3-1-类成员再探">¶</a>7.3.1 类成员再探</h2>
<ul>
<li>
<p>定义一个类型成员</p>
<ul>
<li>
<p>除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名</p>
</li>
<li>
<p>由类定义的类型别名和其他成员一样存在访问限制，可以是 public 或者 private 中的一种</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span>::size_type pos;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">   		pos cursor = <span class="number">0</span>;</span><br><span class="line">    	pos height = <span class="number">0</span>, width = <span class="number">0</span>;</span><br><span class="line">    	<span class="built_in">std</span>::<span class="built_in">string</span> contents;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//通过把pos定义成public成员可以隐藏Screen实现细节</span></span><br><span class="line"><span class="comment">//也可以使用类型别名等价的声明一个类型名字</span></span><br><span class="line"><span class="comment">//using pos = std::string::size_type;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>用来定义类型的成员必须先定义后使用，这一点与普通成员有所区别，具体原因将在解释。因此，类型成员通常在类开始的地方出现</p>
</li>
</ul>
</li>
<li>
<p>令成员作为内联函数</p>
<ul>
<li>定义在类内部的成员函数是自动inline的</li>
<li>可以在类的内部把inline作为声明的一部分显示地声明成员函数</li>
<li>也能在类的外部用inline关键字修饰函数的定义</li>
<li>inline函数应该与相应的类定义在同一个头文件中</li>
</ul>
</li>
<li>
<p>重载成员函数</p>
</li>
<li>
<p>可变数据成员</p>
<ul>
<li>
<p>如果我们希望能够修改类的某个数据成员，即使是在一个 const 成员函数内。可以通过在变量的声明中加入 mutable 关键字做到这一点</p>
</li>
<li>
<p>一个可变数据成员（mutable data member）永远不会是 const，即使它是 const 对象的成员。因此，一个 const 成员函数可以改变一个可变成员的值</p>
</li>
</ul>
</li>
<li>
<p>类成员初始值</p>
<ul>
<li>提供一个类内初始值时，必须以符号 = 或者花括号表示</li>
</ul>
</li>
</ul>
<h2 id="7-3-2-返回-this的成员函数"><a class="header-anchor" href="#7-3-2-返回-this的成员函数">¶</a>7.3.2 返回*this的成员函数</h2>
<ul>
<li>
<p>从const成员函数返回*this</p>
<ul>
<li>一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用</li>
</ul>
</li>
<li>
<p>基于const的重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">//根据对象是否是const重载display函数</span></span><br><span class="line">    	<span class="function">Screen &amp;<span class="title">display</span><span class="params">(<span class="built_in">std</span>::ostream &amp;os)</span></span></span><br><span class="line"><span class="function">        			</span>&#123; do_display(os); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    	<span class="function"><span class="keyword">const</span> Screen &amp;<span class="title">display</span><span class="params">(<span class="built_in">std</span>::ostream &amp;os)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        			</span>&#123; do_display(os); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">do_display</span><span class="params">(<span class="built_in">std</span>::ostream &amp;os)</span> <span class="keyword">const</span> </span>&#123; os &lt;&lt; contents; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//display的非常量版本调用do_display时，它的this指针将隐式从指向非常量的指针转换成指向常量的指针</span></span><br><span class="line"></span><br><span class="line"><span class="function">Screen <span class="title">myScreen</span><span class="params">(<span class="number">5</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> Screen <span class="title">blank</span><span class="params">(<span class="number">5</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">myScreen.<span class="built_in">set</span>(<span class="string">'#'</span>).display(<span class="built_in">cout</span>); <span class="comment">//调用非常量版本</span></span><br><span class="line">blank.display(<span class="built_in">cout</span>); <span class="comment">//调用常量版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//建议:对于公共代码使用私有功能函数;避免重复代码;随着类的规模发展,display函数有可能变复杂;方便调试;额外的函数调用不会增加任何开销</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="7-3-3-类类型"><a class="header-anchor" href="#7-3-3-类类型">¶</a>7.3.3 类类型</h2>
<ul>
<li>
<p>类的声明</p>
<ul>
<li>
<p>可以仅仅声明类而暂时不定义它</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这种声明被称作前向声明（forward declaration），它向程序中引入了名字 Screen 并且指明 Screen 是一种类类型</li>
<li>对于类型 Screen 来说，在它声明之后定义之前是一个不完全类型（incomplete type），也就是说，此时我们已知 Screen 是一个类类型，但是不清楚它到底包含哪些成员</li>
<li>不完全类型只能在非常有限的情景下使用：可以定义指向这种类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数</li>
</ul>
</li>
<li>
<p>只有当类全部完成后类才算被定义，所有一个类的成员类型不能是该类自己；一旦一个类的名字出现，就被认为声明过（但未定义），因此类允许包含指向它自身类型的引用或指针；</p>
</li>
</ul>
</li>
</ul>
<h2 id="7-3-4-友元再探"><a class="header-anchor" href="#7-3-4-友元再探">¶</a>7.3.4 友元再探</h2>
<ul>
<li>
<p>类之间的友元关系</p>
<ul>
<li>如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员；</li>
<li>友元关系不存在传递性</li>
<li>每个类负责控制自己的友元或友元函数</li>
</ul>
</li>
<li>
<p>令成员函数作为友元</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> &#123;</span></span><br><span class="line">    <span class="comment">//Window_mgr::clear必须在Screen类之前被声明</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> Window_mgr::clear(ScreenIndex);</span><br><span class="line">    <span class="comment">//Screen类的剩余部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>必须仔细组织程序的结构满足声明和定义的彼此依赖关系
<ul>
<li>首先定义Window_mgr类，声明clear函数，但是不能定义它</li>
<li>接下来定义Screen，包括对clear的友元声明</li>
<li>最后定义clear，此时它才可以使用Screen的成员</li>
</ul>
</li>
</ul>
</li>
<li>
<p>函数重载和友元</p>
<ul>
<li>如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中每一个分别声明</li>
</ul>
</li>
<li>
<p>友元声明和作用域</p>
<ul>
<li>类和非成员函数的声明不是必须在它们友元声明之前</li>
<li>当一个名字第一次出现在一个友元声明中时，我们隐式假定该名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中</li>
<li>即使仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的</li>
<li>友元声明的作用是影响访问权限，它本身并非普通意义上的声明</li>
</ul>
</li>
</ul>
<h1>7.4 类的作用域</h1>
<blockquote>
<p>普通数据和函数成员只能由对象、引用或指针使用成员访问运算符来访问。对于类类型成员则使用作用域运算符访问</p>
</blockquote>
<ul>
<li>
<p>作用域和定义在类外部的成员</p>
<ul>
<li>一旦遇到类名，定义的剩余部分就在类的作用域之内了，这里的剩余部分包括参数列表和函数体</li>
<li>返回类型出现在函数名之前，因此定义在类外部时，返回类型中使用的名字都位于类的作用域之外</li>
</ul>
</li>
</ul>
<h2 id="7-4-1-名字查找与类的作用域"><a class="header-anchor" href="#7-4-1-名字查找与类的作用域">¶</a>7.4.1 名字查找与类的作用域</h2>
<ul>
<li>
<p>到目前为止，我们编写的程序中，名字查找（name lookup）（寻找与所用名字最匹配的声明的过程）的过程比较直截了当：</p>
<ul>
<li>首先，在名字所在的块中寻找其声明语句，只考虑在名字的使用之前出现的声明。</li>
<li>如果没找到，继续查找外层作用域。</li>
<li>如果最终没有找到匹配的声明，则程序报错。</li>
</ul>
</li>
<li>
<p>对于定义在类内部的成员函数来说，解析其中名字的方式与上述的查找规则有所区别，不过在当前的这个例子中体现得不太明显。类的定义分两部处理：</p>
<ul>
<li>
<p>首先，编译成员的声明。</p>
</li>
<li>
<p>直到类全部可见后才编译函数体。</p>
</li>
</ul>
</li>
<li>
<p>编译器处理完类中的全部声明后才会处理成员函数的定义。</p>
</li>
<li>
<p>用于类成员声明的名字查找</p>
<ul>
<li>类内函数体在整个类可见后才被处理</li>
<li>如果某个成员的声明使用了类中尚未出现的名字，则编译器会在定义该类的作用域中继续查找</li>
</ul>
</li>
<li>
<p>类型名要特殊处理</p>
<ul>
<li>在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字</li>
</ul>
</li>
<li>
<p>成员定义中的普通块作用域的名字查找</p>
<ul>
<li>首先，在成员函数内查找该名字的声明</li>
<li>如果在成员函数内没找到，则在类内继续查找，这时类的所有成员都可以被考虑</li>
<li>如果类内也没找到该名字的声明，在<strong>成员函数定义之前的作用域</strong>继续查找</li>
</ul>
</li>
<li>
<p>类作用域之后，在外围的作用域中查找</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Screen::dummy_fcn(pos height) &#123;</span><br><span class="line">    cursor = width * ::height; <span class="comment">//用作用域运算符访问外层height</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在文件中名字的出现处对其进行解析</p>
<ul>
<li>当成员定义在类外部，名字查找的第三步不仅要考虑类定义之前的全局作用域中的声明，还要考虑成员函数定义之前的全局作用域中的声明</li>
</ul>
</li>
</ul>
<h1>7.5 构造函数再探</h1>
<h2 id="7-5-1-构造函数初始值列表"><a class="header-anchor" href="#7-5-1-构造函数初始值列表">¶</a>7.5.1 构造函数初始值列表</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Sales_data::Sales_data(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s,</span><br><span class="line">                      <span class="keyword">unsigned</span> cnt, <span class="keyword">double</span> price)&#123;</span><br><span class="line">    bookNo = s;</span><br><span class="line">    units_sold = cnt;</span><br><span class="line">    revenue = cnt * price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sales_data::Sales_data(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p):</span><br><span class="line">                    bookNo(s), units_sold(n), revenue(p*n) &#123; &#125;</span><br><span class="line"><span class="comment">//两种构造函数的区别是，前者是先初始化后赋值，后者是初始化</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>构造函数初始值有时必不可少</p>
<ul>
<li>
<p>如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConstRef</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	ConstRef(<span class="keyword">int</span> ii);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">int</span> i;</span><br><span class="line">    	<span class="keyword">const</span> <span class="keyword">int</span> ci;</span><br><span class="line">    	<span class="keyword">int</span> &amp;ri;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误:ci和ri必须被初始化</span></span><br><span class="line">ConstRef::ConstRef(<span class="keyword">int</span> ii)&#123;</span><br><span class="line">    i = ii;</span><br><span class="line">    ci = ii;<span class="comment">//错误，不能给const赋值</span></span><br><span class="line">    ri = i;<span class="comment">//错误，ri没初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确，显示初始化引用和const成员</span></span><br><span class="line">ConstRef::ConstRef(<span class="keyword">int</span> ii) : i(ii), ci(ii), ri(i) &#123; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>成员初始化顺序</p>
<ul>
<li>
<p>成员的初始化顺序与它们在类定义中的出现顺序一致</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//未定义的:i在j之前被初始化</span></span><br><span class="line">    X(<span class="keyword">int</span> val) : j(val), i(j) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>默认实参和构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_data(<span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="string">""</span>) : bookNo(s) &#123; &#125;</span><br><span class="line"><span class="comment">//如果一个构造函数为所有参数提供了默认实参，则它实际上也定义了默认构造函数</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="7-5-2-委托构造函数"><a class="header-anchor" href="#7-5-2-委托构造函数">¶</a>7.5.2 委托构造函数</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//非委托构造函数使用对应的实参初始化成员</span></span><br><span class="line">        Sales_data(<span class="built_in">std</span>::<span class="built_in">string</span> s,<span class="keyword">unsigned</span> cnt,<span class="keyword">double</span> price):bookNo(s),units_sold(cnt),revenue(price*cnt)&#123;&#125;</span><br><span class="line">        <span class="comment">//其余构造函数全都委托给另一个构造函数</span></span><br><span class="line">        Sales_data():Sales_data(<span class="string">""</span>,<span class="number">0</span>,<span class="number">0</span>)&#123;&#125;</span><br><span class="line">        Sales_data(<span class="built_in">std</span>::<span class="built_in">string</span> s):Sales_data(s,<span class="number">0</span>,<span class="number">0</span>)&#123;&#125;</span><br><span class="line">        Sales_data(<span class="built_in">std</span>::istream &amp;is):Sales_data()</span><br><span class="line">        &#123;</span><br><span class="line">            read(is,*<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//其他成员与之前的版本一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）指责委托给了其他构造函数。</li>
<li>和其他构造函数一样，一个委托构造函数也有一个成员初始值的列表和一个函数体。在委托构造函数体内，成员初始值列表只有一个唯一的入口，就是类名本身。和其他成员初始值一样，类名后面紧跟圆括号括起来的参数列表，参数列表必须与类中另外一个构造函数匹配。</li>
<li>当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行。在Sales_data类中，受委托的构造函数体恰好是空的。假如函数体包含有代码的话，将先执行这些代码，然后控制权才会交还给委托者的函数体。</li>
</ul>
<h2 id="7-5-3-默认构造函数的作用"><a class="header-anchor" href="#7-5-3-默认构造函数的作用">¶</a>7.5.3 默认构造函数的作用</h2>
<ul>
<li>值初始化：
<ul>
<li>
<p>在数组初始化的过程中，如果提供的初始值数量少于数组的大小，剩下的元素会进行值初始化；</p>
</li>
<li>
<p>当我们不使用初始值定义一个局部静态变量时；</p>
</li>
<li>
<p>当我们通过书写形如T()的表达式显示地请求值初始化时；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> <span class="comment">//具有自动和动态存储期的非类变量的默认初始化，产生具有不确定值的对象（静态和线程局部对象进行的是零初始化）</span></span><br><span class="line"><span class="comment">//若 T 是 const 限定类型，则它必须是具有用户提供的默认构造函数的类类型</span></span><br><span class="line"><span class="comment">//不能默认初始化引用</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T1</span> &#123;</span> <span class="keyword">int</span> mem; &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mem;</span><br><span class="line">    T2() &#123; &#125; <span class="comment">// "mem" 不在初始化器列表中</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">// 静态非类，进行两阶段初始化：</span></span><br><span class="line">       <span class="comment">// 1) 零初始化将 n 初始化为零</span></span><br><span class="line">       <span class="comment">// 2) 默认初始化不做任何事，令 n 保留为零</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;            <span class="comment">// 非类，值不确定</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s;    <span class="comment">// 类，调用默认构造函数，值是 ""（空字符串）</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> a[<span class="number">2</span>]; <span class="comment">// 数组，默认初始化其各元素，值是 &#123;"", ""&#125;</span></span><br><span class="line"><span class="comment">//  int&amp; r;           // 错误：引用</span></span><br><span class="line"><span class="comment">//  const int n;      // 错误：const 的非类</span></span><br><span class="line"><span class="comment">//  const T1 t1;      // 错误：const 的带隐式默认构造函数的类</span></span><br><span class="line">    T1 t1;            <span class="comment">// 类，调用隐式默认构造函数</span></span><br><span class="line">    <span class="keyword">const</span> T2 t2;      <span class="comment">// const 类，调用用户提供的默认构造函数</span></span><br><span class="line">                      <span class="comment">// t2.mem 被默认初始化（为不确定值）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>默认初始化：</p>
<ul>
<li>当我们在块作用域内不使用任何初始值定义一个非静态变量时，</li>
<li>当一个类本身含有类类型成员且使用合成的默认构造函数时；</li>
<li>当类类型的成员没有在构造函数初始值列表中显式地初始化时</li>
</ul>
</li>
<li>
<p>类必须包含一个默认构造函数以便在上述情况下使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoDefault</span>&#123;</span></span><br><span class="line"><span class="comment">//没有默认构造函数的类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NoDefault(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;);</span><br><span class="line">	<span class="comment">//还有其他成员，但是没有其他构造函数了</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对应默认初始化的第2中情况</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span> <span class="comment">//默认情况下my_mem是public的</span></span><br><span class="line">	NoDefault my_mem;</span><br><span class="line">&#125;;</span><br><span class="line">A a; <span class="comment">//错误:不能为A合成构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对应默认初始化的第3中情况</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span> </span><br><span class="line">    B() &#123; &#125; <span class="comment">//错误:b_member没有初始值</span></span><br><span class="line">    NoDefault b_member;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//best practice:在实际中，如果定义了其他构造函数，那么最好也提供一个默认构造函数</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果想定义一个使用默认构造函数进行初始化的对象，正确的方法是去掉对象名之后的空的括号对:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_data obj; <span class="comment">//正确:obj是个默认初始化的对象</span></span><br><span class="line"><span class="function">Sales_data <span class="title">obj2</span><span class="params">()</span></span>;<span class="comment">//错误:声明了一个函数而非对象</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="7-5-4-隐式的类类型转换"><a class="header-anchor" href="#7-5-4-隐式的类类型转换">¶</a>7.5.4 隐式的类类型转换</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> null_book = <span class="string">"9-999-99999-9"</span>;</span><br><span class="line"><span class="comment">//构造一个临时的Sales_data对象</span></span><br><span class="line"><span class="comment">//该对象的units_sold和revenue等于0，bookNo等于null_book</span></span><br><span class="line">item.combine(null_book);</span><br><span class="line"><span class="comment">//用一个string实参调用combine，编译器用给定的string自动创建一个Sales_data对象，新生成的这个临时Sales_data对象被传递给combine，因为combine的参数是一个常量引用，所以可以给该参数传递一个临时量</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>只允许一步类类型转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误:需要用户定义的两种转换</span></span><br><span class="line"><span class="comment">//(1)把"9-999-99999-9"转换成string</span></span><br><span class="line"><span class="comment">//(2)再把这个(临时的)string转换成Sales_data</span></span><br><span class="line">item.combine(<span class="string">"9-999-99999-9"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//想完成上述调用，需要下面两次调用</span></span><br><span class="line">item.combine(<span class="built_in">string</span>(<span class="string">"9-999-99999-9"</span>));</span><br><span class="line">item.combine(Sales_data(<span class="string">"9-999-99999-9"</span>));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>类类型转换不是总有效</p>
<ul>
<li>是否需要从string到Sales_data的转换依赖于我们对用户使用该转换的看法</li>
</ul>
</li>
<li>
<p>抑制构造函数定义的隐式转换</p>
<ul>
<li>
<p>将构造函数声明为explicit阻止隐式转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">item.combine(null_book); <span class="comment">//错误:string构造函数是explicit的</span></span><br><span class="line">item.combine(<span class="built_in">cin</span>); <span class="comment">//错误:istream构造函数是explicit的</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>explicit只对一个实参的构造函数有效</p>
</li>
<li>
<p>需要多个实参的构造函数不能用于执行隐式转换，无须将这些构造函数指定为explicit</p>
</li>
<li>
<p>只能在类内声明构造函数时用explicit关键字，在类外部定义时不应重复</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误:explicit关键字只允许出现在类内的构造函数声明处</span></span><br><span class="line"><span class="keyword">explicit</span> Sales_data::Sales_data(istream&amp; is)&#123;</span><br><span class="line">	read(is, *<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>explicit构造函数只能用于直接初始化</p>
<ul>
<li>
<p>发生隐式转换的一种情况是当我们执行拷贝形式的初始化时。此时，只能使用直接初始化而不能使用explicit构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">item1</span><span class="params">(null_book)</span></span>; <span class="comment">//正确:直接初始化</span></span><br><span class="line">Sales_data item2 = null_book;</span><br><span class="line"><span class="comment">//当用explicit声明构造函数，它将只能以直接初始化形式使用。编译器不会再自动转换过程中使用该构造函数</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>为转换显示地使用构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">item.combine(Sales_data(null_book));<span class="comment">//正确:实参是一个显示构造的Sales_data对象</span></span><br><span class="line">item.combine(<span class="keyword">static_cast</span>&lt;Sales_data&gt;(<span class="built_in">cin</span>));<span class="comment">//正确:static_cast可以使用explicit构造函数</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>标准库中含有显示构造函数的类</p>
<blockquote>
<p>用过的一些标准库中的类含有单参数的构造函数</p>
</blockquote>
<ul>
<li>接受一个单参数的const char *的string构造函数不是explicit的</li>
<li>接受一个容量参数的vector构造函数是explicit的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="7-5-5-聚合类"><a class="header-anchor" href="#7-5-5-聚合类">¶</a>7.5.5 聚合类</h2>
<ul>
<li>使得用户可以直接访问其成员，并且具有特殊的初始化语法形式
<ul>
<li>所有成员都是public</li>
<li>没有定义任何构造函数</li>
<li>没有类内初始值</li>
<li>没有基类，也没有virtual函数</li>
</ul>
</li>
<li>如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化</li>
<li>初始值列表的元素个数绝对不能超过类的成员数量</li>
<li>显示初始化类的对象的成员存在三个明显缺点
<ul>
<li>要求类的所有成员是public的</li>
<li>将正确初始化每个对象的每个成员的重任交给了类的用户（而非类的作者）</li>
<li>添加或删除一个成员之后，所有初始化语句都需要更新</li>
</ul>
</li>
</ul>
<h2 id="7-5-6-字面值常量类"><a class="header-anchor" href="#7-5-6-字面值常量类">¶</a>7.5.6 字面值常量类</h2>
<ul>
<li>数据成员都是字面值类型的聚合类是字面值常量类</li>
<li>如果不是聚合类，但它符合下述要求，则它也是一个字面值常量类:
<ul>
<li>数据成员都是字面值类型</li>
<li>类必须至少有一个constexpr构造函数</li>
<li>如果一个数据成员有类内初始值，则内置类型成员的初始值必须是一条常量表达式；如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数</li>
<li>类必须使用析构函数的默认定义，该成员负责销毁类的对象</li>
</ul>
</li>
<li>constexpr构造函数
<ul>
<li>尽管构造函数不能是const的，但是字面值常量类的构造函数可以使constexpr函数</li>
<li>一个字面值常量类必须至少提供一个constexpr构造函数</li>
<li>constexpr构造函数可以声明成=default的形式（或者是删除函数的形式）；否则constexpr构造函数就必须符合构造函数的要求（意味着不能包含返回语句），又符合constexpr函数的要求（意味着它能拥有的唯一可执行语句就是返回语句）。综合这两点可知，constexpr构造函数体一般来说应该是空的</li>
<li>constexpr构造函数必须初始化所有数据成员，初始值或者使用constexpr构造函数，或者是常量表达式</li>
<li>constexpr构造函数用于生成constexpr对象以及constexpr函数的参数或返回类型</li>
</ul>
</li>
</ul>
<h1>7.6 类的静态成员</h1>
<ul>
<li>声明静态成员
<ul>
<li>类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据</li>
<li>静态成员函数不包含this指针，不与任何对象绑定在一起，所以静态成员函数不能声明成const</li>
</ul>
</li>
<li>使用类的静态成员
<ul>
<li>用作用域运算符直接访问静态成员</li>
<li>虽然静态成员不属于类的某个对象，但是仍然可以使用类的对象、引用或者指针来访问静态成员</li>
<li>成员函数不用通过作用域运算符就能直接使用静态成员</li>
</ul>
</li>
<li>定义静态成员
<ul>
<li>可以在类内部，也可以在类外部定义静态成员函数</li>
<li>当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句</li>
<li>静态数据成员不属于类的任何一个对象，它们不是由类的构造函数初始化的，所以必须在类外部定义和初始化每个静态成员，一个静态数据成员只能定义一次</li>
</ul>
</li>
<li>静态成员的类内初始化
<ul>
<li>通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr。初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以它们能用在所有适合于常量表达式的地方</li>
<li>如果某个静态成员的应用场景仅限于编译器可以替换它的值的情况，则一个初始化的const或constexpr static不需要分别定义。相反，如果将它用于值不能直接替换的场景中（比如传给接受const int&amp;的函数时），则该成员必须有一条定义语句</li>
<li>如果在类内部提供了一个初始值，则成员的定义不能再指定一个初始值了</li>
</ul>
</li>
<li>静态成员能用于某些场景，而普通成员不能
<ul>
<li>静态数据成员可以是不完全类型</li>
<li>静态数据成员的类型可以就是它所属的类类型，而非静态数据成员受到限制，只能声明成它所属类的指针或引用</li>
<li>静态成员和普通成员的另外一个区别是我们可以使用静态成员作为默认实参；非静态数据成员不能作为默认实参，因为它的值本身属于对象的一部分</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/14/C-Primer学习笔记：第6章-函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/14/C-Primer学习笔记：第6章-函数/" itemprop="url">C++ Primer学习笔记：第6章 函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-14T22:54:00+08:00">2019-07-14</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>6.1 函数基础</h1>
<h2 id="6-1-1-局部对象"><a class="header-anchor" href="#6-1-1-局部对象">¶</a>6.1.1 局部对象</h2>
<ul>
<li>自动对象
<ul>
<li>函数形参</li>
<li>函数内的局部变量</li>
</ul>
</li>
<li>局部静态对象
<ul>
<li>局部静态变量没有显示初始值，它将执行值初始化，内置类型的局部静态变量初始化为0</li>
</ul>
</li>
</ul>
<h2 id="6-1-2-函数声明"><a class="header-anchor" href="#6-1-2-函数声明">¶</a>6.1.2 函数声明</h2>
<ul>
<li>在头文件中进行函数声明，在源文件中定义</li>
</ul>
<h2 id="6-1-3-分离式编译"><a class="header-anchor" href="#6-1-3-分离式编译">¶</a>6.1.3 分离式编译</h2>
<h1>6.2 参数传递</h1>
<h2 id="6-2-1-传值参数"><a class="header-anchor" href="#6-2-1-传值参数">¶</a>6.2.1 传值参数</h2>
<h2 id="6-2-2-传引用参数"><a class="header-anchor" href="#6-2-2-传引用参数">¶</a>6.2.2 传引用参数</h2>
<h2 id="6-2-3-const形参和实参"><a class="header-anchor" href="#6-2-3-const形参和实参">¶</a>6.2.3 const形参和实参</h2>
<ul>
<li>
<p>实参初始化形参时会忽略掉顶层const。形参的顶层const被忽略掉</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> i = ci;<span class="comment">//正确，拷贝ci时，忽略了它的顶层const</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;i;</span><br><span class="line">*p = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>当形参有顶层const，传给它常量对象或者非常量对象都是可以的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">/* fcun能读取i，但是不能向i写值 */</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>
<p>C++允许定义相同名字的函数，不过前提是不同函数形参列表有明显区别。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span></span>&#123; <span class="comment">/* fcun能读取i，但是不能向i写值 */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123; <span class="comment">/* ... */</span> &#125; <span class="comment">//错误，重复定义了fcn(int)</span></span><br><span class="line"><span class="comment">//因为顶层const忽略掉了，所以可以传入完全一样的参数</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>尽量使用常量引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>::<span class="function">size_type <span class="title">find_char</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">char</span> c, <span class="built_in">string</span>::size_type &amp;occurs)</span></span>;</span><br><span class="line"><span class="comment">//第一个形参应该是const string &amp;类型，否则find_char("Hello World", 'o', ctr);将在编译时发生错误</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_sentence</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span>::size_type ctr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> find_char(s, <span class="string">'.'</span>, ctr) == s.size() - <span class="number">1</span> &amp;&amp; ctr == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果find_char第一个形参是string&amp;，则会发生编译错误，因为s是常量引用，但是find_char只能接受普通引用</span></span><br><span class="line"><span class="comment">//修改思路:要么修改find_char的形参，要么在is_sentence内部定义string类型的对象，令其为s的副本，然后把这个string对象传递给find_char</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="6-2-4-数组形参"><a class="header-anchor" href="#6-2-4-数组形参">¶</a>6.2.4 数组形参</h2>
<ul>
<li>
<p>数组的两个特殊性质</p>
<ul>
<li>不允许拷贝数组
<ul>
<li>不能以值传递的方式使用数组</li>
</ul>
</li>
<li>使用数组通常会将其转换成指针
<ul>
<li>当我们以为传递的是一个数组时，实际上传递的是一个指向数组首元素的指针</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> [])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> [<span class="number">10</span>])</span></span>;</span><br><span class="line"><span class="comment">//上面三个函数等价，每个的唯一形参都是const int *类型，数组的大小对函数调用没有影响</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>数组大小一开始不知道，所以调用者要提供一些额外的信息。管理指针形参的三种技术:</p>
<ul>
<li>
<p>使用标记制定数组长度</p>
<ul>
<li>C风格字符串</li>
</ul>
</li>
<li>
<p>使用标准库规范</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *beg, <span class="keyword">const</span> <span class="keyword">int</span> *end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (beg != end)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *beg++ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> j[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">print(begin(j), end(j));<span class="comment">//使用标准库函数begin和end获取首元素和尾后元素指针</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>显示传递数组大小</p>
</li>
</ul>
</li>
<li>
<p>数组形参和const</p>
</li>
<li>
<p>数组引用形参</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (&amp;arr)[<span class="number">10</span>])</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> elem : arr)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只能作用于大小为10的数组</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>传递多维数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> matrix[][<span class="number">10</span>], <span class="keyword">int</span> rowSize)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="comment">//多维数组传参编译器会忽略掉第一个维度</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="6-2-5-main-处理命令行选项"><a class="header-anchor" href="#6-2-5-main-处理命令行选项">¶</a>6.2.5 main:处理命令行选项</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="comment">//argv是一个数组，元素是指向C风格字符串的指针，argc代表数组中字符串的数量</span></span><br></pre></td></tr></table></figure>
<h2 id="6-2-6-含有可变形参的函数"><a class="header-anchor" href="#6-2-6-含有可变形参的函数">¶</a>6.2.6 含有可变形参的函数</h2>
<ul>
<li>
<p>如果所有实参类型相同，可以传递一个名为initializer_list</p>
<ul>
<li>
<p>模板类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; ls;</span><br><span class="line"><span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; li;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>initializer_list对象中的元素永远是常量值</p>
</li>
<li>
<p>花括号传递值序列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(expected != actual)<span class="comment">//expected, actual是string对象</span></span><br><span class="line">    error_msg(&#123;<span class="string">"functionX"</span>, expected, actual&#125;);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    error_msg(&#123;<span class="string">"functionX"</span>, <span class="string">"okay"</span>&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>如果实参类型不同，也可以编写特殊的函数，也就是所谓的可变参数模板</p>
</li>
<li>
<p>还有一种特殊的形参类型（省略符），只用于和C函数交互的接口程序</p>
<ul>
<li>大多数类类型的对象在传递给省略符形参时都无法正确拷贝</li>
</ul>
</li>
</ul>
<h1>6.3 返回类型和return</h1>
<h2 id="6-3-1-无返回值的函数"><a class="header-anchor" href="#6-3-1-无返回值的函数">¶</a>6.3.1 无返回值的函数</h2>
<h2 id="6-3-2-有返回值的函数"><a class="header-anchor" href="#6-3-2-有返回值的函数">¶</a>6.3.2 有返回值的函数</h2>
<ul>
<li>
<p>值返回的方式和初始化一个变量或者形参的方式完全一样</p>
</li>
<li>
<p>不要返回局部对象的引用或指针</p>
</li>
<li>
<p>返回类类型的函数和调用运算符</p>
</li>
<li>
<p>引用返回左值</p>
<ul>
<li>
<p>可以为返回类型是<strong>非常量引用</strong>的函数的结果赋值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> &amp;<span class="title">get_val</span><span class="params">(<span class="built_in">string</span> &amp;str, <span class="built_in">string</span>::size_type ix)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str[ix];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"a value"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    get_val(s, <span class="number">0</span>) = <span class="string">'A'</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>列表初始化返回值</p>
<ul>
<li>如果列表为空，临时量执行值初始化；否则，返回的值由函数的返回类型决定</li>
</ul>
</li>
<li>
<p>主函数main的返回值</p>
<ul>
<li>允许没有return语句直接结束，如果到达main函数结尾处没有return，编译器将隐式插入一条返回0的return语句</li>
<li>main返回值可以看做状态指示器。cstdlib中定义了两个预处理变量EXIT_FAILURE、EXIT_SUCCESS，可以用作main的返回值</li>
</ul>
</li>
<li>
<p>递归</p>
</li>
</ul>
</li>
</ul>
<h2 id="6-3-3-返回数组指针"><a class="header-anchor" href="#6-3-3-返回数组指针">¶</a>6.3.3 返回数组指针</h2>
<ul>
<li>
<p>声明一个返回数组指针的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Type (*function(parameter_list))[dimension]</span><br><span class="line"><span class="comment">//Type表示元素类型，dimension表示数组大小，(*function(parameter_list))两端括号必须存在</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用尾置返回类型</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto func(int i) -&gt; int(*)[10];//为了表示真正返回类型在形参列表之后，在本该出现返回类型的地方，放置一个auto</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用decltype</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> odd[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> even[] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(odd) *arrPtr(<span class="keyword">int</span> i)&#123;</span><br><span class="line">    <span class="keyword">return</span> (i % <span class="number">2</span>) ? &amp;odd : &amp;even;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>6.4 函数重载</h1>
<ul>
<li>
<p>定义重载函数</p>
<ul>
<li>重载的函数在形参数量或者形参类型上应该有所不同</li>
<li>不允许除了返回类型外其他所有要素都相同</li>
</ul>
</li>
<li>
<p>重载和const形参</p>
<ul>
<li>
<p>顶层const不影响传入函数的对象，一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone)</span></span>; <span class="comment">//重复声明了Record lookup(Phone)</span></span><br><span class="line"></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone*)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone* <span class="keyword">const</span>)</span></span>; <span class="comment">//重复声明了Record lookup(Phone*)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果形参是某种类型的指针或者引用，则通过区分其指向的是常量对象还是非常量对象可以实现重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;<span class="comment">//作用于Account的引用</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account&amp;)</span></span>;<span class="comment">//新函数，作用于常量引用</span></span><br><span class="line"></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account*)</span></span>;<span class="comment">//新函数，作用于Account的引用</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account*)</span></span>;<span class="comment">//新函数，作用于常量引用</span></span><br><span class="line"><span class="comment">//只能把const对象传递给const形参，非常量可以转换成const，所以上面4个函数都能作用于非常量对象或者指向非常量对象的指针</span></span><br><span class="line"><span class="comment">//传递一个非常量对象或者非常量对象的指针时，编译器会优先选用非常量版本的函数</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>const_cast和重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">shorterString</span><span class="params">(<span class="built_in">string</span> &amp;s1, <span class="built_in">string</span> &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;r  = shorterString(<span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s1),</span><br><span class="line">                            <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s2));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="built_in">string</span>&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>调用重载的函数</p>
<ul>
<li>编译器找到一个与实参最佳匹配的函数，并生成调用该函数的代码</li>
<li>找不到匹配的，则发出无匹配的错误信息</li>
<li>有多于一个，但是每个都不是明显的最佳，也将错误，称为二义性调用</li>
</ul>
</li>
</ul>
<h2 id="6-4-1-重载与作用域"><a class="header-anchor" href="#6-4-1-重载与作用域">¶</a>6.4.1 重载与作用域</h2>
<ul>
<li>不同的作用域中无法重载函数名。内层作用域中声明名字，他将隐藏外层作用域中声明的同名实体</li>
</ul>
<h1>6.5 特殊用途语言特性</h1>
<h2 id="6-5-1-默认实参"><a class="header-anchor" href="#6-5-1-默认实参">¶</a>6.5.1 默认实参</h2>
<ul>
<li>
<p>一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值</p>
</li>
<li>
<p>使用默认实参调用函数</p>
<ul>
<li>想使用默认实参，只要在调用函数的时候省略该实参就行了</li>
<li>合理设置形参的顺序，尽量让不怎么用的默认值的形参出现在前面，经常使用默认值的形参出现在后面</li>
</ul>
</li>
<li>
<p>默认实参声明</p>
<ul>
<li>可以在不同地方给同一个函数声明添加默认值，但是添加默认值的形参的右侧的所有形参必须都有默认值，而且后续声明只能为之前那些没有默认值的形参添加默认实参</li>
</ul>
</li>
<li>
<p>默认实参值</p>
<ul>
<li>
<p>局部变量不能作为默认实参。除此之外，只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sz wd = <span class="number">80</span>;</span><br><span class="line"><span class="keyword">char</span> def = <span class="string">' '</span>;</span><br><span class="line"><span class="function">sz <span class="title">ht</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz = ht(), sz = wd, <span class="keyword">char</span> = def)</span></span>;</span><br><span class="line"><span class="built_in">string</span> window = screen(); <span class="comment">//调用screen(ht(), 80, ' ')</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    def = <span class="string">'*'</span>;<span class="comment">//改变了默认形参的值</span></span><br><span class="line">    sz wd = <span class="number">100</span>;<span class="comment">//隐藏了外层的wd，没有改变默认值</span></span><br><span class="line">    window = screen();<span class="comment">//调用screen(ht(), 80, '*')</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="6-5-2-内联函数和constexpr函数"><a class="header-anchor" href="#6-5-2-内联函数和constexpr函数">¶</a>6.5.2 内联函数和constexpr函数</h2>
<ul>
<li>
<p>constexpr函数</p>
<ul>
<li>
<p>用于常量表达式的函数</p>
</li>
<li>
<p>函数的返回类型及所有形参的类型都得是字面值类型，且函数体中必须有且只有一条return语句</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">new_sz</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> foo = new_sz(); <span class="comment">//正确:foo是一个常量表达式</span></span><br><span class="line"><span class="comment">//constexpr函数被隐式指定为内联函数，执行初始化任务时，编译器把对constexpr的调用替换成结果值</span></span><br><span class="line"><span class="comment">//constexpr函数体内可以包含其他语句，只要这些语句在运行时不执行任何操作。例如，constexpr函数中可以有空语句、类型别名以及using声明</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> size_t <span class="title">scale</span><span class="params">(<span class="keyword">size_t</span> cnt)</span> </span>&#123; <span class="keyword">return</span> new_sz() * cnt; &#125;</span><br><span class="line"><span class="comment">//如果arg是常量表达式，则scale(arg)也是常量表达式</span></span><br><span class="line"><span class="keyword">int</span> arr[scale(<span class="number">2</span>)];<span class="comment">//正确:scale(2)是常量表达式</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;<span class="comment">//i不是常量表达式</span></span><br><span class="line"><span class="keyword">int</span> a2[scale(i)];<span class="comment">//错误:scale(i)不是常量表达式</span></span><br><span class="line"><span class="comment">//constexpr函数不一定返回常量表达式</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>把内联函数和constexpr函数放在头文件内</p>
<ul>
<li>内联函数和constexpr函数可以多次定义，一般把定义放在头文件中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="6-5-3-调试帮助"><a class="header-anchor" href="#6-5-3-调试帮助">¶</a>6.5.3 调试帮助</h2>
<ul>
<li>assert预处理宏
<ul>
<li><code>assert(expr);//expr求值，表达式为假，assert输出信息并终止程序的执行；表达式为真，则什么也不做</code></li>
<li>定义在cassert头文件中，预处理名字由预处理器而非编译器管理</li>
</ul>
</li>
<li>NDEBUG
<ul>
<li>#define NDEBUG等价于$CC -D NDEBUG main.c</li>
<li>assert依赖于NDEBUG，如果+定义了NDEBUG，assert什么也不做</li>
</ul>
</li>
</ul>
<h1>6.6 函数匹配</h1>
<ul>
<li>确定候选函数和可行函数</li>
<li>寻找最佳匹配（如果有的话）
<ul>
<li>实参与形参类型越接近，它们匹配的越好</li>
</ul>
</li>
<li>含有多个形参的函数匹配
<ul>
<li>该函数每个实参的匹配都不劣于其他可行函数需要的匹配</li>
<li>至少有一个实参的匹配优于其他可行函数提供的匹配</li>
</ul>
</li>
<li>调用重载函数尽量避免强制类型转换，如果实际应用中确实需要强制类型转换，说明我们设计的形参集合不合理</li>
</ul>
<h2 id="6-6-1-实参类型转换"><a class="header-anchor" href="#6-6-1-实参类型转换">¶</a>6.6.1 实参类型转换</h2>
<ul>
<li>
<p>为了确定最佳匹配，编译器将实参类型到相应形参类型的转换划分等级，转换等级以降序排列如下：</p>
<ol>
<li>
<p>精确匹配。实参与形参类型相同；实参从数组或函数转换为对应的指针类型；向实参添加顶层const或者从实参中删除顶层const</p>
</li>
<li>
<p>通过const转换实现的匹配；</p>
</li>
<li>
<p>通过类型提升实现的匹配；</p>
</li>
<li>
<p>通过算术类型转换或者指针转换实现的匹配；</p>
<ul>
<li>
<p>小整数一般都会提升到int类型或者更大的整数类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff</span><span class="params">(<span class="keyword">short</span>)</span></span>;</span><br><span class="line">ff(<span class="string">'a'</span>);<span class="comment">//char提升成int；调用ff(int)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>所有算术类型转换的级别都一样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">(<span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">(<span class="keyword">float</span>)</span></span>;</span><br><span class="line">manip(<span class="number">3.14</span>);<span class="comment">//错误:二义性调用</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>通过类类型转换实现的匹配。</p>
</li>
</ol>
</li>
<li>
<p>函数匹配和const实参</p>
<ul>
<li>如果重载函数的区别在于它们的引用类型的形参是否引用了const，或者指针类型的形参是否指向const，则当调用发生时编译器通过实参是否是常量来决定选择哪个函数</li>
</ul>
</li>
</ul>
<h1>6.7 函数指针</h1>
<blockquote>
<p>函数的类型由返回类型和形参类型决定，与函数名无关</p>
</blockquote>
<ul>
<li>
<p>使用函数指针</p>
</li>
<li>
<p>重载函数的指针</p>
</li>
<li>
<p>函数指针形参</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三个参数是函数类型，它会自动地转换成指向函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1,<span class="keyword">const</span> <span class="built_in">string</span> &amp;s2,<span class="keyword">bool</span> pf(<span class="keyword">const</span> <span class="built_in">string</span> &amp;,<span class="keyword">const</span> <span class="built_in">string</span> &amp;))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价的声明，显式地将形参定义成指向函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1,<span class="keyword">const</span> <span class="built_in">string</span> &amp;s2,<span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="built_in">string</span> &amp;,<span class="keyword">const</span> <span class="built_in">string</span> &amp;))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们可以直接把函数作为实参使用，此时它会自动转换成指针：</span></span><br><span class="line"><span class="comment">//自动将函数lengthCompare转换成指向该函数的指针</span></span><br><span class="line">useBigger(s1,s2,lengthCompare);</span><br><span class="line"></span><br><span class="line"><span class="comment">//正如useBigger的声明语句所示，直接使用函数指针类型显得冗长而繁琐。类型别名和decltype能让我们简化使用了函数指针的代码：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Func和Func2是函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">bool</span> <span class="title">Func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> Func2</span>;<span class="comment">//等价的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//FuncP和FuncP2是指向函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*FuncP)</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;,<span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> *FuncP2</span>;  <span class="comment">//等价的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//useBigger 的等价声明，其中使用了类型别名</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span> &amp;,Func)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;,<span class="keyword">const</span> <span class="built_in">string</span> &amp;,FuncP2)</span></span>;</span><br><span class="line"><span class="comment">//这两个声明语句声明的是同一个函数，在第一条语句中，编译器自动地将Func表示的函数类型转换成指针。</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>返回指向函数的指针</p>
<ul>
<li>
<p>和数组类似，虽然不能返回一个函数，但是能返回指向函数类型的指针。然而，我们必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型进行处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> F=<span class="keyword">int</span>(<span class="keyword">int</span>*,<span class="keyword">int</span>);  <span class="comment">//F是函数类型，不是指针</span></span><br><span class="line"><span class="keyword">using</span> PF=<span class="keyword">int</span>(*)(<span class="keyword">int</span>*,<span class="keyword">int</span>);   <span class="comment">//PF是指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//和函数类型的形参不一样，返回类型不会自动地转换成指针，我们必须显式地将返回类型指定为指针：</span></span><br><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;   <span class="comment">//正确：PF是指向函数的指针，f1返回指向函数的指针</span></span><br><span class="line"><span class="function">F <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;    <span class="comment">//错误：F是函数类型，f1不能返回一个函数</span></span><br><span class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;  <span class="comment">//正确：显式地指定返回类型是指向函数的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当然，我们也能用下面的形式直接声明f1：</span></span><br><span class="line"><span class="keyword">int</span> (*f1(<span class="keyword">int</span>))(<span class="keyword">int</span> *,<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用尾置类型的方式声明一个返回函数指针的函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto f1(int )-&gt;int(*)(int *,int);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>将auto和decltype用于函数指针类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>::<span class="function">size_type <span class="title">sumLength</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="built_in">string</span>::<span class="function">size_type <span class="title">largerLength</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="comment">//根据其形参的取值，getFcn函数返回指向sumLength或者largerLength的指针</span></span><br><span class="line"><span class="keyword">decltype</span>(sumLength) *getFcn(<span class="keyword">const</span> <span class="built_in">string</span> &amp;);</span><br><span class="line"><span class="comment">//声明getFcn唯一需要注意的地方是牢记当我们将decltype作用于么讴歌函数值，它返回函数类型而非指针类型，因此，我们显式地加上*以表明我们需要返回指针，而非函数本身。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/13/C-Primer学习笔记：第5章-语句/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/13/C-Primer学习笔记：第5章-语句/" itemprop="url">C++ Primer学习笔记：第5章 语句</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-13T19:36:00+08:00">2019-07-13</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>5.1 简单语句</h1>
<ul>
<li>空语句</li>
<li>别漏写分号，也别多写分号</li>
<li>复合语句（块）</li>
</ul>
<h1>5.2 语句作用域</h1>
<blockquote>
<p>这一节有什么意义？</p>
</blockquote>
<h1>5.3 条件语句</h1>
<h2 id="5-3-1-if语句"><a class="header-anchor" href="#5-3-1-if语句">¶</a>5.3.1 if语句</h2>
<ul>
<li>
<p>使用if else语句</p>
</li>
<li>
<p>嵌套if语句</p>
</li>
<li>
<p>注意使用花括号</p>
</li>
<li>
<p>悬垂else（dangling else）</p>
<ul>
<li>else与离它最近的尚未匹配的if匹配</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (grade % <span class="number">10</span> &gt;= <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">if</span> (grade % <span class="number">10</span> &gt; <span class="number">7</span>)</span><br><span class="line">        lettergrade += <span class="string">'+'</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    lettergrade += <span class="string">'-'</span>;</span><br><span class="line"><span class="comment">//上述代码的执行过程和缩进格式不相符，其执行过程实际上等价于如下形式</span></span><br><span class="line"><span class="keyword">if</span> (grade % <span class="number">10</span> &gt;= <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">if</span> (grade % <span class="number">10</span> &gt; <span class="number">7</span>)</span><br><span class="line">        lettergrade += <span class="string">'+'</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        lettergrade += <span class="string">'-'</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用花括号控制执行路径</li>
</ul>
</li>
</ul>
<h2 id="5-3-2-switch语句"><a class="header-anchor" href="#5-3-2-switch语句">¶</a>5.3.2 switch语句</h2>
<ul>
<li>
<p>case关键字和它对应的值一起被称为case标签。case标签必须是整型常量表达式</p>
</li>
<li>
<p>switch内部控制流</p>
<ul>
<li>
<p>case标签匹配成功，将从该标签开始往后顺序执行所有case分支，除非程序显示中断这一过程，否则直到switch结尾才会停下来</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (ch)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'a'</span>:<span class="keyword">case</span> <span class="string">'e'</span>:<span class="keyword">case</span> <span class="string">'i'</span>:<span class="keyword">case</span> <span class="string">'o'</span>:<span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">        ++vowelCnt;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>漏写break容易引发缺陷</p>
</li>
<li>
<p>default标签</p>
<ul>
<li>没有任何一个case标签匹配上的时候，程序会执行紧跟于default之后的语句</li>
<li>如果switch结构以一个空的default标签作为结束，则该default标签后面必须跟上一条空语句或者空块</li>
</ul>
</li>
<li>
<p>switch内部的变量定义</p>
<ul>
<li>
<p>如果在某处一个带有初值的变量位于作用域之外，在另一处该变量位于作用域之内，则从前一处跳转到后一处的行为是非法行为（也就是<strong>跳过带有显示或隐式初始化的变量的声明</strong>）</p>
</li>
<li>
<p>不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置</p>
</li>
<li>
<p>如果要为某个case分支定义并初始化一个变量，应该把变量定义在块内，从而确保后面的所有case都在变量的作用域之外</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">	<span class="comment">//因为程序的执行流程可能绕开下面的初始化语句，所以该switch语句不合法</span></span><br><span class="line">	<span class="built_in">string</span> file_name;<span class="comment">//错误：控制流绕过一个隐式初始化的变量</span></span><br><span class="line">	<span class="keyword">int</span> ival = <span class="number">0</span>;<span class="comment">//错误：控制流绕过一个显示初始化的变量</span></span><br><span class="line">	<span class="keyword">int</span> jval;<span class="comment">//正确：因为jval没有初始化</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">	<span class="comment">//正确：jval虽然在作用域内，但是它没有被初始化</span></span><br><span class="line">	jval = next_num();<span class="comment">//正确：给jval赋一个值</span></span><br><span class="line">	<span class="keyword">if</span> (file_name.empty())<span class="comment">//file_name在作用域内，但是没有被初始化</span></span><br><span class="line">        <span class="comment">//...</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1>5.4 迭代语句</h1>
<h2 id="5-4-1-while语句"><a class="header-anchor" href="#5-4-1-while语句">¶</a>5.4.1 while语句</h2>
<ul>
<li>定义在while条件部分或者while循环体内的变量每次迭代都经历从创建到销毁的过程</li>
<li>使用while循环的场合
<ul>
<li>不确定要迭代多少次</li>
<li>循环后想访问循环控制变量</li>
</ul>
</li>
</ul>
<h2 id="5-4-2-传统for语句"><a class="header-anchor" href="#5-4-2-传统for语句">¶</a>5.4.2 传统for语句</h2>
<ul>
<li>
<p>传统for的执行流程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(initializer;condition;expression) </span><br><span class="line">	statement</span><br></pre></td></tr></table></figure>
</li>
</ul>
<div id="flowchart-0" class="flow-chart"></div>
<ul>
<li>for语句头中的多重声明
<ul>
<li>init-statement可以定义多个对象，但是只能有一条声明语句，所有变量的基础类型必须相同</li>
</ul>
</li>
<li>省略for语句头中的某些部分
<ul>
<li>可以省略任何一个或者全部</li>
</ul>
</li>
</ul>
<h2 id="5-4-3-范围for语句"><a class="header-anchor" href="#5-4-3-范围for语句">¶</a>5.4.3 范围for语句</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for(declaration : expression)</span></span><br><span class="line"><span class="comment">//	statement;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;r : v)</span><br><span class="line">    r *= <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h2 id="5-4-4-do-while语句"><a class="header-anchor" href="#5-4-4-do-while语句">¶</a>5.4.4 do while语句</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//do</span></span><br><span class="line"><span class="comment">//	statement</span></span><br><span class="line"><span class="comment">//while (condition);</span></span><br><span class="line"><span class="comment">//condition使用的变量必须定义在循环体之外</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不允许在条件部分定义变量</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    mumble(foo);</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="keyword">int</span> foo = get_foo());<span class="comment">//错误：将变量声明放在了do的条件部分</span></span><br></pre></td></tr></table></figure>
<h1>5.5 跳转语句</h1>
<h2 id="5-5-1-break语句"><a class="header-anchor" href="#5-5-1-break语句">¶</a>5.5.1 break语句</h2>
<h2 id="5-5-2-continue语句"><a class="header-anchor" href="#5-5-2-continue语句">¶</a>5.5.2 continue语句</h2>
<ul>
<li>只有switch语句嵌套在迭代语句内部，才能在switch里使用continue</li>
<li>continue中断迭代，对于while或者do while来说，继续判断条件的值；对于传统的for循环，继续执行for语句头的expression；对于范围for来说，使用序列中的下一个元素初始化循环控制变量</li>
</ul>
<h2 id="5-5-3-goto语句"><a class="header-anchor" href="#5-5-3-goto语句">¶</a>5.5.3 goto语句</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> label;</span><br><span class="line"></span><br><span class="line">label: statement</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>//goto语句的作用是从goto语句无条件跳转到<strong>同一函数内</strong>的另一条语句</p>
</li>
<li>
<p>标签标示符独立于变量或其他标示符的名字，所以可以和程序中其他实体的标示符用同一个名字而不会互相干扰</p>
</li>
<li>
<p>goto语句和label语句必须在同一个函数之内</p>
</li>
<li>
<p>和switch类似，goto也不能将控制权从变量的作用域之外转移到作用域之内</p>
</li>
<li>
<p>向后跳过一个已经执行的定义是合法的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">begin:</span><br><span class="line">	<span class="keyword">int</span> sz = get_size();</span><br><span class="line">	<span class="keyword">if</span> (sz &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> begin;<span class="comment">//goto执行后销毁sz，sz会重新定义和初始化</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>5.6 try语句块和异常处理</h1>
<blockquote>
<p>异常处理机制为程序中异常检测和异常处理两部分的协作提供支持</p>
</blockquote>
<h2 id="5-6-1-throw表达式"><a class="header-anchor" href="#5-6-1-throw表达式">¶</a>5.6.1 throw表达式</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (item1.isbn() != item2.isbn())</span><br><span class="line">	<span class="keyword">throw</span> runtime_error(<span class="string">"Data must refer to same ISBN"</span>);</span><br><span class="line"><span class="comment">//抛出异常将终止当前函数，并把控制权转移给能处理该异常的代码</span></span><br><span class="line"><span class="comment">//runtime_error定义在stdexcept中</span></span><br></pre></td></tr></table></figure>
<h2 id="5-6-2-try语句块"><a class="header-anchor" href="#5-6-2-try语句块">¶</a>5.6.2 try语句块</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	program-statements</span><br><span class="line">&#125; <span class="keyword">catch</span> (exception-declaration) &#123;</span><br><span class="line">    handler-statements</span><br><span class="line">&#125; <span class="keyword">catch</span> (exception-declaration) &#123;</span><br><span class="line">    handler-statements</span><br><span class="line">&#125;<span class="comment">//...</span></span><br><span class="line"><span class="comment">//catch括号中是一个（可能未命名的）对象的声明，称作异常声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; item1 &gt;&gt; item2) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//执行添加两个Sales_item对象的代码</span></span><br><span class="line">        <span class="comment">//如果添加失败，抛出runtime_error异常</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (runtime_error err) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; err.what()<span class="comment">//what函数返回初始化具体对象时所用的string对象的副本，是一个C风格的字符串(const char *)，what函数没有参数，每个标准库异常类都定义了what函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数在寻找处理代码的过程中退出
<ul>
<li>沿着程序执行路径逐层回退，直到找到适当类型的catch子句为止</li>
<li>如果没有找到匹配的catch子句，则转到名为terminate的标准库函数，此函数的行为与系统有关，一般情况下，执行此函数将导致程序非正常退出。</li>
</ul>
</li>
</ul>
<h2 id="5-6-3-标准异常"><a class="header-anchor" href="#5-6-3-标准异常">¶</a>5.6.3 标准异常</h2>
<ul>
<li>C++标准库定义了一组类，用于报告标准库函数遇到的问题。这些异常类可以在用户编写的程序中使用。
<ul>
<li>exception 头文件定义了最通用的异常类 exception。它只报告异常的发生，不提供任何额外信息</li>
</ul>
</li>
<li>stdexcept 头文件定义了几种常用的异常类
<ul>
<li>new 头文件定义了 bad_alloc 异常类型</li>
<li>type_info 头文件定义了 bad_cast 异常类型</li>
</ul>
</li>
<li>我们只能以默认初始化的方式初始化 exception、bad_alloc 和 bad_cast 对象，不允许为它们提供初始值</li>
<li>其他异常类型的行为则恰好相反：应该使用 string 对象或者 C 风格字符串初始化这些类型的对象，但是不允许使用默认初始化的方式</li>
<li>what 函数返回的 C 风格字符串的内容与其他异常对象的类型有关。如果异常类型有一个字符串初始值，则 what 返回该字符串。对于其他无初始值的异常类型来说，what 返回的内容也由编译器决定<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Start
ed=>end: End
cond1=>condition: condition
init=>operation: initializer
statement=>operation: statement
expr=>operation: expression
st->init
init->cond1
cond1(no)->ed
cond1(yes)->statement
statement->expr
expr->cond1</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/12/C-Primer学习笔记：第4章-表达式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/12/C-Primer学习笔记：第4章-表达式/" itemprop="url">C++ Primer学习笔记：第4章 表达式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-12T19:15:00+08:00">2019-07-12</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>4.1 基础</h1>
<ul>
<li>
<p>4.1.1 基本概念</p>
<ul>
<li>组合运算符和运算对象
<ul>
<li>优先级、结合律、求值顺序</li>
</ul>
</li>
<li>运算对象转换</li>
<li>运算符重载
<ul>
<li>运算对象个数，优先级和结合律无法改变</li>
</ul>
</li>
<li>左值和右值
<ul>
<li>当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值时，用的是对象的身份（内存中的位置）</li>
<li>在需要右值的地方可以用左值代替，但是不能把右值当成左值（位置）使用。当一个左值被当成右值使用时，实际使用的是它的内容。</li>
<li>内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector下标运算符的求值结果都是左值</li>
<li>内置类型和迭代器的递增递减运算符作用于左值对象，其前置版的结果亦是左值</li>
<li>如果表达式求值结果是左值，decltype作用于该表达式（不是变量）得到一个引用类型。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>4.1.2 优先级与结合律</p>
<ul>
<li>结合律：从右到左，还是从左到右</li>
<li>优先级：乘法和除法的优先级相同且都高于加法优先级</li>
<li>括号无视优先级和结合律</li>
</ul>
</li>
<li>
<p>4.1.3 求值顺序</p>
<ul>
<li>只有4种运算符明确规定了运算对象的求值顺序（&amp;&amp; 、|| 、?:和,）</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结合律和优先级确定的是运算符的运算对象是谁，但并没有规定算的顺序。2+3*4+5它的结合性是(2+(3*4))+5，但是不代表3*4是最先计算的，它的计算次序是未知的，未定义的。比如3*4-&gt;2+3*4-&gt;2+3*4+5以及2-&gt;3*4-&gt;2+3*4-&gt;2+3*4+5和5-&gt;3*4-&gt;2+3*4-&gt;2+3*4+5这些次序都是有可能的。虽然它们的计算次序不同，但是对最终结果是没有影响的。</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>求值顺序、优先级、结合律</p>
<ul>
<li>运算对象的求值顺序与优先级和结合律无关</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如f()+g()*h()+j()，如果f,g,h,j会改变同一对象，则是错误表达式，会产生未定义行为</span><br></pre></td></tr></table></figure>
<ul>
<li>两个处理复合表达式的原则
<ul>
<li>拿不准的时候用括号</li>
<li>如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算符。改变运算对象的子表达式本身就是另外一个子表达式的运算对象时，该规则无效。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1>4.2 算术运算符</h1>
<table>
<thead>
<tr>
<th>运算符</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>一元正号</td>
<td>+ expr</td>
</tr>
<tr>
<td>-</td>
<td>一元负号</td>
<td>- expr</td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
<td>expr*expr</td>
</tr>
<tr>
<td>/</td>
<td>除法</td>
<td>expr/expr</td>
</tr>
<tr>
<td>%</td>
<td>求余</td>
<td>expr%expr</td>
</tr>
<tr>
<td>+</td>
<td>加法</td>
<td>expr+expr</td>
</tr>
<tr>
<td>-</td>
<td>减法</td>
<td>expr-expr</td>
</tr>
</tbody>
</table>
<ul>
<li>以上表格运算符均为左结合律</li>
<li>除法运算，结果为负值时向0取整</li>
<li>根据取余运算定义，如果m，n是整数且n非0，则表达式（m/n）*n+m%n的结果与m相等。即如果m%n不等于0，则其符号与m相同。除了-m导致溢出的情况，其他时候(-m)/n和m/(-n)都等于-(m/n)，m%(-n)等于m%n，(-m)%n等于-(m%n)</li>
</ul>
<h1>4.3 逻辑和关系运算符</h1>
<table>
<thead>
<tr>
<th>结合律</th>
<th>运算符</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>右</td>
<td>!</td>
<td>逻辑非</td>
<td>!expr</td>
</tr>
<tr>
<td>左</td>
<td>&lt;</td>
<td>小于</td>
<td>expr&lt;expr</td>
</tr>
<tr>
<td>左</td>
<td>&lt;=</td>
<td>小于等于</td>
<td>expr&lt;=expr</td>
</tr>
<tr>
<td>左</td>
<td>&gt;</td>
<td>大于</td>
<td>expr&gt;expr</td>
</tr>
<tr>
<td>左</td>
<td>&gt;=</td>
<td>大于等于</td>
<td>expr&gt;=expr</td>
</tr>
<tr>
<td>左</td>
<td>==</td>
<td>相等</td>
<td>expr==expr</td>
</tr>
<tr>
<td>左</td>
<td>!=</td>
<td>不相等</td>
<td>expr!=expr</td>
</tr>
<tr>
<td>左</td>
<td>&amp;&amp;</td>
<td>逻辑与</td>
<td>expr&amp;&amp;expr</td>
</tr>
<tr>
<td>左</td>
<td>||</td>
<td>逻辑或</td>
<td>expr||expr</td>
</tr>
</tbody>
</table>
<ul>
<li>关系运算符作用于算术或指针类型，逻辑运算符作用于能转换成布尔值的类型</li>
<li>逻辑与和逻辑或
<ul>
<li>短路求值</li>
</ul>
</li>
<li>逻辑非</li>
<li>关系运算符
<ul>
<li>不要连写，如i &lt; j &lt; k</li>
</ul>
</li>
<li>相等性测试与布尔字面值
<ul>
<li><code>if(val==true)</code>是有问题的写法，因为比较之前会将true转换成val类型，则代码可以改写成`if(val==1)</li>
<li>进行比较运算时，除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为运算对象</li>
</ul>
</li>
</ul>
<h1>4.4 赋值运算符</h1>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">初始值列表赋值时，如果左侧对象是内置类型，则初值列表最多只能包含一个值，而且该值即使转换其空间也不应该大于目标类型空间。</span><br></pre></td></tr></table></figure>
<ul>
<li>赋值运算满足右结合律</li>
<li>赋值运算符优先级较低
<ul>
<li>条件语句中的赋值部分应该加上括号</li>
</ul>
</li>
<li>切勿混淆相等运算符和赋值运算符</li>
<li>复合赋值运算符(如+=,-=,…)
<ul>
<li>和对应的非复合赋值表达式的区别在于左侧对象的求值次数:复合运算符只求值一次，普通运算符求值两次</li>
</ul>
</li>
</ul>
<h1>4.5 递增递减运算符</h1>
<ul>
<li>除非必须，否则不用递增递减运算符的后置版本</li>
<li>在一条语句中混用解引用和递增</li>
<li>运算对象可按任意顺序求值，如<code>*beg = toupper(*beg++)</code>将产生未定义的行为</li>
</ul>
<h1>4.6 成员访问运算符</h1>
<ul>
<li>
<p>解引用运算符优先级低于点运算符，如<code>*p.size()</code>等价于<code>*(p.size())</code></p>
</li>
<li>
<p><strong>箭头运算符作用于一个指针类型的运算对象，结果是一个左值；</strong></p>
</li>
<li>
<p>点运算符分两种情况</p>
<ul>
<li>
<p>如果成员所属对象是左值，则结果是左值；</p>
</li>
<li>
<p>反之，如果成员所属对象是右值，则结果是右值；</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    A() = <span class="keyword">default</span>;</span><br><span class="line">    A(<span class="keyword">int</span> m): n(m) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">st</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    A* pst = &amp;st;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; st.n &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//输出5，st是左值，在该表达式执行完毕后依然存在</span></span><br><span class="line">    st.n = <span class="number">6</span>;               <span class="comment">//合法，可以对左值赋值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pst-&gt;n &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出6，pst是左值，在该表达式执行完毕后依然存在</span></span><br><span class="line">    pst-&gt;n = <span class="number">7</span>;             <span class="comment">//合法，可以对左值赋值</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; A(<span class="number">8</span>).n &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出8，A(8)是右值，在该表达式执行完毕后被销毁</span></span><br><span class="line">    A(<span class="number">8</span>).n = <span class="number">9</span>;             <span class="comment">//非法，不能对右值赋值</span></span><br><span class="line">    pst = &amp;(A(<span class="number">8</span>));          <span class="comment">//非法，不能取右值的地址</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为指针所指的对象一定是一个左值，所以使用-&gt;返回的成员也一定是左值。而对右值对象调用成员调用运算符（.）是合法行为，但是这个被调用的成员在对象被销毁时也一并被销毁，所以整个成员也是右值。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1>4.7 条件运算符(?:)</h1>
<ul>
<li>当条件运算符两个表达式都是左值或者能转换成同一种左值类型时，则运算的结果是左值；否则运算结果是右值</li>
</ul>
<blockquote>
<p>关于“能转换成同一种左值类型时，则运算的结果是左值”的问题:</p>
<p>I read this post to get an overview of the type and value category returned from the conditional operator: <a href="https://stackoverflow.com/questions/8535226/return-type-of-ternary-conditional-operator" target="_blank" rel="noopener">Return type of ‘?:’ (ternary conditional operator)</a></p>
<p>That answers pretty much my question, except the phrasing in C++ Primer to describe the same thing confuses me slightly.</p>
<p>“That result of the conditional operator is an lvalue if both expressions are lvalues <strong>or if they convert to a common lvalue type</strong>. Otherwise the result is an rvalue.”</p>
<p>The bolded bit throws me off. This would suggest to me that, for instance</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">&gt;     <span class="keyword">char</span> z = <span class="number">3</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     ((<span class="number">50</span>&lt;<span class="number">60</span>) ? y : z) = <span class="number">3</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>would be fine, because y and z can be both converted to int (well, z would be the one converted) which is an lvalue type (right?), thus the conditional operator would give an lvalue as its value category. This codedoes not compile however, because it actually gives out an rvalue. Can anyone provide an example of the exceptional case mentioned by the bolded bit, so I can understand what point it’s trying to make?</p>
<p>My understanding seems to be that: If the expression are lvalues of the same type, then an lvalue of that type is returned. Otherwise an rvalue (of some compiler-determined type) is returned.</p>
<p>解答:</p>
<p>If <code>z</code> is converted to <code>int</code>, the lvalue-to-rvalue conversion has already been applied, and the result is a prvalue, not an lvalue.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; int a = 10;</span><br><span class="line">&gt; (long)a = 1;//非法，因为a发生了左值到右值(lvalue-to-rvalue)的类型转换，(long)a是右值</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>One example of <code>?:</code> where the two operands have different types, but the result is an lvalue, is when one is <code>const</code>-qualified and the other isn’t:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">const</span> <span class="keyword">int</span> &amp;<span class="title">f</span><span class="params">(<span class="keyword">bool</span> a, <span class="keyword">int</span> &amp;b, <span class="keyword">const</span> <span class="keyword">int</span> &amp;c)</span> </span>&#123;</span><br><span class="line">&gt;   <span class="comment">// b has type int, c has type const int, the result is an lvalue of type const int</span></span><br><span class="line">&gt;   <span class="keyword">return</span> a ? b : c;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>Another example is where one is a class with a custom conversion operator:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">&gt;   <span class="keyword">operator</span> <span class="keyword">int</span>&amp;();</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; <span class="function"><span class="keyword">int</span> &amp;<span class="title">f</span><span class="params">(<span class="keyword">bool</span> a, <span class="keyword">int</span> &amp;b, S &amp;c)</span> </span>&#123;</span><br><span class="line">&gt;   <span class="comment">// b has type int, c has type S, the result is an lvalue of type int</span></span><br><span class="line">&gt;   <span class="comment">// if a is false, c's conversion operator is called</span></span><br><span class="line">&gt;   <span class="keyword">return</span> a ? b : c;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>
<p>嵌套条件运算符</p>
<ul>
<li>右结合律</li>
<li>条件运算的嵌套最好别超过两到三层。</li>
</ul>
</li>
<li>
<p>在输出表达式中使用条件运算符</p>
<ul>
<li>
<p>条件运算符的优先级非常低，因此当一条长表达式中嵌套了条件运算子表达式时，通常需要加上括号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; ((grade &lt; <span class="number">60</span>) ? <span class="string">"fail"</span> : <span class="string">"pass"</span>);<span class="comment">//输出pass或fail</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (grade &lt; <span class="number">60</span>) ? <span class="string">"fail"</span> : <span class="string">"pass"</span>;<span class="comment">//输出1或者0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; grade &lt; <span class="number">60</span> ? <span class="string">"fail"</span> : <span class="string">"pass"</span>;<span class="comment">//错误，师徒比较cout和60</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1>4.8 位运算符</h1>
<ul>
<li>位运算符（左结合律）</li>
</ul>
<table>
<thead>
<tr>
<th>运算符</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>~</td>
<td>位求反</td>
<td>~expr</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移</td>
<td>expr1&lt;&lt;expr2</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
<td>expr1&gt;&gt;expr2</td>
</tr>
<tr>
<td>&amp;</td>
<td>位与</td>
<td>expr&amp;expr</td>
</tr>
<tr>
<td>^</td>
<td>位异或</td>
<td>expr^expr</td>
</tr>
<tr>
<td>|</td>
<td>位或</td>
<td>expr|expr</td>
</tr>
</tbody>
</table>
<ul>
<li>移位运算符
<ul>
<li>运算对象如果是“小整型”，则它的值会被自动提升成较大整型</li>
<li>左侧运算对象按照右侧的要求移动位数，然后将经过移动的（可能进行了类型提升）左侧运算对象的拷贝作为求值结果。其中右侧运算对象一定不能为负，而且值必须严格小于结果的位数。</li>
<li>左移右侧插入0</li>
<li>右移根据有无符号和具体环境</li>
</ul>
</li>
<li>位求反运算符
<ul>
<li>char类型首先提升成int类型，然后逐位求反</li>
</ul>
</li>
<li>位与、位或、位异或运算符</li>
<li>使用位运算符
<ul>
<li>unsigned long在任何机器上都至少有32位</li>
</ul>
</li>
<li>移位运算符（IO运算符）满足左结合律
<ul>
<li>移位运算符优先级不高不低，介于中间：比算术运算符优先级低，但是比关系运算符、赋值运算符和条件运算符要高</li>
</ul>
</li>
</ul>
<h1>4.9 sizeof运算符</h1>
<ul>
<li>形式
<ul>
<li><code>sizeof (type)</code></li>
<li><code>sizeof expr</code></li>
</ul>
</li>
<li>sizeof满足右结合律并且和*解引用运算符优先级一样，所以以下两者等价
<ul>
<li><code>sizeof *p</code></li>
<li><code>sizeof(*p)</code></li>
</ul>
</li>
<li>C++11允许使用作用域运算符获取类成员大小
<ul>
<li>sizeof运算符的结果部分依赖于其作用的类型</li>
<li>引用类型返回被引用对象的空间的大小</li>
<li>对指针执行sizeof运算返回的是指针所占的空间的大小</li>
<li>对指针解引用执行sizeof运算，返回其指向的对象的所占空间大小。</li>
<li>对指针解引用执行sizeof运算，不需要其指向对象有效，只要有类型即可。</li>
<li>对数组进行sizeof运算，返回的是数组的大小，也就是相当于对数组的所有元素执行一次sizeof 并且相加！</li>
<li>对string和vector对象进行sizeof运算只返回该类型固定部分的大小，不会计算对象元素占用多少空间</li>
</ul>
</li>
<li>sizeof返回值是常量表达式，可以用sizeof结果声明数组的维数</li>
</ul>
<h1>4.10 运算符</h1>
<ul>
<li>逗号运算符和逻辑与，逻辑或，条件运算符一样，也规定了运算对象的求值顺序</li>
<li>逗号运算符的真正结果是右侧表达式的值。右侧对象如果是左值，则最终结果也是左值</li>
</ul>
<h1>4.11 类型转换</h1>
<ul>
<li>
<p>何时转换</p>
<ul>
<li>在大多数表达式中，比int小的首先提升为较大整数类型</li>
<li><strong>在条件中</strong>，非布尔值转换成布尔</li>
<li>初始化时，初始值转换为变量的类型；赋值语句右侧转为左侧的类型</li>
<li>算术或关系的运算对象需要转换成同一种类型</li>
<li>函数调用也会发生转换</li>
</ul>
</li>
<li>
<p>4.11.1 算术转换</p>
<ul>
<li>
<p>整型提升</p>
</li>
<li>
<p>char类型提升成int，unsigned int，long，unsigned long、long long和unsigned long long中最小的一种类型</p>
</li>
<li>
<p>无符号类型运算对象</p>
<ul>
<li>首先，整型提升。如果类型匹配（同为有符号或无符号），则小类型转为大类型</li>
<li>如果一个是有符号，一个无符号，无符号类型不小于有符号类型，则有符号转换成无符号的类型。如unsigned int和int，int转换成unsigned int</li>
<li>如果有符号大于无符号类型，此时依赖于机器。如果无符号<strong>所有值都能存在有符号类型中</strong>，则无符号转成有符号的类型；否则有符号转换成无符号类型。如long和unsigned int，大小相同，则long转为unsigned int；否则，unsigned int转为long</li>
</ul>
</li>
<li>
<p>4.11.2 其它隐式类型转换</p>
<ul>
<li>数组转换成指针
<ul>
<li>当数组用作decltype的参数，或者取地址符、sizeof和typeid的运算对象时，不会发生转换</li>
<li>初始化一个数组的引用时，也不会发生转换</li>
</ul>
</li>
<li>指针转换
<ul>
<li>常量整数值0或字面值nullptr能转换成任意指针类型</li>
<li>指向任意非常量的指针可以转换成void*</li>
<li>指向任意对象的指针可以转换成const void*</li>
</ul>
</li>
<li>转换成bool类型
<ul>
<li>如果指针或算术类型的值为0，转换结果为false，否则为true</li>
</ul>
</li>
<li>转换成常量
<ul>
<li>允许将指向非常量类型的指针转换成指向相应的常量类型指针，反过来不行</li>
</ul>
</li>
<li>类类型的转换
<ul>
<li>类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换</li>
<li>istream类对象向bool值转换时，读入成功，则转成true；读入失败，转成false</li>
</ul>
</li>
</ul>
</li>
<li>
<p>4.11.3 显示转换</p>
<ul>
<li>
<p>命名的强制转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cast-name&lt;type&gt;(expression);<span class="comment">//type是目标类型，expression是要转换的值，cast-name是static_cast、dynamic_cast、const_cast和reinterpret_cast中的一种，用来指定执行的转换类型</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>static_cast</p>
<ul>
<li>
<p>任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进行强制类型转换以便执行浮点数除法</span></span><br><span class="line"><span class="keyword">double</span> slope = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(j) / i;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>const_cast</p>
<ul>
<li>
<p>const_cast<strong>只能改变运算对象的底层const</strong>。对于将常量对象转换成非常量对象的行为，我们一般称为“<strong>去掉cosnt性质</strong>”。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *pc;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(pc);  <span class="comment">// 正确：但是通过p写值是未定义的行为</span></span><br><span class="line"><span class="comment">// 一旦去掉某个对象的const性质，编译器就不再阻止我们对该对象进行写操作了</span></span><br><span class="line"><span class="comment">//如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为</span></span><br><span class="line"><span class="comment">//如果对象是一个常量，再使用const_cast执行写操作就会产生未定义的后果</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>const_cast只能也只有const_cast能用来改变表达式的常量属性，不能用const_cast改变变量类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> <span class="keyword">char</span> *cp;</span><br><span class="line"> <span class="keyword">char</span> *q = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span> *&gt;(cp);   <span class="comment">// 错误：static_cast不能转换掉const性质</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="built_in">string</span>&gt;(cp);     <span class="comment">// 正确：字符串字面值转换成stirng类型    </span></span><br><span class="line"><span class="keyword">const_cast</span>&lt;<span class="built_in">string</span>&gt;(cp);    <span class="comment">// 错误：const_cast只能改变常量属性</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>reinterpret_cast</p>
<ul>
<li>reinterpret_cast 通常为运算对象的位模式提供较低层次上的<strong>重新解释</strong>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip;</span><br><span class="line"><span class="keyword">char</span> *pc = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(ip);  <span class="comment">// 我们必须牢记pc所指真实对象是一个int而非字符</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>旧式的强制类型转换：</p>
</li>
</ul>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *pc = (<span class="keyword">char</span> *) ip;    <span class="comment">// ip是指向整数的指针</span></span><br><span class="line"><span class="comment">// 效果与使用reinterpret_cast一样</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/12/C-Primer学习笔记：第3章-字符串、向量和数组/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/12/C-Primer学习笔记：第3章-字符串、向量和数组/" itemprop="url">C++ Primer学习笔记：第3章 字符串、向量和数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-12T13:22:00+08:00">2019-07-12</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>
<p>string上的操作</p>
<ul>
<li>
<p>读写</p>
</li>
<li>
<p>getline(cin,line)</p>
<ul>
<li>getline返回的是流参数cin,而不是line</li>
</ul>
</li>
<li>
<p>empty，size函数</p>
</li>
<li>
<p>string::size_type</p>
<ul>
<li>s.size &lt; n，n为负数时，判断结果肯定是True</li>
<li>一条表达式如果已经用size()，就别用int，避免有无符号数混用</li>
</ul>
</li>
<li>
<p>比较大小，大小写敏感</p>
</li>
<li>
<p>对象直接赋值</p>
</li>
<li>
<p>string对象相加</p>
</li>
<li>
<p>字面值和string对象相加</p>
<ul>
<li>字符串和字符字面值都能转化为string类型</li>
<li>加法运算符两侧的运算对象至少有一个是string</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s6 = s1 +<span class="string">","</span>+<span class="string">"world"</span><span class="comment">//正确，（s1+","）是string对象，再"world"运算</span></span><br><span class="line"><span class="built_in">string</span> s7 = <span class="string">","</span>+<span class="string">"world"</span>+s1<span class="comment">//错误，第一个加法运算符两侧都是字面值</span></span><br></pre></td></tr></table></figure>
<ul>
<li>字符串字面值和string是不同对象</li>
</ul>
</li>
</ul>
</li>
<li>
<p>处理string中的字符</p>
<ul>
<li>cctype头文件（isalnum,isalpha,iscntrl,isdigit,isgraph,islowe,isprint,ispunct,isspace,isupper,isxdigit,tolower,toupper）
<ul>
<li>C++头文件和C语言头文件的对应关系:cname&lt;—&gt;name.h</li>
<li>区别:C语言头文件中定义的名字不是std命名空间，而C++是</li>
</ul>
</li>
<li>处理每个字符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(auto c : str)</span><br><span class="line">	cout &lt;&lt; c &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用for修改字符串中字符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(auto &amp;c : s)</span><br><span class="line">	c = toupper(c);</span><br></pre></td></tr></table></figure>
<ul>
<li>只处理一部分字符
<ul>
<li>下标(类型为string::size_type，可以确保大于0，但是要检查是否小于s.size())</li>
<li>迭代器</li>
</ul>
</li>
</ul>
</li>
<li>
<p>标准库类型vector</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.vector是模板而非类型，类型要包含元素类型，如vector&lt;int&gt;</span><br><span class="line">2.元素为vector的vector对象，要在外层的右尖括号和元素类型之间加一个空格，如vector&lt;vector&lt;int&gt; &gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义和初始化vector对象</li>
</ul>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;T&gt; v3(n, val);</span><br><span class="line">  	<span class="built_in">vector</span>&lt;T&gt; v4(n);<span class="comment">//n个进行了值初始化的对象</span></span><br><span class="line">  	<span class="built_in">vector</span>&lt;T&gt; v5&#123;a,b,c...&#125;</span><br></pre></td></tr></table></figure>
<pre><code>  - 列表初始化注意事项，C++初始化方式互相等价使用的例外
      - 使用拷贝初始化，只能提供一个初始值
      - 如果提供类内初始值，则只能用拷贝初始化或者花括号形式初始化，不能使用
      - 如果提供初始元素值的列表。则只能把初始值都放在花括号里进行列表初始化，不能放在圆括号里
  - 创建指定数量的元素
  - 值初始化
      - 必须要类型支持
      - 只能使用直接初始化，不能用拷贝初始化
  - 圆括号和花括号
      - 圆括号是用提供的值来构造vector对象的，提供的值是容量和元素初始值的信息
      - 花括号提供的一般是元素初始值的列表，只有提供的值无法拿来执行列表初始化时才会考虑用这样的值来构造vector对象
</code></pre>
<ul>
<li>向vector中添加元素</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector对象高效增长，除非所有元素值都一样，否则最好先定一个空vector，再在运行时向其添加具体值</span><br></pre></td></tr></table></figure>
<pre><code>- 循环体内部包含有向vector添加元素的语句，则不能使用范围for循环，即for语句体内不应该改变其所遍历序列的大小
</code></pre>
<ul>
<li>其他vector操作</li>
</ul>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">v.empty()</span><br><span class="line">v.size()</span><br><span class="line">v.push_back()</span><br><span class="line">v[n]<span class="comment">//返回第n个位置上元素的引用</span></span><br><span class="line">v1 = v2</span><br><span class="line">v1 = &#123;a,b,c...&#125;</span><br><span class="line">v1 == v2</span><br><span class="line">v1 != v2</span><br><span class="line">&lt;,&lt;=,&gt;,&gt;=</span><br></pre></td></tr></table></figure>
<ul>
<li>vector<int>::size_type和vector::size_type的区别
<ul>
<li>vector<int>::size_type是内部元素的size()返回类型</int></li>
<li>vector::size是vector的size()的返回类型</li>
</ul>
</int></li>
<li>不能用下标形式添加元素，会造成缓冲区溢出，尽可能使用范围for语句</li>
</ul>
</li>
<li>
<p>迭代器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">所有标准库容器都可以使用迭代器，而下标运算符只有少数几种支持。</span><br><span class="line">string不属于容器类型，但是支持很多与容器类型类似的操作。</span><br><span class="line">类似指针，迭代器提供了对对象的间接访问。有效迭代器指向某个元素，或者指向容器中尾元素的下一位置</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>使用迭代器</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto b = v.begin(), e = v.end();</span><br></pre></td></tr></table></figure>
<ul>
<li>begin成员返回第一个元素的迭代器，end返回尾元素下一位置的迭代器，即“尾后迭代器”</li>
</ul>
</li>
<li>
<p>迭代器运算符</p>
<ul>
<li>迭代器用法类似于指针</li>
<li>同样和指针类似，可以用解引用运算符来获取元素</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s(&quot;something&quot;)</span><br><span class="line">if (s.begin() != s.end())&#123;</span><br><span class="line">	auto it = s.begin();</span><br><span class="line">	*it = toupper(*it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>移动迭代器</p>
<ul>
<li>++it</li>
<li>–it</li>
</ul>
</li>
<li>
<p>迭代器类型</p>
<ul>
<li>有迭代器的标准库类型用iterator和const_iterator表示迭代器类型</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;::iterator it;</span><br><span class="line">vector&lt;int&gt;::const_iterator it2;</span><br></pre></td></tr></table></figure>
<ul>
<li>常量vector对象只能用const_iterator</li>
<li>cbegin(),cend()不论vector是不是常量，都返回const_iterator迭代器</li>
</ul>
</li>
<li>
<p>解引用和成员运算符结合</p>
<ul>
<li>(*it).empty()等价于it-&gt;empty()</li>
</ul>
</li>
<li>
<p>某些对vector的操作会使迭代器失效</p>
<ul>
<li>任何一种可能改变vector对象容量的操作，都会使该vector对象的迭代器失效</li>
</ul>
</li>
<li>
<p>迭代器运算</p>
</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iter + n</span><br><span class="line">iter - n</span><br><span class="line">iter += n</span><br><span class="line">iter -= n</span><br><span class="line">iter1 - iter2</span><br><span class="line">&gt;、&gt;=、&lt;、&lt;=</span><br></pre></td></tr></table></figure>
<pre><code>  - 迭代器算术运算
      - 迭代器相减返回difference_type的有符号整数
  - 可以用迭代器实现二分查找
</code></pre>
</li>
<li>
<p>数组</p>
<ul>
<li>
<p>定义和初始化</p>
<ul>
<li>定义时必须显示指定数组类型，数组元素应该为对象</li>
<li>字符数组可以用字符串字面值初始化，大小为字符串字符数加上一个空字符</li>
<li>理解数组声明的含义，最好办法是从数组名字开始按照由内向外的顺序阅读</li>
</ul>
</li>
<li>
<p>访问数组</p>
<ul>
<li>下标为size_t类型，机器相关的无符号类型，在cstddef头文件中定义</li>
<li>数组的下标运算符是C++语言直接定义，而vector的下标运算符是库模板vector定义的，只能用于vector类型的运算对象</li>
</ul>
</li>
<li>
<p>指针和数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int ia[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;</span><br><span class="line">auto ia2(ia);//ia2是一个整型指针</span><br><span class="line">decltype(ia) ia3;//ia3是一个含有10个整数的数组</span><br></pre></td></tr></table></figure>
<ul>
<li>指针也是迭代器
<ul>
<li>尾后指针需要通过<code>int *e = &amp;arr[10];</code>来获取</li>
</ul>
</li>
<li>标准库函数begin，end
<ul>
<li>int *pbeg = begin(arr), int *pend = end(arr);</li>
<li>尾后指针不能解引用和递增</li>
</ul>
</li>
<li>指针运算
<ul>
<li>指针相减结果类型是ptrdiff_t，定义在cstddef头文件，带符号</li>
</ul>
</li>
<li>解引用和指针运算交互</li>
<li>下标和指针
<ul>
<li>内置的下标运算符可以处理负值，比如<code>int *p = &amp;ia[2];int k = p[-2]</code>，p[-2]代表的是数组首元素</li>
</ul>
</li>
</ul>
</li>
<li>
<p>C风格字符串</p>
</li>
<li>
<p>和旧代码的接口</p>
<ul>
<li>混用string和C风格字符串
<ul>
<li>用字符数组代替string
<ul>
<li>允许用字符数组初始化或者赋值string对象</li>
<li>string对象的加法运算允许使用字符数组作为其中一个运算对象，在string对象复合赋值运算中允许使用空字符结束的字符数组作为右侧运算对象</li>
</ul>
</li>
<li>用string不能直接代替字符数组，需要通过string的c_str()方法获得对应的字符数组
<ul>
<li>c_str获得的字符数组可能因为原string的改变失去效用</li>
</ul>
</li>
</ul>
</li>
<li>用数组初始化vector对象</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int int_arr[] = &#123;0,1,2,3,4,5&#125;;</span><br><span class="line">vector&lt;int&gt; ivec(begin(int_arr), end(int_arr));</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>多维数组</p>
<ul>
<li>多维数组初始化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[3][4] = &#123;&#123;0,1,2,3&#125;,&#123;4,5,6,7&#125;,&#123;8,9,10,11&#125;&#125;;</span><br><span class="line">int ia[3][4] = &#123;0,1,2,3,4,5,6,7,8,9,10,11&#125;;//按顺序初始化</span><br><span class="line">int ia[3][4] = &#123;&#123;0&#125;,&#123;4&#125;,&#123;8&#125;&#125;;//初始化每行第一个元素</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>范围for处理多维数组</p>
<ul>
<li>除了最内层，其他所有循环控制变量都要用引用类型。因为数组形式的元素会自动转换成指向数组首元素的指针，从而失去了数组大小信息。</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(auto &amp;row : ia)</span><br><span class="line">	for(auto col : row)</span><br><span class="line">		cout &lt;&lt; col &lt;&lt; endl</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>指针和多维数组</p>
</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">using int_array = int[4];</span><br><span class="line">typedef int int_array[4];</span><br><span class="line">for(int_array *p = begin(ia); p != end(ia); ++p)</span><br><span class="line">	for(int *q = begin(*p); q != end(*p); ++q)</span><br><span class="line">		cout &lt;&lt; *q &lt;&lt; &apos; &apos;;</span><br><span class="line">	cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/11/C-Primer学习-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/11/C-Primer学习-1/" itemprop="url">C++ Primer学习笔记：第2章 变量和基本类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-11T13:56:00+08:00">2019-07-11</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>复合类型
<ul>
<li>声明语句=基本数据类型+（类型修饰符）声明符</li>
<li>类型修饰符是声明符的一部分，所以要声明多个指针变量要在每个变量名前面加*符号</li>
</ul>
</li>
<li>关于引用和指针
<ul>
<li>引用必须被初始化，绑定到初始值，之后一直不能改变</li>
<li><strong>引用并非对象</strong>，所以不能定义引用的引用</li>
<li>引用只能绑定在左值上，即可以取地址的值（非字面值或者表达式计算结果）</li>
<li>引用不是对象，没有实际地址，所以不能定义指向引用的指针</li>
<li><a href="https://blog.csdn.net/williamgavin/article/details/78825170" target="_blank" rel="noopener">关于“指针指向紧邻对象所占空间的下一个位置”的理解</a></li>
<li><code>int &amp;*p</code>与<code>int *&amp; p</code>
<ul>
<li>假设p是一个指向int的指针，则指向指针的引用<code>int *&amp;r = p</code>。而<code>int &amp;*p；</code>是不正确的，它创建的是引用的指针。阅读复合类型声明时，要从右到左解读修饰符。</li>
</ul>
</li>
</ul>
</li>
<li>const限定符
<ul>
<li>const对象默认情况下只在文件内有效，多个文件中可以同时定义同名的const变量（一般此时const对象值是常量表达式，编译过程中替换值）</li>
<li>想在文件间共享const对象，必须定义和声明前都加上extern（一般此时const对象值不是常量表达式，可能要运行时才知道其值）</li>
<li>初始化const的引用可以用任意表达式作为初始值，只要改值能转化为引用的类型，比如字面量，非常量对象，甚至是一个一般表达式（const引用可以用任意值初始化是指针类型必须和所指对象类型一致的例外情况之一，另外一种好像是面对对象的多态）</li>
<li>顶层const和底层const
<ul>
<li>顶层const：指针本身是个常量</li>
<li>底层const：指针所指对象是一个常量</li>
<li>对象拷贝，顶层const不受什么影响，底层const需要拷入拷出对象都是底层const或者可以转换（非常量可以转换成常量，反之不行）</li>
</ul>
</li>
<li>一个对象（或表达式）是不是常量表达式是由它的数据类型和初始值共同决定的，比如<code>const int sz = get_size()、int staff = 27</code>都不是常量表达式</li>
<li>constexpr类型
<ul>
<li>将变量声明为constexpr以便由编译器验证变量是否是常量表达式</li>
<li>constexpr函数，是编译时即可计算结果的函数，constexpr函数可以给constexpr变量赋初始值</li>
<li>声明constexpr时用到的类型必须有所限制。这些类型统称为字面值类型（literal type）
<ul>
<li>算数类型、引用、指针是字面值类型。constexpr int a = 0；//算数类型int是字面值类型；</li>
<li>某些类也是字面值类型，这些类叫做字面值常量类假设类Debug是字面值常量类。那么：constexpr Debug debug(args)；//生成一个constexpr对象-debug；</li>
</ul>
</li>
<li>constexpr指针初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象</li>
<li><code>constexpr int *q = nullptr</code>是顶层const，<code>const int *p = nullptr</code>是底层const</li>
</ul>
</li>
</ul>
</li>
<li>类型处理
<ul>
<li>类型别名
<ul>
<li>由两种方法定义类型别名
<ul>
<li><code>typedef double wages;</code></li>
<li><code>using SI = Sales_item;</code></li>
</ul>
</li>
<li>指针，常量和类型别名
<ul>
<li>如果<code>typedef char *pstring;</code>，则<code>const pstring cstr = 0</code>中cstr是指向字符的常量指针，而不是指向常量字符的指针。<code>const char *cstr</code>这种理解是错的，它的基本数据类型是const char，而<code>const pstring cstr = 0</code>中的基本数据类型是const pstring</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>auto说明符
<ul>
<li>
<p>auto说明符声明多个变量时，这些变量的基本数据类型必须相同。如<code>auto i = 0, *p = &amp;i</code>合法，而<code>auto sz = 0, pi = 3.14</code>不合法</p>
</li>
<li>
<p>auto定义的变量<strong>必须有初始值</strong></p>
</li>
<li>
<p>auto不能识别顶层const，能识别底层const，要让auto推断出顶层const，需要在auto前加上const，如<code>const auto f = ci</code></p>
</li>
<li>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto &amp;h = 42;//非常量引用不能绑定字面值</span><br><span class="line">auto &amp;g = ci;//g是整型常量引用，绑定到ci</span><br><span class="line">const auto &amp;j = 42;//可以为常量引用绑定字面值</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留</p>
</li>
<li>
<p><a href="https://segmentfault.com/q/1010000002568358" target="_blank" rel="noopener">如果给初始值绑定一个引用，则此时的常量就不是顶层常量了</a></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">top-level const : const 修饰的是自身。</span><br><span class="line">low-level const : const 修饰的是别人。</span><br><span class="line">            </span><br><span class="line">            POD(Plain Old Data)，类对象都只能是&quot;自身&quot;</span><br><span class="line">            指针可以是自身(指针本身)，可以是别人(指向别人)。</span><br><span class="line">            引用没有自身，只能是别人。(引用是别名)</span><br><span class="line">       </span><br><span class="line">const int ci = 0;</span><br><span class="line">auto &amp;r1 = ci; 发生了什么？</span><br><span class="line">                从 top-level const 降成 low-level const.</span><br><span class="line">                top-level const 的特质(自身无法修改)依然保留。</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>decltype类型指示符</p>
<ul>
<li>decltype处理顶层const和引用的方式与auto有些许不同。</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const int ci = 0, &amp;cj = ci;</span><br><span class="line">decltype(ci) x = 0;//x的类型是const int</span><br><span class="line">decltype(cj) y = x;//y的类型是const int &amp;，绑定到x上</span><br><span class="line">decltype(cj) z;//错误，引用必须初始化</span><br></pre></td></tr></table></figure>
<ul>
<li>引用在decltype中使用时，此时并不是其所指对象的同义词。如<code>decltype(ci)</code>和<code>decltype(cj)</code>代表的类型不同</li>
<li>decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i = 42, *p = &amp;i, &amp;r = i;</span><br><span class="line">decltype(r+0) b; // b是未初始化的int类型</span><br><span class="line">decltype(*p) c; // 错误，c是int&amp;类型，必须初始化</span><br><span class="line">decltype(r) d; // 错误，d是int的引用类型，引用必须初始化</span><br></pre></td></tr></table></figure>
<ul>
<li>decltype与auto的另一个重要区别是，decltype和表达式形式密切相关</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decltype((i)) d;//错误，d是int&amp;类型，必须初始化</span><br><span class="line">decltype(i) e;//正确，e是未初始化的int类型</span><br></pre></td></tr></table></figure>
<ul>
<li><code>decltype((variable))</code>的结果永远是引用，而<code>decltype(variable)</code>的结果只有当variable本身就是引用时才是一个引用。</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/11/python面向对象学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/11/python面向对象学习/" itemprop="url">python学习20190711</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-11T09:56:00+08:00">2019-07-11</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><a href="https://www.cnblogs.com/weihengblog/p/8528967.html" target="_blank" rel="noopener">python抽象类和接口类</a></li>
<li><a href="https://www.cnblogs.com/yutongzhu/p/5615764.html" target="_blank" rel="noopener">python装饰器</a></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myDecorator</span><span class="params">(...)</span>:</span>　　　　<span class="comment">#定义装饰器，可能带参数</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span>    <span class="comment">#装饰器核心，以被装饰的函数对象为参数，返回装饰后的函数对象</span></span><br><span class="line">         <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kvargs)</span>:</span>    <span class="comment">#装饰的过程，参数列表适应不同参数的函数</span></span><br><span class="line">             ...    <span class="comment">#修改函数调用前的行为</span></span><br><span class="line">             func(*args, **kvargs)    <span class="comment">#调用函数</span></span><br><span class="line">             ...    <span class="comment">#修改函数调用后的行为</span></span><br><span class="line">         <span class="keyword">return</span> wrapper</span><br><span class="line">     <span class="keyword">return</span> decorator</span><br><span class="line"> </span><br><span class="line"><span class="meta">@myDecorator(...):　　　　#给函数加上装饰器</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">myFunc</span><span class="params">(...)</span>:</span>　　　　  <span class="comment">#自己定义的功能函数</span></span><br><span class="line">    	...</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><a href="https://blog.csdn.net/orangleliu/article/details/45843813" target="_blank" rel="noopener">装饰器传参数</a></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*- encoding=utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task_logging</span><span class="params">(taskname)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func_wrapper</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">        @wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">return_wrapper</span><span class="params">(*args, **wkargs)</span>:</span></span><br><span class="line">            <span class="comment"># 函数通过装饰起参数给装饰器传送参数</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">'before task'</span>,taskname</span><br><span class="line">            <span class="comment"># 装饰器传变量给函数</span></span><br><span class="line">            taskid = <span class="number">1</span></span><br><span class="line">            summer, funcres = func(taskid, *args, **wkargs)</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'after task'</span>, taskid, summer </span><br><span class="line">            <span class="keyword">return</span> funcres</span><br><span class="line">        <span class="keyword">return</span> return_wrapper</span><br><span class="line">    <span class="keyword">return</span> func_wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@task_logging("test")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testd</span><span class="params">(taskid)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"testd runing"</span>,taskid</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"task summer success eg"</span>, []</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> testd()</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><a href="https://www.cnblogs.com/zhangzhuozheng/p/8053045.html" target="_blank" rel="noopener">*arg和**kwargs的含义</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/09/树状数组/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/09/树状数组/" itemprop="url">树状数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-09T16:18:00+08:00">2019-07-09</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/data-structure/" itemprop="url" rel="index">
                    <span itemprop="name">data structure</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-基本用法"><a class="header-anchor" href="#1-基本用法">¶</a>1. 基本用法</h3>
<ol>
<li>单点修改，区间查询</li>
<li>区间修改，单点查询</li>
<li>区间修改，区间查询</li>
</ol>
<h3 id="2-扩展"><a class="header-anchor" href="#2-扩展">¶</a>2. 扩展</h3>
<ol>
<li>二维树状数组</li>
<li>求逆序对</li>
<li>树形树状数组</li>
<li>求指定长度单调子序列</li>
<li>树状数组求区间最值</li>
</ol>
<h3 id="3-参考"><a class="header-anchor" href="#3-参考">¶</a>3. 参考</h3>
<ol>
<li><a href="https://blog.csdn.net/qq_39553725/article/details/76696168" target="_blank" rel="noopener">https://blog.csdn.net/qq_39553725/article/details/76696168</a></li>
<li><a href="https://blog.csdn.net/u010598215/article/details/48206959" target="_blank" rel="noopener">https://blog.csdn.net/u010598215/article/details/48206959</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">lidanyang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">74</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">40</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/lidanyang" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1261727840@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lidanyang</span>

  

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.0.0</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.0"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
