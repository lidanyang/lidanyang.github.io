<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.0" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="标签">
<meta property="og:url" content="http://yoursite.com/tags/index.html">
<meta property="og:site_name" content="Just a blog">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-05-28T06:22:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="标签">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/tags/">





  <title>Just a blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Just a blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/21/leetcode-刷题日常-135-CandyCopy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/21/leetcode-刷题日常-135-CandyCopy/" itemprop="url">135. Candy</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-21T16:57:00+08:00">2019-06-21</time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-06-25T20:11:22+08:00">2019-06-25</time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>题目描述</h1>
<p><a href="https://leetcode.com/problems/candy/" target="_blank" rel="noopener">135. Candy</a></p>
<p>Difficulty: <strong>Hard</strong></p>
<p>There are <em>N</em> children standing in a line. Each child is assigned a rating value.</p>
<p>You are giving candies to these children subjected to the following requirements:</p>
<ul>
<li>Each child must have at least one candy.</li>
<li>Children with a higher rating get more candies than their neighbors.</li>
</ul>
<p>What is the minimum candies you must give?</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,0,2]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.</span><br><span class="line">             The third child gets 1 candy because it satisfies the above two conditions.</span><br></pre></td></tr></table></figure>
<h1>解法</h1>
<p>  参考leetcode的solution专栏，一共有四个解法。</p>
<h2 id="法一-暴力解法"><a class="header-anchor" href="#法一-暴力解法">¶</a>法一 暴力解法</h2>
<p>  最简单的方法是使用一维数组candy来跟踪给学生的糖果。 首先，我们给每个学生1个糖果。然后，对每个i，如果ratings[i] &gt; ratings[i + 1] &amp;&amp; candies[i] &lt;= candies[i + 1]，则更新candies[i]为candies[i + 1] + 1;如果ratings[i] &gt; ratings[i - 1] &amp;&amp; candies[i] &lt;= candies[i - 1])，则更新candies[i]为candies[i - 1] + 1。用这种方式从左到右遍历调整多次，直到没有发生值的改变，就说明到达目标状态了，可以用一个flag记录值的改变情况。</p>
<p>  最后，我们把candy的所有元素加起来，以获得所需的最少数量的糖果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="keyword">int</span>[] ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] candies = <span class="keyword">new</span> <span class="keyword">int</span>[ratings.length];</span><br><span class="line">        Arrays.fill(candies, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ratings.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != ratings.length - <span class="number">1</span> &amp;&amp; ratings[i] &gt; ratings[i + <span class="number">1</span>] &amp;&amp; candies[i] &lt;= candies[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                    candies[i] = candies[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; ratings[i] &gt; ratings[i - <span class="number">1</span>] &amp;&amp; candies[i] &lt;= candies[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    candies[i] = candies[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> candy : candies) &#123;</span><br><span class="line">            sum += candy;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="法二"><a class="header-anchor" href="#法二">¶</a>法二</h2>
<p>  这是我自己能想到的最好解法，就是从左往右扫描并调整值，再从右往左扫描并调整值，最后取所有相应位置上左右数组的最大值的和。</p>
<ul>
<li>python解法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def candy(self, ratings: List[int]) -&gt; int:</span><br><span class="line">        L = len(ratings)</span><br><span class="line">        minl = [0] * L</span><br><span class="line">        minr = [0] * L        </span><br><span class="line">        sums = 0</span><br><span class="line">        for i in range(1, L):            </span><br><span class="line">            if ratings[i] &gt; ratings[i - 1]:</span><br><span class="line">                minl[i] = minl[i - 1] + 1</span><br><span class="line">        for i in range(L - 2, -1, -1):            </span><br><span class="line">            if ratings[i] &gt; ratings[i + 1]:</span><br><span class="line">                minr[i] = minr[i + 1] + 1</span><br><span class="line">        for k in range(0, L):</span><br><span class="line">            sums += max(minl[k], minr[k]) + 1</span><br><span class="line">        return sums</span><br></pre></td></tr></table></figure>
<ul>
<li>java解法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="keyword">int</span>[] ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] left2right = <span class="keyword">new</span> <span class="keyword">int</span>[ratings.length];</span><br><span class="line">        <span class="keyword">int</span>[] right2left = <span class="keyword">new</span> <span class="keyword">int</span>[ratings.length];</span><br><span class="line">        Arrays.fill(left2right, <span class="number">1</span>);</span><br><span class="line">        Arrays.fill(right2left, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ratings.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                left2right[i] = left2right[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = ratings.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                right2left[i] = right2left[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ratings.length; i++) &#123;</span><br><span class="line">            sum += Math.max(left2right[i], right2left[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="法三"><a class="header-anchor" href="#法三">¶</a>法三</h2>
<p>  法三在法二的基础上进行修改，从用两个数组变成只用一个数组。从左往右时，如果ratings[i] &gt; ratings[i - 1]， 更新candies[i] 为 candies[i - 1] + 1，此时candies[i]满足左边的大小关系；从右往左时，如果ratings[i] &gt; ratings[i + 1])，更新candies[i] 为 Math.max(candies[i], candies[i + 1] + 1)，使得candies[i]同时满足右边的大小关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="keyword">int</span>[] ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] candies = <span class="keyword">new</span> <span class="keyword">int</span>[ratings.length];</span><br><span class="line">        Arrays.fill(candies, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ratings.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                candies[i] = candies[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = candies[ratings.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = ratings.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                candies[i] = Math.max(candies[i], candies[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sum += candies[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="法四"><a class="header-anchor" href="#法四">¶</a>法四</h2>
<p>  这个解法是将ratings的递增递减对应candies上下坡记录每个上坡(1,2,3,…)，下坡(…3,2,1)的宽度然后比较大小决定山顶是属于上坡还是下坡(如1,2,3,4,5,3,2,1中5要属于更长的上坡才能满足同时比它旁边的3和4都大)，而山脚为了保证最少糖果取1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int count(int n) &#123;</span><br><span class="line">        <span class="keyword">return</span> (n * (n + <span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    public int candy(int[] ratings) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ratings.length;</span><br><span class="line">        &#125;</span><br><span class="line">        int candies = <span class="number">0</span>;</span><br><span class="line">        <span class="comment"># 该轮上坡高度</span></span><br><span class="line">        int up = <span class="number">0</span>;</span><br><span class="line">        <span class="comment"># 该轮下坡高度</span></span><br><span class="line">        int down = <span class="number">0</span>;</span><br><span class="line">        <span class="comment"># 上一次循环的斜率</span></span><br><span class="line">        int old_slope = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt; ratings.length; i++) &#123;</span><br><span class="line">            int new_slope = (ratings[i] &gt; ratings[i - 1]) ? 1 : (ratings[i] &lt; ratings[i - 1] ? -1 : 0);</span><br><span class="line">            <span class="comment"># 前后相等也看做山脚</span></span><br><span class="line">            <span class="comment"># 如果上一次是上升，下一次是相等则此时是山脚；如果上一次是下降，下一次是上升或者相等，则此时是山脚。</span></span><br><span class="line">            <span class="keyword">if</span> ((old_slope &gt; <span class="number">0</span> &amp;&amp; new_slope == <span class="number">0</span>) || (old_slope &lt; <span class="number">0</span> &amp;&amp; new_slope &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">                candies += count(up) + count(down) + Math.max(up, down);</span><br><span class="line">                up = <span class="number">0</span>;</span><br><span class="line">                down = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (new_slope &gt; <span class="number">0</span>)</span><br><span class="line">                up++;</span><br><span class="line">            <span class="keyword">if</span> (new_slope &lt; <span class="number">0</span>)</span><br><span class="line">                down++;</span><br><span class="line">            <span class="keyword">if</span> (new_slope == <span class="number">0</span>)</span><br><span class="line">                candies++;</span><br><span class="line">			<span class="comment"># 到这里candies算的是i之前的所有candy的总和，但是不包括山脚i</span></span><br><span class="line">            old_slope = new_slope;</span><br><span class="line">        &#125;</span><br><span class="line">        candies += count(up) + count(down) + Math.max(up, down) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> candies;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/21/leetcode-刷题日常-133-Clone-Graph/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/21/leetcode-刷题日常-133-Clone-Graph/" itemprop="url">133. Clone Graph</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-21T15:08:00+08:00">2019-06-21</time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-06-25T20:11:29+08:00">2019-06-25</time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>题目描述</h1>
<p><a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="noopener">133. Clone Graph</a></p>
<p>Difficulty: <strong>Medium</strong></p>
<p>Given a reference of a node in a  undirected graph, return a (clone) of the graph. Each node in the graph contains a val (<code>int</code>) and a list (<code>List[Node]</code>) of its neighbors.</p>
<p><strong>Example:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2019/02/19/113_sample.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&#123;&quot;$id&quot;:&quot;1&quot;,&quot;neighbors&quot;:[&#123;&quot;$id&quot;:&quot;2&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;1&quot;&#125;,&#123;&quot;$id&quot;:&quot;3&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&#123;&quot;$id&quot;:&quot;4&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;3&quot;&#125;,&#123;&quot;$ref&quot;:&quot;1&quot;&#125;],&quot;val&quot;:4&#125;],&quot;val&quot;:3&#125;],&quot;val&quot;:2&#125;,&#123;&quot;$ref&quot;:&quot;4&quot;&#125;],&quot;val&quot;:1&#125;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Node 1&apos;s value is 1, and it has two neighbors: Node 2 and 4.</span><br><span class="line">Node 2&apos;s value is 2, and it has two neighbors: Node 1 and 3.</span><br><span class="line">Node 3&apos;s value is 3, and it has two neighbors: Node 2 and 4.</span><br><span class="line">Node 4&apos;s value is 4, and it has two neighbors: Node 1 and 3.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li>The number of nodes will be between 1 and 100.</li>
<li>The undirected graph is a , which means no repeated edges and no self-loops in the graph.</li>
<li>Since the graph is undirected, if node <em>p</em> has node <em>q</em> as neighbor, then node <em>q</em> must have node <em>p</em> as neighbor too.</li>
<li>You must return the <strong>copy of the given node</strong> as a reference to the cloned graph.</li>
</ol>
<h1>解法</h1>
<h2 id="法一："><a class="header-anchor" href="#法一：">¶</a>法一：</h2>
<p>DFS深度优先遍历，DFS返回新节点，DFS的过程中用dic记录新旧节点的对应关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line"># Definition for a Node.</span><br><span class="line">class Node:</span><br><span class="line">    def __init__(self, val, neighbors):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.neighbors = neighbors</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from collections import defaultdict</span><br><span class="line">class Solution:</span><br><span class="line">    def cloneGraph(self, node: &apos;Node&apos;) -&gt; &apos;Node&apos;:    </span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        nodelist = []</span><br><span class="line">        def DFS(N):</span><br><span class="line">            if N == None:</span><br><span class="line">                return None</span><br><span class="line">            if N in dic:</span><br><span class="line">                return dic[N]</span><br><span class="line">            new = Node(N.val, [])</span><br><span class="line">            dic[N] = new</span><br><span class="line">            for n in N.neighbors:</span><br><span class="line">                new.neighbors.append(DFS(n))</span><br><span class="line">            return new</span><br><span class="line">        return DFS(node)</span><br></pre></td></tr></table></figure>
<h2 id="法二："><a class="header-anchor" href="#法二：">¶</a>法二：</h2>
<p>BFS遍历，dic存放新旧节点的对应关系，每次节点入队之前都要克隆还没克隆过的节点，dic也可以当作节点访问标记数组使用，节点克隆过就代表节点访问过。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cloneGraph</span><span class="params">(self, node: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span>    </span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        q = deque([node])</span><br><span class="line">        dic[node] = Node(node.val, [])</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            n = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> neighbor <span class="keyword">in</span> n.neighbors:</span><br><span class="line">                <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                    q.append(neighbor)</span><br><span class="line">                    dic[neighbor] = Node(neighbor.val, [])</span><br><span class="line">                dic[n].neighbors.append(dic[neighbor])</span><br><span class="line">        <span class="keyword">return</span> dic[node]</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/21/leetcode-刷题日常-132-Palindrome-Partitioning-II/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/21/leetcode-刷题日常-132-Palindrome-Partitioning-II/" itemprop="url">132. Palindrome Partitioning II</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-21T12:17:00+08:00">2019-06-21</time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-06-25T20:11:38+08:00">2019-06-25</time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>题目描述</h1>
<p><a href="https://leetcode.com/problems/palindrome-partitioning-ii/" target="_blank" rel="noopener">132. Palindrome Partitioning II</a></p>
<p>Difficulty: <strong>Hard</strong></p>
<p>Given a string <em>s</em>, partition <em>s</em> such that every substring of the partition is a palindrome.</p>
<p>Return the minimum cuts needed for a palindrome partitioning of <em>s</em>.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;aab&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The palindrome partitioning [&quot;aa&quot;,&quot;b&quot;] could be produced using 1 cut.</span><br></pre></td></tr></table></figure>
<h1>解法</h1>
<p>  此题涉及动态规划。</p>
<h2 id="法一-我自己的解法-效率较低"><a class="header-anchor" href="#法一-我自己的解法-效率较低">¶</a>法一（我自己的解法，效率较低）</h2>
<p>  dp[i] = 0 if s[:i+1][::-1] == s[:i+1] else $\min_{ 0 &lt; j &lt;= i\ and\ s[j:i+1][::-1] == s[j:i+1]}{dp[j - 1] + 1}$</p>
<p>  注：j是使j+1到i之间的字符串为回文串的下标位置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 900ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCut</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span>] * len(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[:i+<span class="number">1</span>] == s[:i+<span class="number">1</span>][::<span class="number">-1</span>]:</span><br><span class="line">                dp[i] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            dp[i] = len(s)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[j:i+<span class="number">1</span>][::<span class="number">-1</span>] == s[j:i+<span class="number">1</span>]:</span><br><span class="line">                    dp[i] = min(dp[i], dp[j - <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[len(s) - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>  这种思路还有一种更漂亮简洁的写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minCut</span><span class="params">(self, s)</span>:</span></span><br><span class="line">    cut = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">-1</span>,len(s))]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(s)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i,len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i:j] == s[j:i:<span class="number">-1</span>]:</span><br><span class="line">                cut[j+<span class="number">1</span>] = min(cut[j+<span class="number">1</span>],cut[i]+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> cut[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h1>法二</h1>
<p>  此解的几个关键点在于：</p>
<ul>
<li>i的遍历方向为从右到左，j的遍历方向为从左到右;</li>
<li>dp_cut数组代表的是切成几个回文串，而不是切几刀，所以最后返回结果之前要减1;</li>
<li>该解法的动态规划递推式是:<br>
$$dp_{i&lt;=j}[i][j] == 1\ if\ s[i] == s[j]\ and\ (i &lt;= j - 1\ or\ dp[i+1][j-1] == 1)\ else\ 0$$<br>
$$dp_cut[i] = \min_{i&lt;=j&lt;len(s)\ and\ dp[i][j] == 1 }{dp_cut[j+1]+1}$$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 400ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCut</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        L = len(s)</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(L)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(L)]</span><br><span class="line">        dp_cut = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(L + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(L - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>): <span class="comment"># i要反着遍历</span></span><br><span class="line">            dp_cut[i] = L</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, L):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j] <span class="keyword">and</span> (i &gt;= j - <span class="number">1</span> <span class="keyword">or</span> dp[i+<span class="number">1</span>][j<span class="number">-1</span>] == <span class="number">1</span>):</span><br><span class="line">                    dp[i][j] = <span class="number">1</span></span><br><span class="line">                    dp_cut[i] = min(dp_cut[i], dp_cut[j+<span class="number">1</span>]+<span class="number">1</span>)                    </span><br><span class="line">        <span class="keyword">return</span> dp_cut[<span class="number">0</span>] - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>  <strong>特例优化</strong>:</p>
<p>  因为动态规划方法在最少需要切一刀或者整个字符串是回文字符串的情况下效率很低,所以需要在开头就这些情况直接判断并返回，这样可以省去大量时间。同理，法一也可以通过在开头加上特判来加速。代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 88ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCut</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> s == s[::<span class="number">-1</span>]: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        L = len(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, L):</span><br><span class="line">            <span class="keyword">if</span> s[:i] == s[:i][::<span class="number">-1</span>] <span class="keyword">and</span> s[i:] == s[i:][::<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(L)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(L)]</span><br><span class="line">        dp_cut = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(L + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(L - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>): <span class="comment"># i要反着遍历</span></span><br><span class="line">            dp_cut[i] = L</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, L):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j] <span class="keyword">and</span> (i &gt;= j - <span class="number">1</span> <span class="keyword">or</span> dp[i+<span class="number">1</span>][j<span class="number">-1</span>] == <span class="number">1</span>):</span><br><span class="line">                    dp[i][j] = <span class="number">1</span></span><br><span class="line">                    dp_cut[i] = min(dp_cut[i], dp_cut[j+<span class="number">1</span>]+<span class="number">1</span>)                    </span><br><span class="line">        <span class="keyword">return</span> dp_cut[<span class="number">0</span>] - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="法三"><a class="header-anchor" href="#法三">¶</a>法三</h2>
<p>  这个解法是我看到的最优解，这种解法即使不用特例优化，也能达到200ms的运行时间，是其他解法都不能做到的。这种解法<strong>只比较回文串两端的s[i]和s[j]，而其他解法每一对s[i]和s[j]都要比较一次</strong>，因此要快很多。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 28ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCut</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># acceleration</span></span><br><span class="line">        <span class="keyword">if</span> s == s[::<span class="number">-1</span>]: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[:i] == s[:i][::<span class="number">-1</span>] <span class="keyword">and</span> s[i:] == s[i:][::<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="comment"># algorithm</span></span><br><span class="line">        cut = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">-1</span>,len(s))]  <span class="comment"># cut numbers in worst case (no palindrome)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            r1, r2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="comment"># use i as origin, and gradually enlarge radius if a palindrome exists</span></span><br><span class="line">            <span class="comment"># odd palindrome</span></span><br><span class="line">            <span class="keyword">while</span> i-r1 &gt;= <span class="number">0</span> <span class="keyword">and</span> i+r1 &lt; len(s) <span class="keyword">and</span> s[i-r1] == s[i+r1]:     </span><br><span class="line">                cut[i+r1+<span class="number">1</span>] = min(cut[i+r1+<span class="number">1</span>], cut[i-r1]+<span class="number">1</span>)</span><br><span class="line">                r1 += <span class="number">1</span></span><br><span class="line">            <span class="comment"># even palindrome</span></span><br><span class="line">            <span class="keyword">while</span> i-r2 &gt;= <span class="number">0</span> <span class="keyword">and</span> i+r2+<span class="number">1</span> &lt; len(s) <span class="keyword">and</span> s[i-r2] == s[i+r2+<span class="number">1</span>]:</span><br><span class="line">                cut[i+r2+<span class="number">2</span>] = min(cut[i+r2+<span class="number">2</span>], cut[i-r2]+<span class="number">1</span>)</span><br><span class="line">                r2 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cut[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h1>总结</h1>
<p>  其实单单针对这道题，针对官网给出的这些测试用例而言最大的优化在于判断特殊情况，加特判和没加特判的时间差很大，其次才是法四的优化。法一、法二和法三的中心思想都是一样的（如果用cut[i]记录s[0:i]所需最少刀数，则假如一个回文字符串是s[i:j]），那么cut[j]一定不大于cut[i + 1] + 1，只不过他们判断回文串的方式不同。法四不仅没有漏掉任何一个回文串而且空间复杂度比其他方法都低，实在是巧妙！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/20/leetcode-刷题日常-137-Single-Number-II/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/20/leetcode-刷题日常-137-Single-Number-II/" itemprop="url">137. Single Number II</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-20T22:58:00+08:00">2019-06-20</time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-06-25T20:11:45+08:00">2019-06-25</time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>题目描述</h1>
<p><a href="https://leetcode.com/problems/single-number-ii/" target="_blank" rel="noopener">137. Single Number II</a></p>
<p>Difficulty: <strong>Medium</strong></p>
<p>Given a <strong>non-empty</strong> array of integers, every element appears <em>three</em> times except for one, which appears exactly once. Find that single one.</p>
<p><strong>Note:</strong></p>
<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,3,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0,1,0,1,99]</span><br><span class="line">Output: 99</span><br></pre></td></tr></table></figure>
<h1>分析</h1>
<p>  这道题让我眼前一亮，是之前没遇到过的位操作。中心思想就是统计每一位上1出现的次数，出现次数余3为1的那些位组成的数即恰好只出现一次的数。</p>
<ul>
<li>法一</li>
</ul>
<p>  one,two,three分别用来记录每一位上出现1的次数是几次，one，two，three三个整数的同一位上只允许有一个有1，因为要么出现1次，要么2次，要么3次，结果返回one；</p>
<ul>
<li>法二</li>
</ul>
<p>  用ab两个整数表示00,01,10三个状态，根据1的出现与否转换ab的值，转化顺序00-&gt;01-&gt;10-&gt;00，结果返回b。</p>
<h1>解法</h1>
<p>Language: <strong>Python3</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # 解法一</span><br><span class="line">    def singleNumber1(self, nums: List[int]) -&gt; int:</span><br><span class="line">        one, two, three = 0, 0, 0</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            two |= one &amp; nums[i]</span><br><span class="line">            one ^= nums[i]</span><br><span class="line">            three = one &amp; two</span><br><span class="line">            one &amp;= ~three</span><br><span class="line">            two &amp;= ~three</span><br><span class="line">        return one</span><br><span class="line">    # 解法二</span><br><span class="line">    def singleNumber2(self, nums: List[int]) -&gt; int:</span><br><span class="line">        res = 0</span><br><span class="line">        for i in range(32):</span><br><span class="line">            count = 0</span><br><span class="line">            for n in nums:</span><br><span class="line">                count += (n &gt;&gt; i) &amp; 1</span><br><span class="line">            res |= ((count % 3) &lt;&lt; i)</span><br><span class="line">        return res - 2**32 if res &gt;= 2**31 else res</span><br><span class="line">    # 解法三</span><br><span class="line">    def singleNumber3(self, nums: List[int]) -&gt; int:</span><br><span class="line">        return (3 * sum(set(nums)) - sum(nums))//2</span><br><span class="line">    # 解法四</span><br><span class="line">    def singleNumber(self, nums: List[int]) -&gt; int:</span><br><span class="line">        a, b =0, 0</span><br><span class="line">        for n in nums:</span><br><span class="line">            b = (b ^ n) &amp; ~a</span><br><span class="line">            a = (a ^ n) &amp; ~b</span><br><span class="line">        return b</span><br></pre></td></tr></table></figure>
<h1>扩展</h1>
<h2 id="扩展一："><a class="header-anchor" href="#扩展一：">¶</a>扩展一：</h2>
<p>  给定一个包含n个整数的数组，除了一个数出现二次外所有的整数均出现三次，找出这个只出现二次的整数。ones记录1出现一次的数，twos记录1出现2次的数，容易知道twos记录的即是最终结果。</p>
<h2 id="扩展二："><a class="header-anchor" href="#扩展二：">¶</a>扩展二：</h2>
<p>  给定一个包含n个整数的数组，有一个整数x出现b次，一个整数y出现c次，其他所有的数均出现a次，其中b和c均不是a的倍数，找出x和y。使用二进制模拟a进制，累计二进制位1出现的次数，当次数达到a时，对其清零，这样可以得到b mod a次x，c mod a次y的累加。遍历剩余结果（用ones、twos、fours…变量表示）中每一位二进制位1出现的次数，如果次数为b mod a 或者 c mod a，可以说明x和y的当前二进制位不同（一个为0，另一个为1），据此二进制位将原数组分成两组，一组该二进制位为1，另一组该二进制位为0。这样问题变成“除了一个整数出现a1次（a1 = b 或 a1 = c）外所有的整数均出现a次”，使用和上面相同的方式计算就可以得到最终结果，假设模拟a进制计算过程中使用的变量为ones、twos、fours…那么最终结果可以用ones | twos | fours …表示。</p>
<h1>参考</h1>
<p><a href="https://www.cnblogs.com/grandyang/p/4263927.html" target="_blank" rel="noopener">https://www.cnblogs.com/grandyang/p/4263927.html</a><br>
<a href="https://www.cnblogs.com/daijinqiao/p/3352893.html" target="_blank" rel="noopener">https://www.cnblogs.com/daijinqiao/p/3352893.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/20/leetcode-刷题日常-134-Gas-Station/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/20/leetcode-刷题日常-134-Gas-Station/" itemprop="url">134. Gas Station</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-20T22:05:00+08:00">2019-06-20</time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-06-25T20:12:06+08:00">2019-06-25</time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>题目描述</h1>
<p><a href="https://leetcode.com/problems/gas-station/" target="_blank" rel="noopener">134. Gas Station</a></p>
<p>Difficulty: <strong>Medium</strong></p>
<p>There are <em>N</em> gas stations along a circular route, where the amount of gas at station <em>i</em> is <code>gas[i]</code>.</p>
<p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from station <em>i</em> to its next station (<em>i</em>+1). You begin the journey with an empty tank at one of the gas stations.</p>
<p>Return the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return -1.</p>
<p><strong>Note:</strong></p>
<ul>
<li>If there exists a solution, it is guaranteed to be unique.</li>
<li>Both input arrays are non-empty and have the same length.</li>
<li>Each element in the input arrays is a non-negative integer.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">gas  = [1,2,3,4,5]</span><br><span class="line">cost = [3,4,5,1,2]</span><br><span class="line"></span><br><span class="line">Output: 3</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4</span><br><span class="line">Travel to station 4\. Your tank = 4 - 1 + 5 = 8</span><br><span class="line">Travel to station 0\. Your tank = 8 - 2 + 1 = 7</span><br><span class="line">Travel to station 1\. Your tank = 7 - 3 + 2 = 6</span><br><span class="line">Travel to station 2\. Your tank = 6 - 4 + 3 = 5</span><br><span class="line">Travel to station 3\. The cost is 5\. Your gas is just enough to travel back to station 3.</span><br><span class="line">Therefore, return 3 as the starting index.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">gas  = [2,3,4]</span><br><span class="line">cost = [3,4,3]</span><br><span class="line"></span><br><span class="line">Output: -1</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">You can&apos;t start at station 0 or 1, as there is not enough gas to travel to the next station.</span><br><span class="line">Let&apos;s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4</span><br><span class="line">Travel to station 0\. Your tank = 4 - 3 + 2 = 3</span><br><span class="line">Travel to station 1\. Your tank = 3 - 3 + 3 = 3</span><br><span class="line">You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.</span><br><span class="line">Therefore, you can&apos;t travel around the circuit once no matter where you start.</span><br></pre></td></tr></table></figure>
<h1>分析</h1>
<p>  <strong>该题隐藏着一个可以证明的结论，即只要所有gas[i]-cos[i]的和大于0，那么就一定存在一个起点可以绕一圈。</strong></p>
<h4 id="解法一"><a class="header-anchor" href="#解法一">¶</a>解法一</h4>
<p>  从左往右扫描，将值加到sum，如果和小于0，那么就从小于0的那一点的下一个点开始重置sum为0继续加和，并更新起点start，直到遍历完整个数组。遍历数组的同时可以求所有gas-cost的和total，并根据total是否小于0来决定是返回start还是-1。（注意从上一个起点到上一个使sum小于0的那个点之间的所有点都不能作起点，所以要更新起点）</p>
<h4 id="解法二"><a class="header-anchor" href="#解法二">¶</a>解法二</h4>
<p>  从右往左扫描并累加和（累加和的意义是从当前点到最后一个点的剩油量），记录剩油量最大的那个点的下标为start。遍历数组的同时可以求所有gas-cost的和total，并根据total是否小于0来决定是返回start还是-1。</p>
<h1>代码</h1>
<p>Language: <strong>Python3</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line"># 解法一</span><br><span class="line">     def canCompleteCircuit1(self, gas: List[int], cost: List[int]) -&gt; int:</span><br><span class="line">         sums = 0</span><br><span class="line">         total = 0</span><br><span class="line">         start = 0</span><br><span class="line">         for i in range(len(gas)):</span><br><span class="line">             sums += gas[i] - cost[i]</span><br><span class="line">             total += gas[i] - cost[i]</span><br><span class="line">             if sums &lt; 0:</span><br><span class="line">                 sums = 0</span><br><span class="line">                 start = i + 1</span><br><span class="line">            </span><br><span class="line">         return start if total &gt;= 0 else -1</span><br><span class="line"></span><br><span class="line"># 解法二</span><br><span class="line">    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -&gt; int:</span><br><span class="line">        mx = -1</span><br><span class="line">        total = 0</span><br><span class="line">        start = 0</span><br><span class="line">        for i in range(len(gas) - 1, -1, -1):</span><br><span class="line">            total += gas[i] - cost[i]</span><br><span class="line">            if total &gt; mx:</span><br><span class="line">                mx = total</span><br><span class="line">                start = i</span><br><span class="line">            </span><br><span class="line">        return start if total &gt;= 0 else -1</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/20/C语言运算符/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/20/C语言运算符/" itemprop="url">C语言运算符</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-20T13:35:00+08:00">2019-06-20</time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-11-03T00:11:20+08:00">2019-11-03</time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>优先级表格</h1>
<table border="1" cellspacing="0" cellpadding="0" width="612" style="color:rgb(0,0,0);font-family:Arial;font-size:14px;line-height:26px;text-align:left;"><tbody><tr><td>
<p align="center">
<strong>优先级</strong></p>
</td>
<td>
<p align="center">
<strong>运算符</strong></p>
</td>
<td>
<p align="center">
<strong>名称或含义</strong></p>
</td>
<td>
<p align="center">
<strong>使用形式</strong></p>
</td>
<td>
<p align="center">
<strong>结合方向</strong></p>
</td>
<td>
<p align="center">
<strong>说明</strong></p>
</td>
</tr><tr><td rowspan="4">
<p align="center">
<strong>1</strong></p>
</td>
<td>
<p align="center">
<strong><span style="color:#0000FF;">[]</span></strong></p>
</td>
<td>
<p>
数组下标</p>
</td>
<td>
<p>
数组名[常量表达式]</p>
</td>
<td rowspan="4">
<p align="center">
左到右</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">()</span></strong></p>
</td>
<td>
<p>
圆括号</p>
</td>
<td>
<p>
(表达式）/函数名(形参表)</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">.</span></strong></p>
</td>
<td>
<p>
成员选择（对象）</p>
</td>
<td>
<p>
对象.成员名</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">-&gt;</span></strong></p>
</td>
<td>
<p>
成员选择（指针）</p>
</td>
<td>
<p>
对象指针-&gt;成员名</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td width="612" colspan="6">
<p>
 </p>
</td>
</tr><tr><td rowspan="9">
<p align="center">
<strong>2</strong></p>
</td>
<td>
<p align="center">
<strong><span style="color:#0000FF;">-</span></strong></p>
</td>
<td>
<p>
负号运算符</p>
</td>
<td>
<p>
-表达式</p>
</td>
<td rowspan="9">
<p align="center">
<strong><span style="color:#FF0000;">右到左</span></strong></p>
</td>
<td rowspan="7">
<p align="center">
单目运算符</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">~</span></strong></p>
</td>
<td>
<p>
按位取反运算符</p>
</td>
<td>
<p>
~表达式</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">++</span></strong></p>
</td>
<td>
<p>
自增运算符</p>
</td>
<td>
<p>
++变量名/变量名++</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">--</span></strong></p>
</td>
<td>
<p>
自减运算符</p>
</td>
<td>
<p>
--变量名/变量名--</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">*</span></strong></p>
</td>
<td>
<p>
取值运算符</p>
</td>
<td>
<p>
*指针变量</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">&amp;</span></strong></p>
</td>
<td>
<p>
取地址运算符</p>
</td>
<td>
<p>
&amp;变量名</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">!</span></strong></p>
</td>
<td>
<p>
逻辑非运算符</p>
</td>
<td>
<p>
!表达式</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">(</span><span style="color:#0000FF;">类型</span><span style="color:#0000FF;">)</span></strong></p>
</td>
<td>
<p>
强制类型转换</p>
</td>
<td>
<p>
(数据类型)表达式</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">sizeof</span></strong></p>
</td>
<td>
<p>
长度运算符</p>
</td>
<td>
<p>
sizeof(表达式)</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td width="612" colspan="6">
<p>
 </p>
</td>
</tr><tr><td rowspan="3">
<p align="center">
<strong>3</strong></p>
</td>
<td>
<p align="center">
<strong><span style="color:#0000FF;">/</span></strong></p>
</td>
<td>
<p>
除</p>
</td>
<td>
<p>
表达式/表达式</p>
</td>
<td rowspan="3">
<p align="center">
左到右</p>
</td>
<td rowspan="3">
<p align="center">
双目运算符</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">*</span></strong></p>
</td>
<td>
<p>
乘</p>
</td>
<td>
<p>
表达式*表达式</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">%</span></strong></p>
</td>
<td>
<p>
余数（取模）</p>
</td>
<td>
<p>
整型表达式%整型表达式</p>
</td>
</tr><tr><td rowspan="2">
<p align="center">
<strong>4</strong></p>
</td>
<td>
<p align="center">
<strong><span style="color:#0000FF;">+</span></strong></p>
</td>
<td>
<p>
加</p>
</td>
<td>
<p>
表达式+表达式</p>
</td>
<td rowspan="2">
<p align="center">
左到右</p>
</td>
<td rowspan="2">
<p align="center">
双目运算符</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">-</span></strong></p>
</td>
<td>
<p>
减</p>
</td>
<td>
<p>
表达式-表达式</p>
</td>
</tr><tr><td rowspan="2">
<p align="center">
<strong>5</strong></p>
</td>
<td>
<p align="center">
<strong><span style="color:#0000FF;">&lt;&lt; </span></strong></p>
</td>
<td>
<p>
左移</p>
</td>
<td>
<p>
变量&lt;&lt;表达式</p>
</td>
<td rowspan="2">
<p align="center">
左到右</p>
</td>
<td rowspan="2">
<p align="center">
双目运算符</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">&gt;&gt; </span></strong></p>
</td>
<td>
<p>
右移</p>
</td>
<td>
<p>
变量&gt;&gt;表达式</p>
</td>
</tr><tr><td width="612" colspan="6">
<p>
 </p>
</td>
</tr><tr><td rowspan="4">
<p align="center">
<strong>6</strong></p>
</td>
<td>
<p align="center">
<strong><span style="color:#0000FF;">&gt; </span></strong></p>
</td>
<td>
<p>
大于</p>
</td>
<td>
<p>
表达式&gt;表达式</p>
</td>
<td rowspan="4">
<p align="center">
左到右</p>
</td>
<td rowspan="4">
<p align="center">
双目运算符</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">&gt;=</span></strong></p>
</td>
<td>
<p>
大于等于</p>
</td>
<td>
<p>
表达式&gt;=表达式</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">&lt; </span></strong></p>
</td>
<td>
<p>
小于</p>
</td>
<td>
<p>
表达式&lt;表达式</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">&lt;=</span></strong></p>
</td>
<td>
<p>
小于等于</p>
</td>
<td>
<p>
表达式&lt;=表达式</p>
</td>
</tr><tr><td rowspan="2">
<p align="center">
<strong>7</strong></p>
</td>
<td>
<p align="center">
<strong><span style="color:#0000FF;">==</span></strong></p>
</td>
<td>
<p>
等于</p>
</td>
<td>
<p>
表达式==表达式</p>
</td>
<td rowspan="2">
<p align="center">
左到右</p>
</td>
<td rowspan="2">
<p align="center">
双目运算符</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">！</span><span style="color:#0000FF;">=</span></strong></p>
</td>
<td>
<p>
不等于</p>
</td>
<td>
<p>
表达式!= 表达式</p>
</td>
</tr><tr><td width="612" colspan="6">
<p>
 </p>
</td>
</tr><tr><td>
<p align="center">
<strong>8</strong></p>
</td>
<td>
<p align="center">
<strong><span style="color:#0000FF;">&amp;</span></strong></p>
</td>
<td>
<p>
按位与</p>
</td>
<td>
<p>
表达式&amp;表达式</p>
</td>
<td>
<p align="center">
左到右</p>
</td>
<td>
<p align="center">
双目运算符</p>
</td>
</tr><tr><td>
<p align="center">
<strong>9</strong></p>
</td>
<td>
<p align="center">
<strong><span style="color:#0000FF;">^</span></strong></p>
</td>
<td>
<p>
按位异或</p>
</td>
<td>
<p>
表达式^表达式</p>
</td>
<td>
<p align="center">
左到右</p>
</td>
<td>
<p align="center">
双目运算符</p>
</td>
</tr><tr><td>
<p align="center">
<strong>10</strong></p>
</td>
<td>
<p align="center">
<strong><span style="color:#0000FF;">|</span></strong></p>
</td>
<td>
<p>
按位或</p>
</td>
<td>
<p>
表达式|表达式</p>
</td>
<td>
<p align="center">
左到右</p>
</td>
<td>
<p align="center">
双目运算符</p>
</td>
</tr><tr><td>
<p align="center">
<strong>11</strong></p>
</td>
<td>
<p align="center">
<strong><span style="color:#0000FF;">&amp;&amp;</span></strong></p>
</td>
<td>
<p>
逻辑与</p>
</td>
<td>
<p>
表达式&amp;&amp;表达式</p>
</td>
<td>
<p align="center">
左到右</p>
</td>
<td>
<p align="center">
双目运算符</p>
</td>
</tr><tr><td>
<p align="center">
<strong>12</strong></p>
</td>
<td>
<p align="center">
<strong><span style="color:#0000FF;">||</span></strong></p>
</td>
<td>
<p>
逻辑或</p>
</td>
<td>
<p>
表达式||表达式</p>
</td>
<td>
<p align="center">
左到右</p>
</td>
<td>
<p align="center">
双目运算符</p>
</td>
</tr><tr><td width="612" colspan="6">
<p>
 </p>
</td>
</tr><tr><td>
<p align="center">
<strong>13</strong></p>
</td>
<td>
<p align="center">
<strong><span style="color:#0000FF;">?:</span></strong></p>
</td>
<td>
<p>
条件运算符</p>
</td>
<td>
<p>
表达式1?</p>
<p>
表达式2: 表达式3</p>
</td>
<td>
<p align="center">
<strong><span style="color:#FF0000;">右到左</span></strong></p>
</td>
<td>
<p align="center">
<span style="color:#FF0000;">三目运算符</span></p>
</td>
</tr><tr><td width="612" colspan="6">
<p>
<span style="color:#FF0000;"> </span></p>
</td>
</tr><tr><td rowspan="11">
<p align="center">
<strong>14</strong></p>
</td>
<td>
<p align="center">
<strong><span style="color:#0000FF;">=</span></strong></p>
</td>
<td>
<p>
赋值运算符</p>
</td>
<td>
<p>
变量=表达式</p>
</td>
<td rowspan="11">
<p align="center">
<strong><span style="color:#FF0000;">右到左</span></strong></p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">/=</span></strong></p>
</td>
<td>
<p>
除后赋值</p>
</td>
<td>
<p>
变量/=表达式</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">*=</span></strong></p>
</td>
<td>
<p>
乘后赋值</p>
</td>
<td>
<p>
变量*=表达式</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">%=</span></strong></p>
</td>
<td>
<p>
取模后赋值</p>
</td>
<td>
<p>
变量%=表达式</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">+=</span></strong></p>
</td>
<td>
<p>
加后赋值</p>
</td>
<td>
<p>
变量+=表达式</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">-=</span></strong></p>
</td>
<td>
<p>
减后赋值</p>
</td>
<td>
<p>
变量-=表达式</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">&lt;&lt;=</span></strong></p>
</td>
<td>
<p>
左移后赋值</p>
</td>
<td>
<p>
变量&lt;&lt;=表达式</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">&gt;&gt;=</span></strong></p>
</td>
<td>
<p>
右移后赋值</p>
</td>
<td>
<p>
变量&gt;&gt;=表达式</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">&amp;=</span></strong></p>
</td>
<td>
<p>
按位与后赋值</p>
</td>
<td>
<p>
变量&amp;=表达式</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">^=</span></strong></p>
</td>
<td>
<p>
按位异或后赋值</p>
</td>
<td>
<p>
变量^=表达式</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">|=</span></strong></p>
</td>
<td>
<p>
按位或后赋值</p>
</td>
<td>
<p>
变量|=表达式</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td width="612" colspan="6">
<p>
 </p>
</td>
</tr><tr><td>
<p align="center">
<strong>15</strong></p>
</td>
<td>
<p align="center">
<strong><span style="color:#0000FF;">，</span></strong></p>
</td>
<td>
<p>
逗号运算符</p>
</td>
<td>
<p>
表达式,表达式,…</p>
</td>
<td>
<p align="center">
左到右</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr></tbody></table>
<h1>说明</h1>
<p>  运算符共分为15级，1级优先级最高，15级优先级最低。</p>
<p>  同一优先级的运算符，运算次序由结合方向所决定。(结合性：2 13 14 是从右至左 其他都是 从左至右)</p>
<p>  简单记就是：！ &gt; 算术运算符 &gt; 关系运算符 &gt; &amp;&amp; &gt; || &gt; 赋值运算符</p>
<h1>口诀</h1>
<p>括号成员第一;                //括号运算符<a href></a> 成员运算符. -&gt;</p>
<p>全体单目第二;              //所有的单目运算符比如++、 --、 +(正)、 -(负) 、指针运算*、&amp;</p>
<p>乘除余三,加减四;         //这个&quot;余&quot;是指取余运算即%</p>
<p>移位五，关系六;          //移位运算符：&lt;&lt; &gt;&gt; ，关系：&gt; &lt; &gt;= &lt;= 等</p>
<p>等于(与)不等排第七;      //即== 和!=</p>
<p>位与异或和位或;   &quot;三分天下&quot;八九十;     //这几个都是位运算: 位与(&amp;)异或(^)位或(|)</p>
<p>逻辑或跟与;              //逻辑运算符:|| 和 &amp;&amp;</p>
<p>十二和十一;           //注意顺序:优先级(||) 底于 优先级(&amp;&amp;)</p>
<p>条件高于赋值,                //三目运算符优先级排到13 位只比赋值运算符和&quot;,&quot;高</p>
<p>逗号运算级最低!        //逗号运算符优先级最低</p>
<h1>参考</h1>
<p><a href="https://blog.csdn.net/hitwhylz/article/details/14526569" target="_blank" rel="noopener">https://blog.csdn.net/hitwhylz/article/details/14526569</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/19/leetcode-刷题日常-130-Surrounded-Regions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/19/leetcode-刷题日常-130-Surrounded-Regions/" itemprop="url">130. Surrounded Regions</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-19T21:59:00+08:00">2019-06-19</time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-06-25T20:14:03+08:00">2019-06-25</time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>题目描述</h1>
<p><a href="https://leetcode.com/problems/surrounded-regions/" target="_blank" rel="noopener">130. Surrounded Regions</a></p>
<p>Difficulty: <strong>Medium</strong></p>
<p>Given a 2D board containing <code>'X'</code> and <code>'O'</code> (<strong>the letter O</strong>), capture all regions surrounded by <code>'X'</code>.</p>
<p>A region is captured by flipping all <code>'O'</code>s into <code>'X'</code>s in that surrounded region.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>
<p>After running your function, the board should be:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>
<p><strong>Explanation:</strong></p>
<p>Surrounded regions shouldn’t be on the border, which means that any <code>'O'</code> on the border of the board are not flipped to <code>'X'</code>. Any <code>'O'</code> that is not on the border and it is not connected to an <code>'O'</code> on the border will be flipped to <code>'X'</code>. Two cells are connected if they are adjacent cells connected horizontally or vertically.</p>
<h1>解法</h1>
<p>Language: <strong>Python3</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def solve(self, board: List[List[str]]) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify board in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<h1>并查集解法</h1>
<p>  虽然可以用BFS，DFS做，但是既然可以用并查集了，那就借这道题初探并查集。代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        self.m = len(board)</span><br><span class="line">        self.n = len(board[<span class="number">0</span>])</span><br><span class="line">        self.length = self.m * self.n</span><br><span class="line"></span><br><span class="line">        self.id = [<span class="literal">None</span>] * self.length</span><br><span class="line">        self.size = [<span class="number">1</span>] * self.length</span><br><span class="line">        self.surrounded = [<span class="literal">True</span>] * self.length</span><br><span class="line"></span><br><span class="line">        [operator.setitem(self.id, *([self.genIndex(i, j)] * <span class="number">2</span>))</span><br><span class="line">         <span class="keyword">for</span> i, row <span class="keyword">in</span> enumerate(board)</span><br><span class="line">         <span class="keyword">for</span> j, val <span class="keyword">in</span> enumerate(row) <span class="keyword">if</span> val == <span class="string">'O'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">genIndex</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.n * i + j</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, p)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> p != self.id[p]:</span><br><span class="line">            self.id[p] = self.id[self.id[p]]</span><br><span class="line">            p = self.id[p]</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        idp, idq = map(self.find, (p, q))</span><br><span class="line">        <span class="keyword">if</span> idp == idq:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        less, more = (</span><br><span class="line">            (idp, idq) <span class="keyword">if</span> self.size[idp] &lt; self.size[idq] <span class="keyword">else</span> (idq, idp))</span><br><span class="line"></span><br><span class="line">        self.id[less] = self.id[more]</span><br><span class="line">        self.size[more] += self.size[less]</span><br><span class="line">        self.surrounded[more] = self.surrounded[less] <span class="keyword">and</span> self.surrounded[more]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        uf = UnionFind(board)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, row <span class="keyword">in</span> enumerate(board):</span><br><span class="line">            <span class="keyword">for</span> j, val <span class="keyword">in</span> enumerate(row):</span><br><span class="line">                <span class="keyword">if</span> val != <span class="string">'O'</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                index = uf.genIndex(i, j)</span><br><span class="line"></span><br><span class="line">                [uf.union(index, uf.genIndex(y, z))</span><br><span class="line">                 <span class="keyword">for</span> x, y, z <span class="keyword">in</span> ((i, i - <span class="number">1</span>, j), (j, i, j - <span class="number">1</span>))</span><br><span class="line">                 <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">and</span> board[y][z] == <span class="string">'O'</span>]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span> <span class="keyword">or</span> i == uf.m - <span class="number">1</span> <span class="keyword">or</span> j == uf.n - <span class="number">1</span>:</span><br><span class="line">                    uf.surrounded[uf.find(index)] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        [operator.setitem(board[i], j, <span class="string">'X'</span>)</span><br><span class="line">         <span class="keyword">for</span> i <span class="keyword">in</span> xrange(uf.m)</span><br><span class="line">         <span class="keyword">for</span> j <span class="keyword">in</span> xrange(uf.n)</span><br><span class="line">         <span class="keyword">if</span> board[i][j] == <span class="string">'O'</span> <span class="keyword">and</span> uf.surrounded[uf.find(uf.genIndex(i, j))]]</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/18/leetcode-刷题日常-126-Word-Ladder-II/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/18/leetcode-刷题日常-126-Word-Ladder-II/" itemprop="url">126. Word Ladder II</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-18T22:19:00+08:00">2019-06-18</time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-06-25T20:14:20+08:00">2019-06-25</time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>题目描述</h1>
<p><a href="https://leetcode.com/problems/word-ladder-ii/" target="_blank" rel="noopener">126. Word Ladder II</a></p>
<p>Difficulty: <strong>Hard</strong></p>
<p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find all shortest transformation sequence(s) from <em>beginWord</em> to <em>endWord</em>, such that:</p>
<ol>
<li>Only one letter can be changed at a time</li>
<li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li>
</ol>
<p><strong>Note:</strong></p>
<ul>
<li>Return an empty list if there is no such transformation sequence.</li>
<li>All words have the same length.</li>
<li>All words contain only lowercase alphabetic characters.</li>
<li>You may assume no duplicates in the word list.</li>
<li>You may assume <em>beginWord</em> and <em>endWord</em> are non-empty and are not the same.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = &quot;hit&quot;,</span><br><span class="line">endWord = &quot;cog&quot;,</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = &quot;hit&quot;</span><br><span class="line">endWord = &quot;cog&quot;</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">Output: []</span><br><span class="line"></span><br><span class="line">Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no possible transformation.</span><br></pre></td></tr></table></figure>
<h1>分析</h1>
<p>不多说，直接给解法。</p>
<h2 id="bfs-dfs"><a class="header-anchor" href="#bfs-dfs">¶</a>BFS+DFS</h2>
<p>  上一题的BFS可以求出endWord到beginWord的最短距离，同时也求出了<strong>所有单词到beginWord的最短距离</strong>。该题想要找到到endWord的所有最短路径，那么每条最短路径上每个单词到beginWord都必须是最短路径，沿着最短路径到beginWord的距离也是<strong>最短距离</strong>，并且顺着最短路径由beginWord到每个单词结点的最短距离都是按顺序依次递增1的，这就限制了DFS的搜索顺序必须是按照BFS深度递增的顺序来搜索。BFS的同时可以记录每个单词对应的BFS序，那么DFS搜索的时候可以直接搜索序刚好比当前单词大1的单词。代码如下：</p>
<h3 id="300ms实现-我自己写的"><a class="header-anchor" href="#300ms实现-我自己写的">¶</a>300ms实现 我自己写的</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLadders</span><span class="params">(self, beginWord: str, endWord: str, wordList: List[str])</span> -&gt; List[List[str]]:</span></span><br><span class="line">        L = len(beginWord)</span><br><span class="line">        </span><br><span class="line">        all_combo_dict = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(L):</span><br><span class="line">                all_combo_dict[word[:i] + <span class="string">"*"</span> + word[i+<span class="number">1</span>:]].append(word)</span><br><span class="line">                </span><br><span class="line">        visited = &#123;beginWord:<span class="number">1</span>&#125;</span><br><span class="line">        mindistance = len(wordList) + <span class="number">1</span></span><br><span class="line">        q = Queue()</span><br><span class="line">        q.put((beginWord, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">            cur, level= q.get()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(L):</span><br><span class="line">                intermediate = cur[:i] + <span class="string">"*"</span> + cur[i+<span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">for</span> word <span class="keyword">in</span> all_combo_dict[intermediate]:</span><br><span class="line">                    <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        visited[word] = level + <span class="number">1</span></span><br><span class="line">                        q.put((word, level + <span class="number">1</span>))</span><br><span class="line">                        <span class="keyword">if</span> word == endWord:</span><br><span class="line">                            mindistance = level + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> mindistance == len(wordList) + <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">DFS</span><span class="params">(path)</span>:</span></span><br><span class="line">            beginWord = path[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> visited[beginWord] == mindistance: </span><br><span class="line">                <span class="keyword">if</span> beginWord == endWord:</span><br><span class="line">                    res.append(path)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(L):</span><br><span class="line">                intermediate = beginWord[:i] + <span class="string">"*"</span> + beginWord[i+<span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">for</span> word <span class="keyword">in</span> all_combo_dict[intermediate]:</span><br><span class="line">                    <span class="keyword">if</span> visited[word] == visited[beginWord] + <span class="number">1</span>:</span><br><span class="line">                        DFS(path + [word])                </span><br><span class="line">        res = []</span><br><span class="line">        DFS([beginWord])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="128ms实现"><a class="header-anchor" href="#128ms实现">¶</a>128ms实现</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLadders</span><span class="params">(self, beginWord: str, endWord: str, wordList: List[str])</span> -&gt; List[List[str]]:</span></span><br><span class="line">        start, end, dict = beginWord, endWord, set(wordList)</span><br><span class="line">        dict.update([start])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># build indexes</span></span><br><span class="line">        key_to_words = self.build_indexes(dict)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># bfs end to start search, calculate the distance to the end from each word</span></span><br><span class="line">        distance = self.bfs(end, start, key_to_words)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># dfs to search for all the shorted paths</span></span><br><span class="line">        results, path = [], [start]</span><br><span class="line">        self.dfs(start, end, key_to_words, distance, path, results)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> results</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 记录intermediate字典，比如dog对应的key是d*g,do*,*og</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_indexes</span><span class="params">(self, dict)</span>:</span></span><br><span class="line">        key_to_words = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> dict:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">                key = word[:i] + <span class="string">"%"</span> + word[i + <span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> key_to_words:</span><br><span class="line">                    key_to_words[key] = set([word])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    key_to_words[key].add(word)</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> key_to_words</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 从endWord开始搜索，搜索空间重心靠近endWord，这样可以避免一开始就搜索很多无效路径，命中率更高，此处需要注意！</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, end, start, key_to_words)</span>:</span></span><br><span class="line">        queue, distance = deque([end]), &#123;end : <span class="number">0</span>&#125;</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            word = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> word == start:</span><br><span class="line">                <span class="keyword">return</span> distance</span><br><span class="line">            <span class="keyword">for</span> next_word <span class="keyword">in</span> self.get_next_words(word, key_to_words):</span><br><span class="line">                <span class="keyword">if</span> next_word <span class="keyword">in</span> distance:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                queue.append(next_word)</span><br><span class="line">                distance[next_word] = distance[word] + <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> distance</span><br><span class="line">                </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_words</span><span class="params">(self, word, key_to_words)</span>:</span></span><br><span class="line">        next_words = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">            key = word[:i] + <span class="string">"%"</span> + word[i + <span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> key_to_words:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            next_words.extend(list(key_to_words[key]))</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> next_words</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, word, end, key_to_words, distance, path, results)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> word == end:</span><br><span class="line">            results.append(list(path))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> next_word <span class="keyword">in</span> self.get_next_words(word, key_to_words):</span><br><span class="line">            <span class="keyword">if</span> next_word <span class="keyword">not</span> <span class="keyword">in</span> distance:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> distance[next_word] != distance[word] - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            path.append(next_word)</span><br><span class="line">            self.dfs(next_word, end, key_to_words, distance, path, results)</span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure>
<h3 id="108ms-实现-单向bfs"><a class="header-anchor" href="#108ms-实现-单向bfs">¶</a>108ms 实现（单向BFS）</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLadders</span><span class="params">(self, beginWord: str, endWord: str, wordList: List[str])</span> -&gt; List[List[str]]:</span></span><br><span class="line">        neighbors = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(w)):</span><br><span class="line">                placeholder = w[:i] + <span class="string">'_'</span> + w[i+<span class="number">1</span>:]</span><br><span class="line">                neighbors[placeholder].append(w)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># bfs + build tree</span></span><br><span class="line">        tree = collections.defaultdict(set)//记录每个已访问结点，并且将后继结点加入字典值中</span><br><span class="line">        cur_layer = &#123;beginWord&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> cur_layer <span class="keyword">and</span> <span class="keyword">not</span> endWord <span class="keyword">in</span> cur_layer:</span><br><span class="line">            next_layer = collections.defaultdict(set)</span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> cur_layer:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">                    placeholder = word[:i] + <span class="string">'_'</span> + word[i+<span class="number">1</span>:]</span><br><span class="line">                    <span class="keyword">for</span> neigh <span class="keyword">in</span> neighbors[placeholder]:</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">not</span> neigh <span class="keyword">in</span> tree:</span><br><span class="line">                            next_layer[neigh].add(word)</span><br><span class="line">                            </span><br><span class="line">            tree.update(next_layer) <span class="comment"># 这条语句位置很重要，意味着结点可能被重复遍历</span></span><br><span class="line">            cur_layer = next_layer</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># dfs</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(source, dest)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> source == dest:</span><br><span class="line">                <span class="keyword">return</span> [[source]]</span><br><span class="line">            <span class="keyword">return</span> [pre_path + [dest] <span class="keyword">for</span> parent <span class="keyword">in</span> tree[dest] <span class="keyword">for</span> pre_path <span class="keyword">in</span> dfs(source, parent)]</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> dfs(beginWord, endWord)</span><br></pre></td></tr></table></figure>
<h2 id="双向搜索-parent-son字典回溯路径"><a class="header-anchor" href="#双向搜索-parent-son字典回溯路径">¶</a>双向搜索+parent/son字典回溯路径</h2>
<p>  这个是在submission里看到的一个64ms的解法，思路是从backward = {endWord}和forward = {beginWord}分别开始搜索，将所有相邻节点形成next_forward作为下一次搜索开始的forward集合，同时为了减慢搜索空间增加的速度，每次搜索都比较backward和forward的大小，小的那个集合重新当做forward，大的重新当做backward。在搜索的过程中，用parents字典记录每个节点的前驱节点，便于最后由endWord回溯路径。代码如下：</p>
<h3 id="双向bfs搜索-反向回溯"><a class="header-anchor" href="#双向bfs搜索-反向回溯">¶</a>双向BFS搜索，反向回溯</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLadders</span><span class="params">(self, beginWord, endWord, wordList)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type beginWord: str</span></span><br><span class="line"><span class="string">        :type endWord: str</span></span><br><span class="line"><span class="string">        :type wordList: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList <span class="keyword">or</span> <span class="keyword">not</span> endWord <span class="keyword">or</span> <span class="keyword">not</span> beginWord:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        wordList = set(wordList)</span><br><span class="line">        forward, backward = &#123;beginWord&#125;, &#123;endWord&#125;</span><br><span class="line">        direction = <span class="number">1</span></span><br><span class="line">        parents = defaultdict(set)</span><br><span class="line">        <span class="keyword">while</span> forward <span class="keyword">and</span> backward:</span><br><span class="line">            <span class="keyword">if</span> len(forward) &gt; len(backward):</span><br><span class="line">                forward, backward = backward, forward</span><br><span class="line">                <span class="comment"># We need to trace the direction in order to distinguish the parents</span></span><br><span class="line">                direction *= <span class="number">-1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># The new set of words which will be forward in the next iteration</span></span><br><span class="line">            next_foward = set()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Because all words in forward will be modified by one character</span></span><br><span class="line">            wordList -= forward</span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> forward:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">                    first, second = word[:i], word[i+<span class="number">1</span>:]</span><br><span class="line">                    <span class="keyword">for</span> ch <span class="keyword">in</span> string.ascii_lowercase:</span><br><span class="line">                        combined_word = first + ch + second</span><br><span class="line">                        <span class="keyword">if</span> combined_word <span class="keyword">in</span> wordList:</span><br><span class="line">                            next_foward.add(combined_word)</span><br><span class="line">                            <span class="comment"># Because at the last part, we find parents by indexing dictionary from endWord</span></span><br><span class="line">                            <span class="comment"># So when direction == 1, the combined_word is the key</span></span><br><span class="line">                            <span class="comment"># otherwise, the combined_word should be the value of dictionary.</span></span><br><span class="line">                            <span class="keyword">if</span> direction == <span class="number">1</span>:</span><br><span class="line">                                parents[combined_word].add(word)</span><br><span class="line">                            <span class="keyword">else</span>:</span><br><span class="line">                                parents[word].add(combined_word)</span><br><span class="line">                                </span><br><span class="line">            <span class="comment"># next_foward and backward are always in different direction,</span></span><br><span class="line">            <span class="comment"># so if they have common elements we find a path.</span></span><br><span class="line">            <span class="comment"># We check and return this function inside is because this problem finds the all shortest paths</span></span><br><span class="line">            <span class="keyword">if</span> next_foward &amp; backward:</span><br><span class="line">                <span class="comment"># Starting from the endWord, we find its parent and append to results</span></span><br><span class="line">                <span class="comment"># And do this until we reach the beginWord</span></span><br><span class="line">                results = [[endWord]]</span><br><span class="line">                <span class="keyword">while</span> results[<span class="number">0</span>][<span class="number">0</span>] != beginWord:</span><br><span class="line">                    results = [ [parent] + result <span class="keyword">for</span> result <span class="keyword">in</span> results <span class="keyword">for</span> parent <span class="keyword">in</span> parents[result[<span class="number">0</span>]] ]</span><br><span class="line">                <span class="keyword">return</span> results</span><br><span class="line">            forward = next_foward</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<h3 id="双向bfs搜索-正向回溯"><a class="header-anchor" href="#双向bfs搜索-正向回溯">¶</a>双向BFS搜索，正向回溯</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List <span class="comment"># 该模块作用即参数列表中冒号后面的部分，如wordList: List[str]，检查参数合法性</span></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLadders</span><span class="params">(self, beginWord: str, endWord: str, wordList: List[str])</span> -&gt; List[List[str]]:</span></span><br><span class="line"></span><br><span class="line">        tree, wordSet, n = collections.defaultdict(set), set(wordList), len(beginWord)</span><br><span class="line">        <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordSet:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        found, fq, bq, nq, isForward = <span class="literal">False</span>, &#123;beginWord&#125;, &#123;endWord&#125;, set(), <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> fq <span class="keyword">and</span> <span class="keyword">not</span> found:</span><br><span class="line">            wordSet -= fq</span><br><span class="line">            <span class="keyword">for</span> curWord <span class="keyword">in</span> fq:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(curWord)):</span><br><span class="line">                    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">'abcdefghijklmnopqrstuvwxyz'</span>:</span><br><span class="line">                        nextWord = curWord[:i] + c + curWord[i + <span class="number">1</span>:]</span><br><span class="line">                        <span class="keyword">if</span> nextWord <span class="keyword">in</span> wordSet:</span><br><span class="line">                            <span class="keyword">if</span> nextWord <span class="keyword">in</span> bq:</span><br><span class="line">                                found = <span class="literal">True</span></span><br><span class="line">                            <span class="keyword">else</span>:</span><br><span class="line">                                nq.add(nextWord)</span><br><span class="line">                            tree[curWord].add(nextWord) <span class="keyword">if</span> isForward <span class="keyword">else</span> tree[nextWord].add(curWord) <span class="comment"># 将后继结点加入当前结点的字典值</span></span><br><span class="line">            fq.clear()</span><br><span class="line">            fq, nq = nq, fq <span class="comment"># 此处很巧妙，将fq清空当做下一次的nq用，从而省去了重新分配和初始化nq的时间</span></span><br><span class="line">            <span class="keyword">if</span> len(fq) &gt; len(bq):</span><br><span class="line">                fq, bq, isForward = bq, fq, <span class="keyword">not</span> isForward</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bt</span><span class="params">(word)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> word == endWord:</span><br><span class="line">                <span class="keyword">return</span> [[word]]</span><br><span class="line"></span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">for</span> nextWord <span class="keyword">in</span> tree[word]:</span><br><span class="line">                results = bt(nextWord)</span><br><span class="line">                <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">                    result.insert(<span class="number">0</span>, word)</span><br><span class="line">                    res.append(result)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> bt(beginWord)</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/18/leetcode-刷题日常-127-Word-Ladder/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/18/leetcode-刷题日常-127-Word-Ladder/" itemprop="url">127. Word Ladder</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-18T11:38:00+08:00">2019-06-18</time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-06-25T20:15:05+08:00">2019-06-25</time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>题目描述</h1>
<p><a href="https://leetcode.com/problems/word-ladder/" target="_blank" rel="noopener">127. Word Ladder</a></p>
<p>Difficulty: <strong>Medium</strong></p>
<p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:</p>
<ol>
<li>Only one letter can be changed at a time.</li>
<li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li>
</ol>
<p><strong>Note:</strong></p>
<ul>
<li>Return 0 if there is no such transformation sequence.</li>
<li>All words have the same length.</li>
<li>All words contain only lowercase alphabetic characters.</li>
<li>You may assume no duplicates in the word list.</li>
<li>You may assume <em>beginWord</em> and <em>endWord</em> are non-empty and are not the same.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = &quot;hit&quot;,</span><br><span class="line">endWord = &quot;cog&quot;,</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">Output: 5</span><br><span class="line"></span><br><span class="line">Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,</span><br><span class="line">return its length 5.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = &quot;hit&quot;</span><br><span class="line">endWord = &quot;cog&quot;</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no possible transformation.</span><br></pre></td></tr></table></figure>
<h1>分析</h1>
<p>  如果将每个单词看成图中的一个结点，将只差一个字母的两个单词看成两个相邻接的结点，则问题可转化为用宽度优先搜索求图中两点最短路径的问题。如下图：<br>
<img src="https://leetcode.com/problems/word-ladder/Figures/127/Word_Ladder_1.png" alt="avatar"></p>
<p>  为了找到每个结点的邻接节点，可以将每个单词中每个字母依次分别替换成*，然后以替换后的单词为key，原单词为value建立一个dict，比如dog就对应d*g,*og,do*三个key。单词dog的所有邻接单词都在dict[d*g],dict[*og],dict[do*]这三个列表中，记得还要用visited数组标志单词有没有被遍历过，防止死循环爆栈。代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span><span class="params">(self, beginWord, endWord, wordList)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type beginWord: str</span></span><br><span class="line"><span class="string">        :type endWord: str</span></span><br><span class="line"><span class="string">        :type wordList: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList <span class="keyword">or</span> <span class="keyword">not</span> endWord <span class="keyword">or</span> <span class="keyword">not</span> beginWord <span class="keyword">or</span> <span class="keyword">not</span> wordList:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Since all words are of same length.</span></span><br><span class="line">        L = len(beginWord)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Dictionary to hold combination of words that can be formed,</span></span><br><span class="line">        <span class="comment"># from any given word. By changing one letter at a time.</span></span><br><span class="line">        all_combo_dict = defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(L):</span><br><span class="line">                <span class="comment"># Key is the generic word</span></span><br><span class="line">                <span class="comment"># Value is a list of words which have the same intermediate generic word.</span></span><br><span class="line">                all_combo_dict[word[:i] + <span class="string">"*"</span> + word[i+<span class="number">1</span>:]].append(word)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Queue for BFS</span></span><br><span class="line">        queue = [(beginWord, <span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># Visited to make sure we don't repeat processing same word.</span></span><br><span class="line">        visited = &#123;beginWord: <span class="literal">True</span>&#125;</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            current_word, level = queue.pop(<span class="number">0</span>)      </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(L):</span><br><span class="line">                <span class="comment"># Intermediate words for current word</span></span><br><span class="line">                intermediate_word = current_word[:i] + <span class="string">"*"</span> + current_word[i+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Next states are all the words which share the same intermediate state.</span></span><br><span class="line">                <span class="keyword">for</span> word <span class="keyword">in</span> all_combo_dict[intermediate_word]:</span><br><span class="line">                    <span class="comment"># If at any point if we find what we are looking for</span></span><br><span class="line">                    <span class="comment"># i.e. the end word - we can return with the answer.</span></span><br><span class="line">                    <span class="keyword">if</span> word == endWord:</span><br><span class="line">                        <span class="keyword">return</span> level + <span class="number">1</span></span><br><span class="line">                    <span class="comment"># Otherwise, add it to the BFS Queue. Also mark it visited</span></span><br><span class="line">                    <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        visited[word] = <span class="literal">True</span></span><br><span class="line">                        queue.append((word, level + <span class="number">1</span>))</span><br><span class="line">                all_combo_dict[intermediate_word] = []</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>  上述解法可以通过用双向BFS缩小一半搜索空间来进行优化，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.length = <span class="number">0</span></span><br><span class="line">        <span class="comment"># Dictionary to hold combination of words that can be formed,</span></span><br><span class="line">        <span class="comment"># from any given word. By changing one letter at a time.</span></span><br><span class="line">        self.all_combo_dict = defaultdict(list)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visitWordNode</span><span class="params">(self, queue, visited, others_visited)</span>:</span></span><br><span class="line">        current_word, level = queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.length):</span><br><span class="line">            <span class="comment"># Intermediate words for current word</span></span><br><span class="line">            intermediate_word = current_word[:i] + <span class="string">"*"</span> + current_word[i+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Next states are all the words which share the same intermediate state.</span></span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> self.all_combo_dict[intermediate_word]:</span><br><span class="line">                <span class="comment"># If the intermediate state/word has already been visited from the</span></span><br><span class="line">                <span class="comment"># other parallel traversal this means we have found the answer.</span></span><br><span class="line">                <span class="keyword">if</span> word <span class="keyword">in</span> others_visited:</span><br><span class="line">                    <span class="keyword">return</span> level + others_visited[word]</span><br><span class="line">                <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    <span class="comment"># Save the level as the value of the dictionary, to save number of hops.</span></span><br><span class="line">                    visited[word] = level + <span class="number">1</span></span><br><span class="line">                    queue.append((word, level + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span><span class="params">(self, beginWord, endWord, wordList)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type beginWord: str</span></span><br><span class="line"><span class="string">        :type endWord: str</span></span><br><span class="line"><span class="string">        :type wordList: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList <span class="keyword">or</span> <span class="keyword">not</span> endWord <span class="keyword">or</span> <span class="keyword">not</span> beginWord <span class="keyword">or</span> <span class="keyword">not</span> wordList:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Since all words are of same length.</span></span><br><span class="line">        self.length = len(beginWord)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(self.length):</span><br><span class="line">                <span class="comment"># Key is the generic word</span></span><br><span class="line">                <span class="comment"># Value is a list of words which have the same intermediate generic word.</span></span><br><span class="line">                self.all_combo_dict[word[:i] + <span class="string">"*"</span> + word[i+<span class="number">1</span>:]].append(word)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Queues for birdirectional BFS</span></span><br><span class="line">        queue_begin = [(beginWord, <span class="number">1</span>)] <span class="comment"># BFS starting from beginWord</span></span><br><span class="line">        queue_end = [(endWord, <span class="number">1</span>)] <span class="comment"># BFS starting from endWord</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Visited to make sure we don't repeat processing same word</span></span><br><span class="line">        visited_begin = &#123;beginWord: <span class="number">1</span>&#125;</span><br><span class="line">        visited_end = &#123;endWord: <span class="number">1</span>&#125;</span><br><span class="line">        ans = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># We do a birdirectional search starting one pointer from begin</span></span><br><span class="line">        <span class="comment"># word and one pointer from end word. Hopping one by one.</span></span><br><span class="line">        <span class="keyword">while</span> queue_begin <span class="keyword">and</span> queue_end:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># One hop from begin word</span></span><br><span class="line">            ans = self.visitWordNode(queue_begin, visited_begin, visited_end)</span><br><span class="line">            <span class="keyword">if</span> ans:</span><br><span class="line">                <span class="keyword">return</span> ans</span><br><span class="line">            <span class="comment"># One hop from end word</span></span><br><span class="line">            ans = self.visitWordNode(queue_end, visited_end, visited_begin)</span><br><span class="line">            <span class="keyword">if</span> ans:</span><br><span class="line">                <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1>扩展：C语言实现</h1>
<ol>
<li>Hash桶查找字符串 + 基于链表的队列</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) \</span></span><br><span class="line">    ((type *)((<span class="keyword">char</span> *)(ptr) - (<span class="keyword">size_t</span>)&amp;(((type *)<span class="number">0</span>)-&gt;member)))</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line">    container_of(ptr, type, member)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_first_entry(ptr, type, field) list_entry((ptr)-&gt;next, type, field)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_last_entry(ptr, type, field) list_entry((ptr)-&gt;prev, type, field)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each(p, head) \</span></span><br><span class="line">    <span class="keyword">for</span> (p = (head)-&gt;next; p != (head); p = p-&gt;next)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//删除元素时用这个，防止删除pos后，pos-&gt;next指向undefined state</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_safe(p, n, head) \</span></span><br><span class="line">    <span class="keyword">for</span> (p = (head)-&gt;next, n = p-&gt;next; p != (head); p = n, n = p-&gt;next)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hlist_for_each(pos, head) \</span></span><br><span class="line">    <span class="keyword">for</span> (pos = (head)-&gt;first; pos; pos = pos-&gt;next)</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除元素时用这个，防止删除pos后，pos-&gt;next指向undefined state</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hlist_for_each_safe(pos, n, head) \</span></span><br><span class="line">    <span class="keyword">for</span> (pos = (head)-&gt;first; pos &amp;&amp; (&#123; n = pos-&gt;next; <span class="literal">true</span>; &#125;); pos = n)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">first</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">next</span>, **<span class="title">pprev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">INIT_HLIST_HEAD</span><span class="params">(struct hlist_head *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    h-&gt;first = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hlist_add_head</span><span class="params">(struct hlist_node *n, struct hlist_head *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h-&gt;first != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        h-&gt;first-&gt;pprev = &amp;n-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    n-&gt;next = h-&gt;first;</span><br><span class="line">    n-&gt;pprev = &amp;h-&gt;first;</span><br><span class="line">    h-&gt;first = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">INIT_LIST_HEAD</span><span class="params">(struct list_head *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>-&gt;next = <span class="built_in">list</span>-&gt;prev = <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">list_empty</span><span class="params">(<span class="keyword">const</span> struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (head-&gt;next == head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __list_add(struct list_head *<span class="keyword">new</span>, struct list_head *prev, struct list_head *next)</span><br><span class="line">&#123;</span><br><span class="line">    next-&gt;prev = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = next;</span><br><span class="line">    <span class="keyword">new</span>-&gt;prev = prev;</span><br><span class="line">    prev-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">list_add</span><span class="params">(struct list_head *_new, struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __list_add(_new, head, head-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">list_add_tail</span><span class="params">(struct list_head *_new, struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __list_add(_new, head-&gt;prev, head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __list_del(struct list_head *entry)</span><br><span class="line">&#123;</span><br><span class="line">    entry-&gt;next-&gt;prev = entry-&gt;prev;</span><br><span class="line">    entry-&gt;prev-&gt;next = entry-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">list_del</span><span class="params">(struct list_head *entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __list_del(entry);</span><br><span class="line">    entry-&gt;next = entry-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">word_node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line">    <span class="keyword">char</span> *word;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">link</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取字符串的Hash值，size为word_list_size，每个单词对应一个桶</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BKDRHash</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> seed = <span class="number">131</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*str != <span class="string">'\0'</span>) &#123;</span><br><span class="line">        hash = hash * seed + (*str++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash % size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hlist查找函数，用来根据字符串的值快速查找某个word_node结点</span></span><br><span class="line"><span class="function">struct word_node *<span class="title">find</span><span class="params">(<span class="keyword">char</span> *word, struct hlist_head *hhead, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">int</span> hash = BKDRHash(word, size);</span><br><span class="line">    hlist_for_each(p, &amp;hhead[hash]) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">word_node</span> *<span class="title">node</span> = <span class="title">list_entry</span>(<span class="title">p</span>, <span class="title">struct</span> <span class="title">word_node</span>, <span class="title">node</span>);</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;step == <span class="number">0</span> &amp;&amp; !<span class="built_in">strcmp</span>(node-&gt;word, word)) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;<span class="comment">//node-&gt;step为0代表还未遍历到这个结点，node-&gt;step == 0这个判断很关键，防止死循环，比如hit-&gt;hot-&gt;hit-&gt;hot-&gt;......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="keyword">char</span>* begin_word, <span class="keyword">char</span>* end_word, <span class="keyword">char</span>** word_list, <span class="keyword">int</span> word_list_size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, len = <span class="built_in">strlen</span>(begin_word);</span><br><span class="line">    <span class="keyword">char</span> *word = <span class="built_in">malloc</span>(len + <span class="number">1</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">queue</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">word_node</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内核hash链表hlist和链表list的用法都是先malloc头结点或者定义头结点变量，然后init头结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> *<span class="title">hhead</span> = <span class="title">malloc</span>(<span class="title">word_list_size</span> * <span class="title">sizeof</span>(*<span class="title">hhead</span>));</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; word_list_size; i++) &#123;</span><br><span class="line">        INIT_HLIST_HEAD(hhead + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; word_list_size; i++) &#123;</span><br><span class="line">        node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*node));</span><br><span class="line">        node-&gt;word = word_list[i];</span><br><span class="line">        node-&gt;step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hash = BKDRHash(word_list[i], word_list_size);</span><br><span class="line">        hlist_add_head(&amp;node-&gt;node, &amp;hhead[hash]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    INIT_LIST_HEAD(&amp;<span class="built_in">queue</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">word_node</span> *<span class="title">first</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(*<span class="title">node</span>));</span></span><br><span class="line">    first-&gt;word = begin_word;</span><br><span class="line">    first-&gt;step = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">strcmp</span>(first-&gt;word, end_word)) &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(word, first-&gt;word);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c;</span><br><span class="line">            <span class="keyword">char</span> o = word[i];</span><br><span class="line">            <span class="keyword">for</span> (c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == o) <span class="keyword">continue</span>;</span><br><span class="line">                word[i] = c;</span><br><span class="line">                node = find(word, hhead, word_list_size);</span><br><span class="line">                <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    list_add_tail(&amp;node-&gt;link, &amp;<span class="built_in">queue</span>);<span class="comment">//入队</span></span><br><span class="line">                    node-&gt;step = first-&gt;step + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            word[i] = o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (list_empty(&amp;<span class="built_in">queue</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            first = list_first_entry(&amp;<span class="built_in">queue</span>, struct word_node, link);</span><br><span class="line">            list_del(&amp;first-&gt;link);<span class="comment">//出队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> first-&gt;step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>字典树查找字符串 + 基于链表的队列</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TriNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TriNode</span>** <span class="title">link</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> isword;<span class="comment">//标记单词是否属于字典树</span></span><br><span class="line">&#125;;<span class="comment">//字典树结点</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>* item;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>* <span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;<span class="comment">//链队列结点</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">head</span>, *<span class="title">tail</span>;</span></span><br><span class="line"><span class="function">struct QNode* <span class="title">qinit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qput</span><span class="params">(struct QNode*, <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">qget</span><span class="params">(struct QNode *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">qempty</span><span class="params">(struct QNode*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">struct TriNode* <span class="title">createTri</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">struct TriNode* <span class="title">buildDict</span><span class="params">(<span class="keyword">char</span>**, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchDict</span><span class="params">(struct TriNode *, <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="keyword">char</span> * beginWord, <span class="keyword">char</span> * endWord, <span class="keyword">char</span> ** wordList, <span class="keyword">int</span> wordListSize)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TriNode</span>* <span class="title">root</span>=<span class="title">buildDict</span>(<span class="title">wordList</span>, <span class="title">wordListSize</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>* <span class="title">q</span>=<span class="title">qinit</span>();</span></span><br><span class="line">    <span class="keyword">char</span> dummy;</span><br><span class="line">    <span class="keyword">char</span> *cur;</span><br><span class="line">    <span class="keyword">int</span> steps=<span class="number">1</span>;</span><br><span class="line">    qput(q, beginWord);</span><br><span class="line">    qput(q, &amp;dummy);<span class="comment">//dummy用来区分搜索深度,dummy之前到head的结点是step,dummy之后到tail的结点是step+1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!qempty(q)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((cur=qget(q)) == &amp;dummy) &#123;</span><br><span class="line">            steps++;<span class="comment">//增加搜索深度</span></span><br><span class="line">            qput(q, &amp;dummy);</span><br><span class="line">            <span class="keyword">continue</span>;           </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//保证代码到此处cur的深度为steps</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cur, endWord)==<span class="number">0</span>) <span class="keyword">return</span> steps;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(cur);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c=cur[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> d=j+<span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">if</span> (c!=d) &#123;</span><br><span class="line">                    cur[i]=d;</span><br><span class="line">                    <span class="keyword">if</span> (searchDict(root, cur)) &#123;<span class="comment">//找到单词之后就从字典树中删除单词</span></span><br><span class="line">                        <span class="keyword">char</span> *s=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(len+<span class="number">1</span>);</span><br><span class="line">                        <span class="built_in">strcpy</span>(s,cur);                   </span><br><span class="line">                        qput(q,s);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;       </span><br><span class="line">            &#125;</span><br><span class="line">            cur[i]=c; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur != beginWord)</span><br><span class="line">            <span class="built_in">free</span>(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct TriNode* <span class="title">buildDict</span><span class="params">(<span class="keyword">char</span>** dict, <span class="keyword">int</span> dlen)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TriNode</span>* <span class="title">root</span>=<span class="title">createTri</span>();</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; dlen; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TriNode</span>* <span class="title">node</span>=<span class="title">root</span>;</span></span><br><span class="line">        <span class="keyword">char</span> *word=dict[i];</span><br><span class="line">        <span class="keyword">int</span> len=<span class="built_in">strlen</span>(word);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> k=word[j]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;link[k] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                node-&gt;link[k]=createTri();</span><br><span class="line">            &#125;</span><br><span class="line">            node=node-&gt;link[k];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isword=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct TriNode* <span class="title">createTri</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TriNode</span>* <span class="title">node</span>=(<span class="title">struct</span> <span class="title">TriNode</span>*)<span class="title">calloc</span>(1, <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">TriNode</span>));</span></span><br><span class="line">    node-&gt;link=(struct TriNode**)<span class="built_in">calloc</span>(<span class="number">26</span>, <span class="keyword">sizeof</span>(struct TriNode*));</span><br><span class="line">    node-&gt;isword=<span class="literal">false</span>;<span class="comment">//root结点代表空字符串</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchDict</span><span class="params">(struct TriNode *root, <span class="keyword">char</span> *word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(word);</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TriNode</span> *<span class="title">node</span>=<span class="title">root</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = word[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;link[k] == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        node=node-&gt;link[k];       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;isword == <span class="literal">false</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    node-&gt;isword=<span class="literal">false</span>;<span class="comment">//从字典树中删除该单词</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct QNode* <span class="title">qinit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    head=(struct QNode*)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(struct QNode));</span><br><span class="line">    tail=(struct QNode*)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(struct QNode));</span><br><span class="line">    head-&gt;next=tail;</span><br><span class="line">    head-&gt;prev=tail;</span><br><span class="line">    tail-&gt;next=head;</span><br><span class="line">    tail-&gt;prev=head;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qput</span><span class="params">(struct QNode* q, <span class="keyword">char</span> * item)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">t</span>=(<span class="title">struct</span> <span class="title">QNode</span> *)<span class="title">calloc</span>(1, <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">QNode</span>));</span>   </span><br><span class="line">    t-&gt;item=item;</span><br><span class="line">    t-&gt;next=tail;</span><br><span class="line">    t-&gt;prev=tail-&gt;prev;</span><br><span class="line">    tail-&gt;prev-&gt;next=t;</span><br><span class="line">    tail-&gt;prev=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">qget</span><span class="params">(struct QNode *q)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">t</span>=<span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    t-&gt;next-&gt;prev=t-&gt;prev;</span><br><span class="line">    t-&gt;prev-&gt;next=t-&gt;next;</span><br><span class="line">    <span class="keyword">char</span> *c=t-&gt;item;</span><br><span class="line">    <span class="built_in">free</span>(t);</span><br><span class="line">    <span class="keyword">return</span> c;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">qempty</span><span class="params">(struct QNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next-&gt;next-&gt;next==head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>小结</li>
</ol>
<p>  C语言的解法关键在于怎么高效查找字符串和实现队列。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/18/leetcode-刷题日常-123-Best-Time-to-Buy-and-Sell-Stock-III/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/18/leetcode-刷题日常-123-Best-Time-to-Buy-and-Sell-Stock-III/" itemprop="url">123. Best Time to Buy and Sell Stock III</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-18T10:40:00+08:00">2019-06-18</time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-06-30T22:06:00+08:00">2019-06-30</time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>题目描述</h1>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">123. Best Time to Buy and Sell Stock III</a></p>
<p>Difficulty: <strong>Hard</strong></p>
<p>Say you have an array for which the <em>i</em><sup>th</sup> element is the price of a given stock on day <em>i</em>.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most <em>two</em> transactions.</p>
<p>**Note: **You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,3,5,0,0,3,1,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.</span><br><span class="line">             Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.</span><br><span class="line">             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are</span><br><span class="line">             engaging multiple transactions at the same time. You must sell before buying again.</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transaction is done, i.e. max profit = 0.</span><br></pre></td></tr></table></figure>
<h1>分析</h1>
<p>  股票问题：假设你有一个数组，其中第i个元素是某只股票在第i天的价格。设计一个算法来寻找最大的利润。您最多可以完成k次买卖。k = 1和k为任意多次就是Best Time to Buy and Sell Stock I/II，还有一个k为固定整数的题Best Time to Buy and Sell Stock IV。这类题可用动态规划求解。以下主要针对k为固定整数时的通解的动态规划数组表示方式讨论，其他情况可以直接套用通解或者贪心或者k=1的特殊解法：</p>
<ul>
<li>dp[k][i]表示到价格i为止，允许最多k次交易时的最大利润，则递推公式为:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[k][i]=max(dp[k][i-1], prices[i]-prices[j]+dp[k-1][j])，j的范围为[0, i]</span><br><span class="line">注：dp[k][i-1]为不包含价格i的k次交易，prices[i]-prices[j]+dp[k-1][j]代表包含价格i的k次交易</span><br></pre></td></tr></table></figure>
<ul>
<li>local[i][j]为在到达第i天时最多可进行j次交易并且最后一次交易在最后一天卖出的最大利润，此为局部最优。然后我们定义global[i][j]为在到达第i天时最多可进行j次交易的最大利润，此为全局最优。递推式为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local[i][j] = max(global[i - 1][j - 1] + max(diff, 0), local[i - 1][j] + diff)</span><br><span class="line">global[i][j] = max(local[i][j], global[i - 1][j])</span><br></pre></td></tr></table></figure>
<ul>
<li>用两个数组buy和sell来分别表示第j次买入交易的最大收益值和第j次卖出交易的最大收益值。这样，DP状态转移方程为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buy[j] = max(buy[j],sell[j-1]-prices[i]); //在第i点处进行第j次买入交易。</span><br><span class="line">sell[j] = max(sell[j],buy[j]+prices[i]);//在第i点处进行第j次卖出交易。</span><br></pre></td></tr></table></figure>
<ul>
<li>buy，sell数组针对k = 2情况的特解：Buy1[i]表示前i天做第一笔交易买入股票后剩下的最多的钱，Sell1[i]表示前i天做第一笔交易卖出股票后剩下的最多的钱，Buy2[i]表示前i天做第二笔交易买入股票后剩下的最多的钱，Sell2[i]表示前i天做第二笔交易卖出股票后剩下的最多的钱。则动态规划递推式如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sell2 = max(sell2, buy2+prices[i]);  </span><br><span class="line">buy2 = max(buy2, sell1-prices[i]);  </span><br><span class="line">sell1 = max(sell1, buy1+prices[i]);  </span><br><span class="line">buy1 = max(buy1,-prices[i]);</span><br></pre></td></tr></table></figure>
<h1>代码</h1>
<ul>
<li>dp[k][i]=max(dp[k][i-1], prices[i]-prices[j]+dp[k-1][j])</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfitiv</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = prices.size(), K , temp, i, res= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(len&lt;=<span class="number">2</span>*k)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">            <span class="keyword">if</span>(prices[i]&gt;prices[i<span class="number">-1</span>])</span><br><span class="line">                res +=(prices[i]-prices[i<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(K = <span class="number">1</span>; K &lt;= k; K++)&#123;</span><br><span class="line">        temp = dp[<span class="number">0</span>] - prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            temp = max(temp, dp[i]-prices[i]);</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-1</span>], prices[i] +temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>local[i][j] = max(global[i - 1][j - 1] + max(diff, 0), local[i - 1][j] + diff), global[i][j] = max(local[i][j], global[i - 1][j])</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= prices.size()) <span class="keyword">return</span> solveMaxProfit(prices);</span><br><span class="line">        <span class="keyword">int</span> g[k + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> l[k + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.size() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> diff = prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = k; j &gt;= <span class="number">1</span>; --j) &#123;</span><br><span class="line">                l[j] = max(g[j - <span class="number">1</span>] + max(diff, <span class="number">0</span>), l[j] + diff);</span><br><span class="line">                g[j] = max(g[j], l[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> g[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solveMaxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] - prices[i - <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>buy[j] = max(buy[j],sell[j-1]-prices[i]); //在第i点处进行第j次买入交易。<br><br>
sell[j] = max(sell[j],buy[j]+prices[i]);//在第i点处进行第j次卖出交易。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.size();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (len/<span class="number">2</span> &lt; k)&#123;</span><br><span class="line">            <span class="keyword">return</span> quickSolve(prices);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; buy(k+<span class="number">1</span>,INT_MIN);<span class="comment">//第k次交易买入的最大收益；</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sell(k+<span class="number">1</span>,<span class="number">0</span>);<span class="comment">//第k次交易卖出的最大收益；</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line">                buy[j] = max(buy[j],sell[j<span class="number">-1</span>]-prices[i]);</span><br><span class="line">                sell[j] = max(sell[j],buy[j]+prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell[k];</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">quickSolve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.size(), profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">            <span class="comment">// as long as there is a price gap, we gain a profit.</span></span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) profit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">lidanyang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">148</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">63</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/lidanyang" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1261727840@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lidanyang</span>

  

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.0.0</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.0"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=6.0.0"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=6.0.0"></script>


  

</body>
</html>
