<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.0" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="分类">
<meta property="og:url" content="http://yoursite.com/categories/index.html">
<meta property="og:site_name" content="Just a blog">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-05-28T06:22:34.105Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="分类">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/categories/">





  <title>Just a blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Just a blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/21/leetcode-刷题日常-144-Binary-Tree-Preorder-Traversal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/21/leetcode-刷题日常-144-Binary-Tree-Preorder-Traversal/" itemprop="url">144. Binary Tree Preorder Traversal</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-21T21:38:00+08:00">2019-06-21</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>题目描述</h1>
<p><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. Binary Tree Preorder Traversal</a></p>
<p>Difficulty: <strong>Medium</strong></p>
<p>Given a binary tree, return the <em>preorder</em> traversal of its nodes’ values.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,2,3]</span><br></pre></td></tr></table></figure>
<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>
<h1>解法</h1>
<h2 id="法一"><a class="header-anchor" href="#法一">¶</a>法一</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.left = None</span><br><span class="line">#         self.right = None</span><br><span class="line">​</span><br><span class="line">class Solution:</span><br><span class="line">    def preorderTraversal(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        stack = []</span><br><span class="line">        res = []</span><br><span class="line">        if not root:</span><br><span class="line">            return []</span><br><span class="line">        stack.append(root)</span><br><span class="line">        while len(stack) != 0:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            if node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">            if node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>
<h2 id="法二"><a class="header-anchor" href="#法二">¶</a>法二</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        ans, st = [],[]</span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> st:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                ans.append(root.val)</span><br><span class="line">                st.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            root = st[<span class="number">-1</span>].right</span><br><span class="line">            st.pop()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/21/leetcode-刷题日常-138-Copy-List-with-Random-Pointer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/21/leetcode-刷题日常-138-Copy-List-with-Random-Pointer/" itemprop="url">138. Copy List with Random Pointer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-21T19:44:00+08:00">2019-06-21</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>题目描述</h1>
<p><a href="https://leetcode.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">138. Copy List with Random Pointer</a></p>
<p>Difficulty: <strong>Medium</strong></p>
<p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>
<p>Return a of the list.</p>
<p><strong>Example 1:</strong></p>
<p><strong><img src="https://discuss.leetcode.com/uploads/files/1470150906153-2yxeznm.png" alt></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&#123;&quot;$id&quot;:&quot;1&quot;,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;next&quot;:null,&quot;random&quot;:&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&quot;val&quot;:2&#125;,&quot;random&quot;:&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&quot;val&quot;:1&#125;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Node 1&apos;s value is 1, both of its next and random pointer points to Node 2.</span><br><span class="line">Node 2&apos;s value is 2, its next pointer points to null and its random pointer points to itself.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li>You must return the <strong>copy of the given head</strong> as a reference to the cloned list.</li>
</ol>
<h1>解法</h1>
<p>  此题和clone graph那道题一样用BFS/DFS+hashmap求解;</p>
<h2 id="dfs"><a class="header-anchor" href="#dfs">¶</a>DFS</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">DFS</span><span class="params">(head)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> dic[head]                </span><br><span class="line">            new = Node(head.val, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">            dic[head] = new</span><br><span class="line">            new.next = DFS(head.next)</span><br><span class="line">            new.random = DFS(head.random)</span><br><span class="line">            <span class="keyword">return</span> new</span><br><span class="line">        <span class="keyword">return</span> DFS(head)</span><br></pre></td></tr></table></figure>
<h2 id="bfs"><a class="header-anchor" href="#bfs">¶</a>BFS</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        q = deque([head])</span><br><span class="line">        new = Node(head.val, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">        dic[head] = new</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            node = q.popleft()</span><br><span class="line">            <span class="keyword">if</span> node.next:</span><br><span class="line">                <span class="keyword">if</span> node.next <span class="keyword">not</span> <span class="keyword">in</span> dic:                    </span><br><span class="line">                    dic[node.next] = Node(node.next.val, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">                    q.append(node.next)</span><br><span class="line">                dic[node].next = dic[node.next]</span><br><span class="line">            <span class="keyword">if</span> node.random:</span><br><span class="line">                <span class="keyword">if</span> node.random <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                    dic[node.random] = Node(node.random.val, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">                    q.append(node.random)</span><br><span class="line">                dic[node].random = dic[node.random]</span><br><span class="line">        <span class="keyword">return</span> dic[head]</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/21/leetcode-刷题日常-135-CandyCopy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/21/leetcode-刷题日常-135-CandyCopy/" itemprop="url">135. Candy</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-21T16:57:00+08:00">2019-06-21</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>题目描述</h1>
<p><a href="https://leetcode.com/problems/candy/" target="_blank" rel="noopener">135. Candy</a></p>
<p>Difficulty: <strong>Hard</strong></p>
<p>There are <em>N</em> children standing in a line. Each child is assigned a rating value.</p>
<p>You are giving candies to these children subjected to the following requirements:</p>
<ul>
<li>Each child must have at least one candy.</li>
<li>Children with a higher rating get more candies than their neighbors.</li>
</ul>
<p>What is the minimum candies you must give?</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,0,2]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.</span><br><span class="line">             The third child gets 1 candy because it satisfies the above two conditions.</span><br></pre></td></tr></table></figure>
<h1>解法</h1>
<p>  参考leetcode的solution专栏，一共有四个解法。</p>
<h2 id="法一-暴力解法"><a class="header-anchor" href="#法一-暴力解法">¶</a>法一 暴力解法</h2>
<p>  最简单的方法是使用一维数组candy来跟踪给学生的糖果。 首先，我们给每个学生1个糖果。然后，对每个i，如果ratings[i] &gt; ratings[i + 1] &amp;&amp; candies[i] &lt;= candies[i + 1]，则更新candies[i]为candies[i + 1] + 1;如果ratings[i] &gt; ratings[i - 1] &amp;&amp; candies[i] &lt;= candies[i - 1])，则更新candies[i]为candies[i - 1] + 1。用这种方式从左到右遍历调整多次，直到没有发生值的改变，就说明到达目标状态了，可以用一个flag记录值的改变情况。</p>
<p>  最后，我们把candy的所有元素加起来，以获得所需的最少数量的糖果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="keyword">int</span>[] ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] candies = <span class="keyword">new</span> <span class="keyword">int</span>[ratings.length];</span><br><span class="line">        Arrays.fill(candies, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ratings.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != ratings.length - <span class="number">1</span> &amp;&amp; ratings[i] &gt; ratings[i + <span class="number">1</span>] &amp;&amp; candies[i] &lt;= candies[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                    candies[i] = candies[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; ratings[i] &gt; ratings[i - <span class="number">1</span>] &amp;&amp; candies[i] &lt;= candies[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    candies[i] = candies[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> candy : candies) &#123;</span><br><span class="line">            sum += candy;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="法二"><a class="header-anchor" href="#法二">¶</a>法二</h2>
<p>  这是我自己能想到的最好解法，就是从左往右扫描并调整值，再从右往左扫描并调整值，最后取所有相应位置上左右数组的最大值的和。</p>
<ul>
<li>python解法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def candy(self, ratings: List[int]) -&gt; int:</span><br><span class="line">        L = len(ratings)</span><br><span class="line">        minl = [0] * L</span><br><span class="line">        minr = [0] * L        </span><br><span class="line">        sums = 0</span><br><span class="line">        for i in range(1, L):            </span><br><span class="line">            if ratings[i] &gt; ratings[i - 1]:</span><br><span class="line">                minl[i] = minl[i - 1] + 1</span><br><span class="line">        for i in range(L - 2, -1, -1):            </span><br><span class="line">            if ratings[i] &gt; ratings[i + 1]:</span><br><span class="line">                minr[i] = minr[i + 1] + 1</span><br><span class="line">        for k in range(0, L):</span><br><span class="line">            sums += max(minl[k], minr[k]) + 1</span><br><span class="line">        return sums</span><br></pre></td></tr></table></figure>
<ul>
<li>java解法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="keyword">int</span>[] ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] left2right = <span class="keyword">new</span> <span class="keyword">int</span>[ratings.length];</span><br><span class="line">        <span class="keyword">int</span>[] right2left = <span class="keyword">new</span> <span class="keyword">int</span>[ratings.length];</span><br><span class="line">        Arrays.fill(left2right, <span class="number">1</span>);</span><br><span class="line">        Arrays.fill(right2left, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ratings.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                left2right[i] = left2right[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = ratings.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                right2left[i] = right2left[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ratings.length; i++) &#123;</span><br><span class="line">            sum += Math.max(left2right[i], right2left[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="法三"><a class="header-anchor" href="#法三">¶</a>法三</h2>
<p>  法三在法二的基础上进行修改，从用两个数组变成只用一个数组。从左往右时，如果ratings[i] &gt; ratings[i - 1]， 更新candies[i] 为 candies[i - 1] + 1，此时candies[i]满足左边的大小关系；从右往左时，如果ratings[i] &gt; ratings[i + 1])，更新candies[i] 为 Math.max(candies[i], candies[i + 1] + 1)，使得candies[i]同时满足右边的大小关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="keyword">int</span>[] ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] candies = <span class="keyword">new</span> <span class="keyword">int</span>[ratings.length];</span><br><span class="line">        Arrays.fill(candies, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ratings.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                candies[i] = candies[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = candies[ratings.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = ratings.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                candies[i] = Math.max(candies[i], candies[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sum += candies[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="法四"><a class="header-anchor" href="#法四">¶</a>法四</h2>
<p>  这个解法是将ratings的递增递减对应candies上下坡记录每个上坡(1,2,3,…)，下坡(…3,2,1)的宽度然后比较大小决定山顶是属于上坡还是下坡(如1,2,3,4,5,3,2,1中5要属于更长的上坡才能满足同时比它旁边的3和4都大)，而山脚为了保证最少糖果取1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int count(int n) &#123;</span><br><span class="line">        <span class="keyword">return</span> (n * (n + <span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    public int candy(int[] ratings) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ratings.length;</span><br><span class="line">        &#125;</span><br><span class="line">        int candies = <span class="number">0</span>;</span><br><span class="line">        <span class="comment"># 该轮上坡高度</span></span><br><span class="line">        int up = <span class="number">0</span>;</span><br><span class="line">        <span class="comment"># 该轮下坡高度</span></span><br><span class="line">        int down = <span class="number">0</span>;</span><br><span class="line">        <span class="comment"># 上一次循环的斜率</span></span><br><span class="line">        int old_slope = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt; ratings.length; i++) &#123;</span><br><span class="line">            int new_slope = (ratings[i] &gt; ratings[i - 1]) ? 1 : (ratings[i] &lt; ratings[i - 1] ? -1 : 0);</span><br><span class="line">            <span class="comment"># 前后相等也看做山脚</span></span><br><span class="line">            <span class="comment"># 如果上一次是上升，下一次是相等则此时是山脚；如果上一次是下降，下一次是上升或者相等，则此时是山脚。</span></span><br><span class="line">            <span class="keyword">if</span> ((old_slope &gt; <span class="number">0</span> &amp;&amp; new_slope == <span class="number">0</span>) || (old_slope &lt; <span class="number">0</span> &amp;&amp; new_slope &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">                candies += count(up) + count(down) + Math.max(up, down);</span><br><span class="line">                up = <span class="number">0</span>;</span><br><span class="line">                down = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (new_slope &gt; <span class="number">0</span>)</span><br><span class="line">                up++;</span><br><span class="line">            <span class="keyword">if</span> (new_slope &lt; <span class="number">0</span>)</span><br><span class="line">                down++;</span><br><span class="line">            <span class="keyword">if</span> (new_slope == <span class="number">0</span>)</span><br><span class="line">                candies++;</span><br><span class="line">			<span class="comment"># 到这里candies算的是i之前的所有candy的总和，但是不包括山脚i</span></span><br><span class="line">            old_slope = new_slope;</span><br><span class="line">        &#125;</span><br><span class="line">        candies += count(up) + count(down) + Math.max(up, down) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> candies;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/21/leetcode-刷题日常-133-Clone-Graph/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/21/leetcode-刷题日常-133-Clone-Graph/" itemprop="url">133. Clone Graph</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-21T15:08:00+08:00">2019-06-21</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>题目描述</h1>
<p><a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="noopener">133. Clone Graph</a></p>
<p>Difficulty: <strong>Medium</strong></p>
<p>Given a reference of a node in a  undirected graph, return a (clone) of the graph. Each node in the graph contains a val (<code>int</code>) and a list (<code>List[Node]</code>) of its neighbors.</p>
<p><strong>Example:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2019/02/19/113_sample.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&#123;&quot;$id&quot;:&quot;1&quot;,&quot;neighbors&quot;:[&#123;&quot;$id&quot;:&quot;2&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;1&quot;&#125;,&#123;&quot;$id&quot;:&quot;3&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&#123;&quot;$id&quot;:&quot;4&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;3&quot;&#125;,&#123;&quot;$ref&quot;:&quot;1&quot;&#125;],&quot;val&quot;:4&#125;],&quot;val&quot;:3&#125;],&quot;val&quot;:2&#125;,&#123;&quot;$ref&quot;:&quot;4&quot;&#125;],&quot;val&quot;:1&#125;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Node 1&apos;s value is 1, and it has two neighbors: Node 2 and 4.</span><br><span class="line">Node 2&apos;s value is 2, and it has two neighbors: Node 1 and 3.</span><br><span class="line">Node 3&apos;s value is 3, and it has two neighbors: Node 2 and 4.</span><br><span class="line">Node 4&apos;s value is 4, and it has two neighbors: Node 1 and 3.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li>The number of nodes will be between 1 and 100.</li>
<li>The undirected graph is a , which means no repeated edges and no self-loops in the graph.</li>
<li>Since the graph is undirected, if node <em>p</em> has node <em>q</em> as neighbor, then node <em>q</em> must have node <em>p</em> as neighbor too.</li>
<li>You must return the <strong>copy of the given node</strong> as a reference to the cloned graph.</li>
</ol>
<h1>解法</h1>
<h2 id="法一："><a class="header-anchor" href="#法一：">¶</a>法一：</h2>
<p>DFS深度优先遍历，DFS返回新节点，DFS的过程中用dic记录新旧节点的对应关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line"># Definition for a Node.</span><br><span class="line">class Node:</span><br><span class="line">    def __init__(self, val, neighbors):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.neighbors = neighbors</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from collections import defaultdict</span><br><span class="line">class Solution:</span><br><span class="line">    def cloneGraph(self, node: &apos;Node&apos;) -&gt; &apos;Node&apos;:    </span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        nodelist = []</span><br><span class="line">        def DFS(N):</span><br><span class="line">            if N == None:</span><br><span class="line">                return None</span><br><span class="line">            if N in dic:</span><br><span class="line">                return dic[N]</span><br><span class="line">            new = Node(N.val, [])</span><br><span class="line">            dic[N] = new</span><br><span class="line">            for n in N.neighbors:</span><br><span class="line">                new.neighbors.append(DFS(n))</span><br><span class="line">            return new</span><br><span class="line">        return DFS(node)</span><br></pre></td></tr></table></figure>
<h2 id="法二："><a class="header-anchor" href="#法二：">¶</a>法二：</h2>
<p>BFS遍历，dic存放新旧节点的对应关系，每次节点入队之前都要克隆还没克隆过的节点，dic也可以当作节点访问标记数组使用，节点克隆过就代表节点访问过。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cloneGraph</span><span class="params">(self, node: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span>    </span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        q = deque([node])</span><br><span class="line">        dic[node] = Node(node.val, [])</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            n = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> neighbor <span class="keyword">in</span> n.neighbors:</span><br><span class="line">                <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                    q.append(neighbor)</span><br><span class="line">                    dic[neighbor] = Node(neighbor.val, [])</span><br><span class="line">                dic[n].neighbors.append(dic[neighbor])</span><br><span class="line">        <span class="keyword">return</span> dic[node]</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/21/leetcode-刷题日常-132-Palindrome-Partitioning-II/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/21/leetcode-刷题日常-132-Palindrome-Partitioning-II/" itemprop="url">132. Palindrome Partitioning II</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-21T12:17:00+08:00">2019-06-21</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>题目描述</h1>
<p><a href="https://leetcode.com/problems/palindrome-partitioning-ii/" target="_blank" rel="noopener">132. Palindrome Partitioning II</a></p>
<p>Difficulty: <strong>Hard</strong></p>
<p>Given a string <em>s</em>, partition <em>s</em> such that every substring of the partition is a palindrome.</p>
<p>Return the minimum cuts needed for a palindrome partitioning of <em>s</em>.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;aab&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The palindrome partitioning [&quot;aa&quot;,&quot;b&quot;] could be produced using 1 cut.</span><br></pre></td></tr></table></figure>
<h1>解法</h1>
<p>  此题涉及动态规划。</p>
<h2 id="法一-我自己的解法-效率较低"><a class="header-anchor" href="#法一-我自己的解法-效率较低">¶</a>法一（我自己的解法，效率较低）</h2>
<p>  dp[i] = 0 if s[:i+1][::-1] == s[:i+1] else $\min_{ 0 &lt; j &lt;= i\ and\ s[j:i+1][::-1] == s[j:i+1]}{dp[j - 1] + 1}$</p>
<p>  注：j是使j+1到i之间的字符串为回文串的下标位置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 900ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCut</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span>] * len(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[:i+<span class="number">1</span>] == s[:i+<span class="number">1</span>][::<span class="number">-1</span>]:</span><br><span class="line">                dp[i] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            dp[i] = len(s)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[j:i+<span class="number">1</span>][::<span class="number">-1</span>] == s[j:i+<span class="number">1</span>]:</span><br><span class="line">                    dp[i] = min(dp[i], dp[j - <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[len(s) - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>  这种思路还有一种更漂亮简洁的写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minCut</span><span class="params">(self, s)</span>:</span></span><br><span class="line">    cut = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">-1</span>,len(s))]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(s)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i,len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i:j] == s[j:i:<span class="number">-1</span>]:</span><br><span class="line">                cut[j+<span class="number">1</span>] = min(cut[j+<span class="number">1</span>],cut[i]+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> cut[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h1>法二</h1>
<p>  此解的几个关键点在于：</p>
<ul>
<li>i的遍历方向为从右到左，j的遍历方向为从左到右;</li>
<li>dp_cut数组代表的是切成几个回文串，而不是切几刀，所以最后返回结果之前要减1;</li>
<li>该解法的动态规划递推式是:<br>
$$dp_{i&lt;=j}[i][j] == 1\ if\ s[i] == s[j]\ and\ (i &lt;= j - 1\ or\ dp[i+1][j-1] == 1)\ else\ 0$$<br>
$$dp_cut[i] = \min_{i&lt;=j&lt;len(s)\ and\ dp[i][j] == 1 }{dp_cut[j+1]+1}$$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 400ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCut</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        L = len(s)</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(L)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(L)]</span><br><span class="line">        dp_cut = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(L + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(L - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>): <span class="comment"># i要反着遍历</span></span><br><span class="line">            dp_cut[i] = L</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, L):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j] <span class="keyword">and</span> (i &gt;= j - <span class="number">1</span> <span class="keyword">or</span> dp[i+<span class="number">1</span>][j<span class="number">-1</span>] == <span class="number">1</span>):</span><br><span class="line">                    dp[i][j] = <span class="number">1</span></span><br><span class="line">                    dp_cut[i] = min(dp_cut[i], dp_cut[j+<span class="number">1</span>]+<span class="number">1</span>)                    </span><br><span class="line">        <span class="keyword">return</span> dp_cut[<span class="number">0</span>] - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>  <strong>特例优化</strong>:</p>
<p>  因为动态规划方法在最少需要切一刀或者整个字符串是回文字符串的情况下效率很低,所以需要在开头就这些情况直接判断并返回，这样可以省去大量时间。同理，法一也可以通过在开头加上特判来加速。代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 88ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCut</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> s == s[::<span class="number">-1</span>]: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        L = len(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, L):</span><br><span class="line">            <span class="keyword">if</span> s[:i] == s[:i][::<span class="number">-1</span>] <span class="keyword">and</span> s[i:] == s[i:][::<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(L)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(L)]</span><br><span class="line">        dp_cut = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(L + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(L - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>): <span class="comment"># i要反着遍历</span></span><br><span class="line">            dp_cut[i] = L</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, L):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j] <span class="keyword">and</span> (i &gt;= j - <span class="number">1</span> <span class="keyword">or</span> dp[i+<span class="number">1</span>][j<span class="number">-1</span>] == <span class="number">1</span>):</span><br><span class="line">                    dp[i][j] = <span class="number">1</span></span><br><span class="line">                    dp_cut[i] = min(dp_cut[i], dp_cut[j+<span class="number">1</span>]+<span class="number">1</span>)                    </span><br><span class="line">        <span class="keyword">return</span> dp_cut[<span class="number">0</span>] - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="法三"><a class="header-anchor" href="#法三">¶</a>法三</h2>
<p>  这个解法是我看到的最优解，这种解法即使不用特例优化，也能达到200ms的运行时间，是其他解法都不能做到的。这种解法<strong>只比较回文串两端的s[i]和s[j]，而其他解法每一对s[i]和s[j]都要比较一次</strong>，因此要快很多。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 28ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCut</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># acceleration</span></span><br><span class="line">        <span class="keyword">if</span> s == s[::<span class="number">-1</span>]: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[:i] == s[:i][::<span class="number">-1</span>] <span class="keyword">and</span> s[i:] == s[i:][::<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="comment"># algorithm</span></span><br><span class="line">        cut = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">-1</span>,len(s))]  <span class="comment"># cut numbers in worst case (no palindrome)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            r1, r2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="comment"># use i as origin, and gradually enlarge radius if a palindrome exists</span></span><br><span class="line">            <span class="comment"># odd palindrome</span></span><br><span class="line">            <span class="keyword">while</span> i-r1 &gt;= <span class="number">0</span> <span class="keyword">and</span> i+r1 &lt; len(s) <span class="keyword">and</span> s[i-r1] == s[i+r1]:     </span><br><span class="line">                cut[i+r1+<span class="number">1</span>] = min(cut[i+r1+<span class="number">1</span>], cut[i-r1]+<span class="number">1</span>)</span><br><span class="line">                r1 += <span class="number">1</span></span><br><span class="line">            <span class="comment"># even palindrome</span></span><br><span class="line">            <span class="keyword">while</span> i-r2 &gt;= <span class="number">0</span> <span class="keyword">and</span> i+r2+<span class="number">1</span> &lt; len(s) <span class="keyword">and</span> s[i-r2] == s[i+r2+<span class="number">1</span>]:</span><br><span class="line">                cut[i+r2+<span class="number">2</span>] = min(cut[i+r2+<span class="number">2</span>], cut[i-r2]+<span class="number">1</span>)</span><br><span class="line">                r2 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cut[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h1>总结</h1>
<p>  其实单单针对这道题，针对官网给出的这些测试用例而言最大的优化在于判断特殊情况，加特判和没加特判的时间差很大，其次才是法四的优化。法一、法二和法三的中心思想都是一样的（如果用cut[i]记录s[0:i]所需最少刀数，则假如一个回文字符串是s[i:j]），那么cut[j]一定不大于cut[i + 1] + 1，只不过他们判断回文串的方式不同。法四不仅没有漏掉任何一个回文串而且空间复杂度比其他方法都低，实在是巧妙！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/20/leetcode-刷题日常-137-Single-Number-II/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/20/leetcode-刷题日常-137-Single-Number-II/" itemprop="url">137. Single Number II</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-20T22:58:00+08:00">2019-06-20</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>题目描述</h1>
<p><a href="https://leetcode.com/problems/single-number-ii/" target="_blank" rel="noopener">137. Single Number II</a></p>
<p>Difficulty: <strong>Medium</strong></p>
<p>Given a <strong>non-empty</strong> array of integers, every element appears <em>three</em> times except for one, which appears exactly once. Find that single one.</p>
<p><strong>Note:</strong></p>
<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,3,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0,1,0,1,99]</span><br><span class="line">Output: 99</span><br></pre></td></tr></table></figure>
<h1>分析</h1>
<p>  这道题让我眼前一亮，是之前没遇到过的位操作。中心思想就是统计每一位上1出现的次数，出现次数余3为1的那些位组成的数即恰好只出现一次的数。</p>
<ul>
<li>法一</li>
</ul>
<p>  one,two,three分别用来记录每一位上出现1的次数是几次，one，two，three三个整数的同一位上只允许有一个有1，因为要么出现1次，要么2次，要么3次，结果返回one；</p>
<ul>
<li>法二</li>
</ul>
<p>  用ab两个整数表示00,01,10三个状态，根据1的出现与否转换ab的值，转化顺序00-&gt;01-&gt;10-&gt;00，结果返回b。</p>
<h1>解法</h1>
<p>Language: <strong>Python3</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # 解法一</span><br><span class="line">    def singleNumber1(self, nums: List[int]) -&gt; int:</span><br><span class="line">        one, two, three = 0, 0, 0</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            two |= one &amp; nums[i]</span><br><span class="line">            one ^= nums[i]</span><br><span class="line">            three = one &amp; two</span><br><span class="line">            one &amp;= ~three</span><br><span class="line">            two &amp;= ~three</span><br><span class="line">        return one</span><br><span class="line">    # 解法二</span><br><span class="line">    def singleNumber2(self, nums: List[int]) -&gt; int:</span><br><span class="line">        res = 0</span><br><span class="line">        for i in range(32):</span><br><span class="line">            count = 0</span><br><span class="line">            for n in nums:</span><br><span class="line">                count += (n &gt;&gt; i) &amp; 1</span><br><span class="line">            res |= ((count % 3) &lt;&lt; i)</span><br><span class="line">        return res - 2**32 if res &gt;= 2**31 else res</span><br><span class="line">    # 解法三</span><br><span class="line">    def singleNumber3(self, nums: List[int]) -&gt; int:</span><br><span class="line">        return (3 * sum(set(nums)) - sum(nums))//2</span><br><span class="line">    # 解法四</span><br><span class="line">    def singleNumber(self, nums: List[int]) -&gt; int:</span><br><span class="line">        a, b =0, 0</span><br><span class="line">        for n in nums:</span><br><span class="line">            b = (b ^ n) &amp; ~a</span><br><span class="line">            a = (a ^ n) &amp; ~b</span><br><span class="line">        return b</span><br></pre></td></tr></table></figure>
<h1>扩展</h1>
<h2 id="扩展一："><a class="header-anchor" href="#扩展一：">¶</a>扩展一：</h2>
<p>  给定一个包含n个整数的数组，除了一个数出现二次外所有的整数均出现三次，找出这个只出现二次的整数。ones记录1出现一次的数，twos记录1出现2次的数，容易知道twos记录的即是最终结果。</p>
<h2 id="扩展二："><a class="header-anchor" href="#扩展二：">¶</a>扩展二：</h2>
<p>  给定一个包含n个整数的数组，有一个整数x出现b次，一个整数y出现c次，其他所有的数均出现a次，其中b和c均不是a的倍数，找出x和y。使用二进制模拟a进制，累计二进制位1出现的次数，当次数达到a时，对其清零，这样可以得到b mod a次x，c mod a次y的累加。遍历剩余结果（用ones、twos、fours…变量表示）中每一位二进制位1出现的次数，如果次数为b mod a 或者 c mod a，可以说明x和y的当前二进制位不同（一个为0，另一个为1），据此二进制位将原数组分成两组，一组该二进制位为1，另一组该二进制位为0。这样问题变成“除了一个整数出现a1次（a1 = b 或 a1 = c）外所有的整数均出现a次”，使用和上面相同的方式计算就可以得到最终结果，假设模拟a进制计算过程中使用的变量为ones、twos、fours…那么最终结果可以用ones | twos | fours …表示。</p>
<h1>参考</h1>
<p><a href="https://www.cnblogs.com/grandyang/p/4263927.html" target="_blank" rel="noopener">https://www.cnblogs.com/grandyang/p/4263927.html</a><br>
<a href="https://www.cnblogs.com/daijinqiao/p/3352893.html" target="_blank" rel="noopener">https://www.cnblogs.com/daijinqiao/p/3352893.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/20/leetcode-刷题日常-134-Gas-Station/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/20/leetcode-刷题日常-134-Gas-Station/" itemprop="url">134. Gas Station</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-20T22:05:00+08:00">2019-06-20</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>题目描述</h1>
<p><a href="https://leetcode.com/problems/gas-station/" target="_blank" rel="noopener">134. Gas Station</a></p>
<p>Difficulty: <strong>Medium</strong></p>
<p>There are <em>N</em> gas stations along a circular route, where the amount of gas at station <em>i</em> is <code>gas[i]</code>.</p>
<p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from station <em>i</em> to its next station (<em>i</em>+1). You begin the journey with an empty tank at one of the gas stations.</p>
<p>Return the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return -1.</p>
<p><strong>Note:</strong></p>
<ul>
<li>If there exists a solution, it is guaranteed to be unique.</li>
<li>Both input arrays are non-empty and have the same length.</li>
<li>Each element in the input arrays is a non-negative integer.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">gas  = [1,2,3,4,5]</span><br><span class="line">cost = [3,4,5,1,2]</span><br><span class="line"></span><br><span class="line">Output: 3</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4</span><br><span class="line">Travel to station 4\. Your tank = 4 - 1 + 5 = 8</span><br><span class="line">Travel to station 0\. Your tank = 8 - 2 + 1 = 7</span><br><span class="line">Travel to station 1\. Your tank = 7 - 3 + 2 = 6</span><br><span class="line">Travel to station 2\. Your tank = 6 - 4 + 3 = 5</span><br><span class="line">Travel to station 3\. The cost is 5\. Your gas is just enough to travel back to station 3.</span><br><span class="line">Therefore, return 3 as the starting index.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">gas  = [2,3,4]</span><br><span class="line">cost = [3,4,3]</span><br><span class="line"></span><br><span class="line">Output: -1</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">You can&apos;t start at station 0 or 1, as there is not enough gas to travel to the next station.</span><br><span class="line">Let&apos;s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4</span><br><span class="line">Travel to station 0\. Your tank = 4 - 3 + 2 = 3</span><br><span class="line">Travel to station 1\. Your tank = 3 - 3 + 3 = 3</span><br><span class="line">You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.</span><br><span class="line">Therefore, you can&apos;t travel around the circuit once no matter where you start.</span><br></pre></td></tr></table></figure>
<h1>分析</h1>
<p>  <strong>该题隐藏着一个可以证明的结论，即只要所有gas[i]-cos[i]的和大于0，那么就一定存在一个起点可以绕一圈。</strong></p>
<h4 id="解法一"><a class="header-anchor" href="#解法一">¶</a>解法一</h4>
<p>  从左往右扫描，将值加到sum，如果和小于0，那么就从小于0的那一点的下一个点开始重置sum为0继续加和，并更新起点start，直到遍历完整个数组。遍历数组的同时可以求所有gas-cost的和total，并根据total是否小于0来决定是返回start还是-1。（注意从上一个起点到上一个使sum小于0的那个点之间的所有点都不能作起点，所以要更新起点）</p>
<h4 id="解法二"><a class="header-anchor" href="#解法二">¶</a>解法二</h4>
<p>  从右往左扫描并累加和（累加和的意义是从当前点到最后一个点的剩油量），记录剩油量最大的那个点的下标为start。遍历数组的同时可以求所有gas-cost的和total，并根据total是否小于0来决定是返回start还是-1。</p>
<h1>代码</h1>
<p>Language: <strong>Python3</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line"># 解法一</span><br><span class="line">     def canCompleteCircuit1(self, gas: List[int], cost: List[int]) -&gt; int:</span><br><span class="line">         sums = 0</span><br><span class="line">         total = 0</span><br><span class="line">         start = 0</span><br><span class="line">         for i in range(len(gas)):</span><br><span class="line">             sums += gas[i] - cost[i]</span><br><span class="line">             total += gas[i] - cost[i]</span><br><span class="line">             if sums &lt; 0:</span><br><span class="line">                 sums = 0</span><br><span class="line">                 start = i + 1</span><br><span class="line">            </span><br><span class="line">         return start if total &gt;= 0 else -1</span><br><span class="line"></span><br><span class="line"># 解法二</span><br><span class="line">    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -&gt; int:</span><br><span class="line">        mx = -1</span><br><span class="line">        total = 0</span><br><span class="line">        start = 0</span><br><span class="line">        for i in range(len(gas) - 1, -1, -1):</span><br><span class="line">            total += gas[i] - cost[i]</span><br><span class="line">            if total &gt; mx:</span><br><span class="line">                mx = total</span><br><span class="line">                start = i</span><br><span class="line">            </span><br><span class="line">        return start if total &gt;= 0 else -1</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/20/C语言运算符/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/20/C语言运算符/" itemprop="url">C语言运算符</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-20T13:35:00+08:00">2019-06-20</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C语言/" itemprop="url" rel="index">
                    <span itemprop="name">C语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>优先级表格</h1>
<table border="1" cellspacing="0" cellpadding="0" width="612" style="color:rgb(0,0,0);font-family:Arial;font-size:14px;line-height:26px;text-align:left;"><tbody><tr><td>
<p align="center">
<strong>优先级</strong></p>
</td>
<td>
<p align="center">
<strong>运算符</strong></p>
</td>
<td>
<p align="center">
<strong>名称或含义</strong></p>
</td>
<td>
<p align="center">
<strong>使用形式</strong></p>
</td>
<td>
<p align="center">
<strong>结合方向</strong></p>
</td>
<td>
<p align="center">
<strong>说明</strong></p>
</td>
</tr><tr><td rowspan="4">
<p align="center">
<strong>1</strong></p>
</td>
<td>
<p align="center">
<strong><span style="color:#0000FF;">[]</span></strong></p>
</td>
<td>
<p>
数组下标</p>
</td>
<td>
<p>
数组名[常量表达式]</p>
</td>
<td rowspan="4">
<p align="center">
左到右</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">()</span></strong></p>
</td>
<td>
<p>
圆括号</p>
</td>
<td>
<p>
(表达式）/函数名(形参表)</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">.</span></strong></p>
</td>
<td>
<p>
成员选择（对象）</p>
</td>
<td>
<p>
对象.成员名</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">-&gt;</span></strong></p>
</td>
<td>
<p>
成员选择（指针）</p>
</td>
<td>
<p>
对象指针-&gt;成员名</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td width="612" colspan="6">
<p>
 </p>
</td>
</tr><tr><td rowspan="9">
<p align="center">
<strong>2</strong></p>
</td>
<td>
<p align="center">
<strong><span style="color:#0000FF;">-</span></strong></p>
</td>
<td>
<p>
负号运算符</p>
</td>
<td>
<p>
-表达式</p>
</td>
<td rowspan="9">
<p align="center">
<strong><span style="color:#FF0000;">右到左</span></strong></p>
</td>
<td rowspan="7">
<p align="center">
单目运算符</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">~</span></strong></p>
</td>
<td>
<p>
按位取反运算符</p>
</td>
<td>
<p>
~表达式</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">++</span></strong></p>
</td>
<td>
<p>
自增运算符</p>
</td>
<td>
<p>
++变量名/变量名++</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">--</span></strong></p>
</td>
<td>
<p>
自减运算符</p>
</td>
<td>
<p>
--变量名/变量名--</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">*</span></strong></p>
</td>
<td>
<p>
取值运算符</p>
</td>
<td>
<p>
*指针变量</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">&amp;</span></strong></p>
</td>
<td>
<p>
取地址运算符</p>
</td>
<td>
<p>
&amp;变量名</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">!</span></strong></p>
</td>
<td>
<p>
逻辑非运算符</p>
</td>
<td>
<p>
!表达式</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">(</span><span style="color:#0000FF;">类型</span><span style="color:#0000FF;">)</span></strong></p>
</td>
<td>
<p>
强制类型转换</p>
</td>
<td>
<p>
(数据类型)表达式</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">sizeof</span></strong></p>
</td>
<td>
<p>
长度运算符</p>
</td>
<td>
<p>
sizeof(表达式)</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td width="612" colspan="6">
<p>
 </p>
</td>
</tr><tr><td rowspan="3">
<p align="center">
<strong>3</strong></p>
</td>
<td>
<p align="center">
<strong><span style="color:#0000FF;">/</span></strong></p>
</td>
<td>
<p>
除</p>
</td>
<td>
<p>
表达式/表达式</p>
</td>
<td rowspan="3">
<p align="center">
左到右</p>
</td>
<td rowspan="3">
<p align="center">
双目运算符</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">*</span></strong></p>
</td>
<td>
<p>
乘</p>
</td>
<td>
<p>
表达式*表达式</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">%</span></strong></p>
</td>
<td>
<p>
余数（取模）</p>
</td>
<td>
<p>
整型表达式%整型表达式</p>
</td>
</tr><tr><td rowspan="2">
<p align="center">
<strong>4</strong></p>
</td>
<td>
<p align="center">
<strong><span style="color:#0000FF;">+</span></strong></p>
</td>
<td>
<p>
加</p>
</td>
<td>
<p>
表达式+表达式</p>
</td>
<td rowspan="2">
<p align="center">
左到右</p>
</td>
<td rowspan="2">
<p align="center">
双目运算符</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">-</span></strong></p>
</td>
<td>
<p>
减</p>
</td>
<td>
<p>
表达式-表达式</p>
</td>
</tr><tr><td rowspan="2">
<p align="center">
<strong>5</strong></p>
</td>
<td>
<p align="center">
<strong><span style="color:#0000FF;">&lt;&lt; </span></strong></p>
</td>
<td>
<p>
左移</p>
</td>
<td>
<p>
变量&lt;&lt;表达式</p>
</td>
<td rowspan="2">
<p align="center">
左到右</p>
</td>
<td rowspan="2">
<p align="center">
双目运算符</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">&gt;&gt; </span></strong></p>
</td>
<td>
<p>
右移</p>
</td>
<td>
<p>
变量&gt;&gt;表达式</p>
</td>
</tr><tr><td width="612" colspan="6">
<p>
 </p>
</td>
</tr><tr><td rowspan="4">
<p align="center">
<strong>6</strong></p>
</td>
<td>
<p align="center">
<strong><span style="color:#0000FF;">&gt; </span></strong></p>
</td>
<td>
<p>
大于</p>
</td>
<td>
<p>
表达式&gt;表达式</p>
</td>
<td rowspan="4">
<p align="center">
左到右</p>
</td>
<td rowspan="4">
<p align="center">
双目运算符</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">&gt;=</span></strong></p>
</td>
<td>
<p>
大于等于</p>
</td>
<td>
<p>
表达式&gt;=表达式</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">&lt; </span></strong></p>
</td>
<td>
<p>
小于</p>
</td>
<td>
<p>
表达式&lt;表达式</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">&lt;=</span></strong></p>
</td>
<td>
<p>
小于等于</p>
</td>
<td>
<p>
表达式&lt;=表达式</p>
</td>
</tr><tr><td rowspan="2">
<p align="center">
<strong>7</strong></p>
</td>
<td>
<p align="center">
<strong><span style="color:#0000FF;">==</span></strong></p>
</td>
<td>
<p>
等于</p>
</td>
<td>
<p>
表达式==表达式</p>
</td>
<td rowspan="2">
<p align="center">
左到右</p>
</td>
<td rowspan="2">
<p align="center">
双目运算符</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">！</span><span style="color:#0000FF;">=</span></strong></p>
</td>
<td>
<p>
不等于</p>
</td>
<td>
<p>
表达式!= 表达式</p>
</td>
</tr><tr><td width="612" colspan="6">
<p>
 </p>
</td>
</tr><tr><td>
<p align="center">
<strong>8</strong></p>
</td>
<td>
<p align="center">
<strong><span style="color:#0000FF;">&amp;</span></strong></p>
</td>
<td>
<p>
按位与</p>
</td>
<td>
<p>
表达式&amp;表达式</p>
</td>
<td>
<p align="center">
左到右</p>
</td>
<td>
<p align="center">
双目运算符</p>
</td>
</tr><tr><td>
<p align="center">
<strong>9</strong></p>
</td>
<td>
<p align="center">
<strong><span style="color:#0000FF;">^</span></strong></p>
</td>
<td>
<p>
按位异或</p>
</td>
<td>
<p>
表达式^表达式</p>
</td>
<td>
<p align="center">
左到右</p>
</td>
<td>
<p align="center">
双目运算符</p>
</td>
</tr><tr><td>
<p align="center">
<strong>10</strong></p>
</td>
<td>
<p align="center">
<strong><span style="color:#0000FF;">|</span></strong></p>
</td>
<td>
<p>
按位或</p>
</td>
<td>
<p>
表达式|表达式</p>
</td>
<td>
<p align="center">
左到右</p>
</td>
<td>
<p align="center">
双目运算符</p>
</td>
</tr><tr><td>
<p align="center">
<strong>11</strong></p>
</td>
<td>
<p align="center">
<strong><span style="color:#0000FF;">&amp;&amp;</span></strong></p>
</td>
<td>
<p>
逻辑与</p>
</td>
<td>
<p>
表达式&amp;&amp;表达式</p>
</td>
<td>
<p align="center">
左到右</p>
</td>
<td>
<p align="center">
双目运算符</p>
</td>
</tr><tr><td>
<p align="center">
<strong>12</strong></p>
</td>
<td>
<p align="center">
<strong><span style="color:#0000FF;">||</span></strong></p>
</td>
<td>
<p>
逻辑或</p>
</td>
<td>
<p>
表达式||表达式</p>
</td>
<td>
<p align="center">
左到右</p>
</td>
<td>
<p align="center">
双目运算符</p>
</td>
</tr><tr><td width="612" colspan="6">
<p>
 </p>
</td>
</tr><tr><td>
<p align="center">
<strong>13</strong></p>
</td>
<td>
<p align="center">
<strong><span style="color:#0000FF;">?:</span></strong></p>
</td>
<td>
<p>
条件运算符</p>
</td>
<td>
<p>
表达式1?</p>
<p>
表达式2: 表达式3</p>
</td>
<td>
<p align="center">
<strong><span style="color:#FF0000;">右到左</span></strong></p>
</td>
<td>
<p align="center">
<span style="color:#FF0000;">三目运算符</span></p>
</td>
</tr><tr><td width="612" colspan="6">
<p>
<span style="color:#FF0000;"> </span></p>
</td>
</tr><tr><td rowspan="11">
<p align="center">
<strong>14</strong></p>
</td>
<td>
<p align="center">
<strong><span style="color:#0000FF;">=</span></strong></p>
</td>
<td>
<p>
赋值运算符</p>
</td>
<td>
<p>
变量=表达式</p>
</td>
<td rowspan="11">
<p align="center">
<strong><span style="color:#FF0000;">右到左</span></strong></p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">/=</span></strong></p>
</td>
<td>
<p>
除后赋值</p>
</td>
<td>
<p>
变量/=表达式</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">*=</span></strong></p>
</td>
<td>
<p>
乘后赋值</p>
</td>
<td>
<p>
变量*=表达式</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">%=</span></strong></p>
</td>
<td>
<p>
取模后赋值</p>
</td>
<td>
<p>
变量%=表达式</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">+=</span></strong></p>
</td>
<td>
<p>
加后赋值</p>
</td>
<td>
<p>
变量+=表达式</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">-=</span></strong></p>
</td>
<td>
<p>
减后赋值</p>
</td>
<td>
<p>
变量-=表达式</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">&lt;&lt;=</span></strong></p>
</td>
<td>
<p>
左移后赋值</p>
</td>
<td>
<p>
变量&lt;&lt;=表达式</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">&gt;&gt;=</span></strong></p>
</td>
<td>
<p>
右移后赋值</p>
</td>
<td>
<p>
变量&gt;&gt;=表达式</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">&amp;=</span></strong></p>
</td>
<td>
<p>
按位与后赋值</p>
</td>
<td>
<p>
变量&amp;=表达式</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">^=</span></strong></p>
</td>
<td>
<p>
按位异或后赋值</p>
</td>
<td>
<p>
变量^=表达式</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td>
<p align="center">
<strong><span style="color:#0000FF;">|=</span></strong></p>
</td>
<td>
<p>
按位或后赋值</p>
</td>
<td>
<p>
变量|=表达式</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr><tr><td width="612" colspan="6">
<p>
 </p>
</td>
</tr><tr><td>
<p align="center">
<strong>15</strong></p>
</td>
<td>
<p align="center">
<strong><span style="color:#0000FF;">，</span></strong></p>
</td>
<td>
<p>
逗号运算符</p>
</td>
<td>
<p>
表达式,表达式,…</p>
</td>
<td>
<p align="center">
左到右</p>
</td>
<td>
<p align="center">
--</p>
</td>
</tr></tbody></table>
<h1>说明</h1>
<p>  运算符共分为15级，1级优先级最高，15级优先级最低。</p>
<p>  同一优先级的运算符，运算次序由结合方向所决定。(结合性：2 13 14 是从右至左 其他都是 从左至右)</p>
<p>  简单记就是：！ &gt; 算术运算符 &gt; 关系运算符 &gt; &amp;&amp; &gt; || &gt; 赋值运算符</p>
<h1>口诀</h1>
<p>括号成员第一;                //括号运算符<a href></a> 成员运算符. -&gt;</p>
<p>全体单目第二;              //所有的单目运算符比如++、 --、 +(正)、 -(负) 、指针运算*、&amp;</p>
<p>乘除余三,加减四;         //这个&quot;余&quot;是指取余运算即%</p>
<p>移位五，关系六;          //移位运算符：&lt;&lt; &gt;&gt; ，关系：&gt; &lt; &gt;= &lt;= 等</p>
<p>等于(与)不等排第七;      //即== 和!=</p>
<p>位与异或和位或;   &quot;三分天下&quot;八九十;     //这几个都是位运算: 位与(&amp;)异或(^)位或(|)</p>
<p>逻辑或跟与;              //逻辑运算符:|| 和 &amp;&amp;</p>
<p>十二和十一;           //注意顺序:优先级(||) 底于 优先级(&amp;&amp;)</p>
<p>条件高于赋值,                //三目运算符优先级排到13 位只比赋值运算符和&quot;,&quot;高</p>
<p>逗号运算级最低!        //逗号运算符优先级最低</p>
<h1>参考</h1>
<p><a href="https://blog.csdn.net/hitwhylz/article/details/14526569" target="_blank" rel="noopener">https://blog.csdn.net/hitwhylz/article/details/14526569</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/19/leetcode-刷题日常-130-Surrounded-Regions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/19/leetcode-刷题日常-130-Surrounded-Regions/" itemprop="url">130. Surrounded Regions</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-19T21:59:00+08:00">2019-06-19</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>题目描述</h1>
<p><a href="https://leetcode.com/problems/surrounded-regions/" target="_blank" rel="noopener">130. Surrounded Regions</a></p>
<p>Difficulty: <strong>Medium</strong></p>
<p>Given a 2D board containing <code>'X'</code> and <code>'O'</code> (<strong>the letter O</strong>), capture all regions surrounded by <code>'X'</code>.</p>
<p>A region is captured by flipping all <code>'O'</code>s into <code>'X'</code>s in that surrounded region.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>
<p>After running your function, the board should be:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>
<p><strong>Explanation:</strong></p>
<p>Surrounded regions shouldn’t be on the border, which means that any <code>'O'</code> on the border of the board are not flipped to <code>'X'</code>. Any <code>'O'</code> that is not on the border and it is not connected to an <code>'O'</code> on the border will be flipped to <code>'X'</code>. Two cells are connected if they are adjacent cells connected horizontally or vertically.</p>
<h1>解法</h1>
<p>Language: <strong>Python3</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def solve(self, board: List[List[str]]) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify board in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<h1>并查集解法</h1>
<p>  虽然可以用BFS，DFS做，但是既然可以用并查集了，那就借这道题初探并查集。代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        self.m = len(board)</span><br><span class="line">        self.n = len(board[<span class="number">0</span>])</span><br><span class="line">        self.length = self.m * self.n</span><br><span class="line"></span><br><span class="line">        self.id = [<span class="literal">None</span>] * self.length</span><br><span class="line">        self.size = [<span class="number">1</span>] * self.length</span><br><span class="line">        self.surrounded = [<span class="literal">True</span>] * self.length</span><br><span class="line"></span><br><span class="line">        [operator.setitem(self.id, *([self.genIndex(i, j)] * <span class="number">2</span>))</span><br><span class="line">         <span class="keyword">for</span> i, row <span class="keyword">in</span> enumerate(board)</span><br><span class="line">         <span class="keyword">for</span> j, val <span class="keyword">in</span> enumerate(row) <span class="keyword">if</span> val == <span class="string">'O'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">genIndex</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.n * i + j</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, p)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> p != self.id[p]:</span><br><span class="line">            self.id[p] = self.id[self.id[p]]</span><br><span class="line">            p = self.id[p]</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        idp, idq = map(self.find, (p, q))</span><br><span class="line">        <span class="keyword">if</span> idp == idq:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        less, more = (</span><br><span class="line">            (idp, idq) <span class="keyword">if</span> self.size[idp] &lt; self.size[idq] <span class="keyword">else</span> (idq, idp))</span><br><span class="line"></span><br><span class="line">        self.id[less] = self.id[more]</span><br><span class="line">        self.size[more] += self.size[less]</span><br><span class="line">        self.surrounded[more] = self.surrounded[less] <span class="keyword">and</span> self.surrounded[more]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        uf = UnionFind(board)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, row <span class="keyword">in</span> enumerate(board):</span><br><span class="line">            <span class="keyword">for</span> j, val <span class="keyword">in</span> enumerate(row):</span><br><span class="line">                <span class="keyword">if</span> val != <span class="string">'O'</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                index = uf.genIndex(i, j)</span><br><span class="line"></span><br><span class="line">                [uf.union(index, uf.genIndex(y, z))</span><br><span class="line">                 <span class="keyword">for</span> x, y, z <span class="keyword">in</span> ((i, i - <span class="number">1</span>, j), (j, i, j - <span class="number">1</span>))</span><br><span class="line">                 <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">and</span> board[y][z] == <span class="string">'O'</span>]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span> <span class="keyword">or</span> i == uf.m - <span class="number">1</span> <span class="keyword">or</span> j == uf.n - <span class="number">1</span>:</span><br><span class="line">                    uf.surrounded[uf.find(index)] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        [operator.setitem(board[i], j, <span class="string">'X'</span>)</span><br><span class="line">         <span class="keyword">for</span> i <span class="keyword">in</span> xrange(uf.m)</span><br><span class="line">         <span class="keyword">for</span> j <span class="keyword">in</span> xrange(uf.n)</span><br><span class="line">         <span class="keyword">if</span> board[i][j] == <span class="string">'O'</span> <span class="keyword">and</span> uf.surrounded[uf.find(uf.genIndex(i, j))]]</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/18/leetcode-刷题日常-126-Word-Ladder-II/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/18/leetcode-刷题日常-126-Word-Ladder-II/" itemprop="url">126. Word Ladder II</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-18T22:19:00+08:00">2019-06-18</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>题目描述</h1>
<p><a href="https://leetcode.com/problems/word-ladder-ii/" target="_blank" rel="noopener">126. Word Ladder II</a></p>
<p>Difficulty: <strong>Hard</strong></p>
<p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find all shortest transformation sequence(s) from <em>beginWord</em> to <em>endWord</em>, such that:</p>
<ol>
<li>Only one letter can be changed at a time</li>
<li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li>
</ol>
<p><strong>Note:</strong></p>
<ul>
<li>Return an empty list if there is no such transformation sequence.</li>
<li>All words have the same length.</li>
<li>All words contain only lowercase alphabetic characters.</li>
<li>You may assume no duplicates in the word list.</li>
<li>You may assume <em>beginWord</em> and <em>endWord</em> are non-empty and are not the same.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = &quot;hit&quot;,</span><br><span class="line">endWord = &quot;cog&quot;,</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = &quot;hit&quot;</span><br><span class="line">endWord = &quot;cog&quot;</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">Output: []</span><br><span class="line"></span><br><span class="line">Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no possible transformation.</span><br></pre></td></tr></table></figure>
<h1>分析</h1>
<p>不多说，直接给解法。</p>
<h2 id="bfs-dfs"><a class="header-anchor" href="#bfs-dfs">¶</a>BFS+DFS</h2>
<p>  上一题的BFS可以求出endWord到beginWord的最短距离，同时也求出了<strong>所有单词到beginWord的最短距离</strong>。该题想要找到到endWord的所有最短路径，那么每条最短路径上每个单词到beginWord都必须是最短路径，沿着最短路径到beginWord的距离也是<strong>最短距离</strong>，并且顺着最短路径由beginWord到每个单词结点的最短距离都是按顺序依次递增1的，这就限制了DFS的搜索顺序必须是按照BFS深度递增的顺序来搜索。BFS的同时可以记录每个单词对应的BFS序，那么DFS搜索的时候可以直接搜索序刚好比当前单词大1的单词。代码如下：</p>
<h3 id="300ms实现-我自己写的"><a class="header-anchor" href="#300ms实现-我自己写的">¶</a>300ms实现 我自己写的</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLadders</span><span class="params">(self, beginWord: str, endWord: str, wordList: List[str])</span> -&gt; List[List[str]]:</span></span><br><span class="line">        L = len(beginWord)</span><br><span class="line">        </span><br><span class="line">        all_combo_dict = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(L):</span><br><span class="line">                all_combo_dict[word[:i] + <span class="string">"*"</span> + word[i+<span class="number">1</span>:]].append(word)</span><br><span class="line">                </span><br><span class="line">        visited = &#123;beginWord:<span class="number">1</span>&#125;</span><br><span class="line">        mindistance = len(wordList) + <span class="number">1</span></span><br><span class="line">        q = Queue()</span><br><span class="line">        q.put((beginWord, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">            cur, level= q.get()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(L):</span><br><span class="line">                intermediate = cur[:i] + <span class="string">"*"</span> + cur[i+<span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">for</span> word <span class="keyword">in</span> all_combo_dict[intermediate]:</span><br><span class="line">                    <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        visited[word] = level + <span class="number">1</span></span><br><span class="line">                        q.put((word, level + <span class="number">1</span>))</span><br><span class="line">                        <span class="keyword">if</span> word == endWord:</span><br><span class="line">                            mindistance = level + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> mindistance == len(wordList) + <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">DFS</span><span class="params">(path)</span>:</span></span><br><span class="line">            beginWord = path[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> visited[beginWord] == mindistance: </span><br><span class="line">                <span class="keyword">if</span> beginWord == endWord:</span><br><span class="line">                    res.append(path)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(L):</span><br><span class="line">                intermediate = beginWord[:i] + <span class="string">"*"</span> + beginWord[i+<span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">for</span> word <span class="keyword">in</span> all_combo_dict[intermediate]:</span><br><span class="line">                    <span class="keyword">if</span> visited[word] == visited[beginWord] + <span class="number">1</span>:</span><br><span class="line">                        DFS(path + [word])                </span><br><span class="line">        res = []</span><br><span class="line">        DFS([beginWord])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="128ms实现"><a class="header-anchor" href="#128ms实现">¶</a>128ms实现</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLadders</span><span class="params">(self, beginWord: str, endWord: str, wordList: List[str])</span> -&gt; List[List[str]]:</span></span><br><span class="line">        start, end, dict = beginWord, endWord, set(wordList)</span><br><span class="line">        dict.update([start])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># build indexes</span></span><br><span class="line">        key_to_words = self.build_indexes(dict)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># bfs end to start search, calculate the distance to the end from each word</span></span><br><span class="line">        distance = self.bfs(end, start, key_to_words)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># dfs to search for all the shorted paths</span></span><br><span class="line">        results, path = [], [start]</span><br><span class="line">        self.dfs(start, end, key_to_words, distance, path, results)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> results</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 记录intermediate字典，比如dog对应的key是d*g,do*,*og</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_indexes</span><span class="params">(self, dict)</span>:</span></span><br><span class="line">        key_to_words = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> dict:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">                key = word[:i] + <span class="string">"%"</span> + word[i + <span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> key_to_words:</span><br><span class="line">                    key_to_words[key] = set([word])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    key_to_words[key].add(word)</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> key_to_words</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 从endWord开始搜索，搜索空间重心靠近endWord，这样可以避免一开始就搜索很多无效路径，命中率更高，此处需要注意！</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, end, start, key_to_words)</span>:</span></span><br><span class="line">        queue, distance = deque([end]), &#123;end : <span class="number">0</span>&#125;</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            word = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> word == start:</span><br><span class="line">                <span class="keyword">return</span> distance</span><br><span class="line">            <span class="keyword">for</span> next_word <span class="keyword">in</span> self.get_next_words(word, key_to_words):</span><br><span class="line">                <span class="keyword">if</span> next_word <span class="keyword">in</span> distance:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                queue.append(next_word)</span><br><span class="line">                distance[next_word] = distance[word] + <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> distance</span><br><span class="line">                </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_words</span><span class="params">(self, word, key_to_words)</span>:</span></span><br><span class="line">        next_words = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">            key = word[:i] + <span class="string">"%"</span> + word[i + <span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> key_to_words:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            next_words.extend(list(key_to_words[key]))</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> next_words</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, word, end, key_to_words, distance, path, results)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> word == end:</span><br><span class="line">            results.append(list(path))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> next_word <span class="keyword">in</span> self.get_next_words(word, key_to_words):</span><br><span class="line">            <span class="keyword">if</span> next_word <span class="keyword">not</span> <span class="keyword">in</span> distance:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> distance[next_word] != distance[word] - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            path.append(next_word)</span><br><span class="line">            self.dfs(next_word, end, key_to_words, distance, path, results)</span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure>
<h3 id="108ms-实现-单向bfs"><a class="header-anchor" href="#108ms-实现-单向bfs">¶</a>108ms 实现（单向BFS）</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLadders</span><span class="params">(self, beginWord: str, endWord: str, wordList: List[str])</span> -&gt; List[List[str]]:</span></span><br><span class="line">        neighbors = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(w)):</span><br><span class="line">                placeholder = w[:i] + <span class="string">'_'</span> + w[i+<span class="number">1</span>:]</span><br><span class="line">                neighbors[placeholder].append(w)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># bfs + build tree</span></span><br><span class="line">        tree = collections.defaultdict(set)//记录每个已访问结点，并且将后继结点加入字典值中</span><br><span class="line">        cur_layer = &#123;beginWord&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> cur_layer <span class="keyword">and</span> <span class="keyword">not</span> endWord <span class="keyword">in</span> cur_layer:</span><br><span class="line">            next_layer = collections.defaultdict(set)</span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> cur_layer:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">                    placeholder = word[:i] + <span class="string">'_'</span> + word[i+<span class="number">1</span>:]</span><br><span class="line">                    <span class="keyword">for</span> neigh <span class="keyword">in</span> neighbors[placeholder]:</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">not</span> neigh <span class="keyword">in</span> tree:</span><br><span class="line">                            next_layer[neigh].add(word)</span><br><span class="line">                            </span><br><span class="line">            tree.update(next_layer) <span class="comment"># 这条语句位置很重要，意味着结点可能被重复遍历</span></span><br><span class="line">            cur_layer = next_layer</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># dfs</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(source, dest)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> source == dest:</span><br><span class="line">                <span class="keyword">return</span> [[source]]</span><br><span class="line">            <span class="keyword">return</span> [pre_path + [dest] <span class="keyword">for</span> parent <span class="keyword">in</span> tree[dest] <span class="keyword">for</span> pre_path <span class="keyword">in</span> dfs(source, parent)]</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> dfs(beginWord, endWord)</span><br></pre></td></tr></table></figure>
<h2 id="双向搜索-parent-son字典回溯路径"><a class="header-anchor" href="#双向搜索-parent-son字典回溯路径">¶</a>双向搜索+parent/son字典回溯路径</h2>
<p>  这个是在submission里看到的一个64ms的解法，思路是从backward = {endWord}和forward = {beginWord}分别开始搜索，将所有相邻节点形成next_forward作为下一次搜索开始的forward集合，同时为了减慢搜索空间增加的速度，每次搜索都比较backward和forward的大小，小的那个集合重新当做forward，大的重新当做backward。在搜索的过程中，用parents字典记录每个节点的前驱节点，便于最后由endWord回溯路径。代码如下：</p>
<h3 id="双向bfs搜索-反向回溯"><a class="header-anchor" href="#双向bfs搜索-反向回溯">¶</a>双向BFS搜索，反向回溯</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLadders</span><span class="params">(self, beginWord, endWord, wordList)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type beginWord: str</span></span><br><span class="line"><span class="string">        :type endWord: str</span></span><br><span class="line"><span class="string">        :type wordList: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList <span class="keyword">or</span> <span class="keyword">not</span> endWord <span class="keyword">or</span> <span class="keyword">not</span> beginWord:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        wordList = set(wordList)</span><br><span class="line">        forward, backward = &#123;beginWord&#125;, &#123;endWord&#125;</span><br><span class="line">        direction = <span class="number">1</span></span><br><span class="line">        parents = defaultdict(set)</span><br><span class="line">        <span class="keyword">while</span> forward <span class="keyword">and</span> backward:</span><br><span class="line">            <span class="keyword">if</span> len(forward) &gt; len(backward):</span><br><span class="line">                forward, backward = backward, forward</span><br><span class="line">                <span class="comment"># We need to trace the direction in order to distinguish the parents</span></span><br><span class="line">                direction *= <span class="number">-1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># The new set of words which will be forward in the next iteration</span></span><br><span class="line">            next_foward = set()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Because all words in forward will be modified by one character</span></span><br><span class="line">            wordList -= forward</span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> forward:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">                    first, second = word[:i], word[i+<span class="number">1</span>:]</span><br><span class="line">                    <span class="keyword">for</span> ch <span class="keyword">in</span> string.ascii_lowercase:</span><br><span class="line">                        combined_word = first + ch + second</span><br><span class="line">                        <span class="keyword">if</span> combined_word <span class="keyword">in</span> wordList:</span><br><span class="line">                            next_foward.add(combined_word)</span><br><span class="line">                            <span class="comment"># Because at the last part, we find parents by indexing dictionary from endWord</span></span><br><span class="line">                            <span class="comment"># So when direction == 1, the combined_word is the key</span></span><br><span class="line">                            <span class="comment"># otherwise, the combined_word should be the value of dictionary.</span></span><br><span class="line">                            <span class="keyword">if</span> direction == <span class="number">1</span>:</span><br><span class="line">                                parents[combined_word].add(word)</span><br><span class="line">                            <span class="keyword">else</span>:</span><br><span class="line">                                parents[word].add(combined_word)</span><br><span class="line">                                </span><br><span class="line">            <span class="comment"># next_foward and backward are always in different direction,</span></span><br><span class="line">            <span class="comment"># so if they have common elements we find a path.</span></span><br><span class="line">            <span class="comment"># We check and return this function inside is because this problem finds the all shortest paths</span></span><br><span class="line">            <span class="keyword">if</span> next_foward &amp; backward:</span><br><span class="line">                <span class="comment"># Starting from the endWord, we find its parent and append to results</span></span><br><span class="line">                <span class="comment"># And do this until we reach the beginWord</span></span><br><span class="line">                results = [[endWord]]</span><br><span class="line">                <span class="keyword">while</span> results[<span class="number">0</span>][<span class="number">0</span>] != beginWord:</span><br><span class="line">                    results = [ [parent] + result <span class="keyword">for</span> result <span class="keyword">in</span> results <span class="keyword">for</span> parent <span class="keyword">in</span> parents[result[<span class="number">0</span>]] ]</span><br><span class="line">                <span class="keyword">return</span> results</span><br><span class="line">            forward = next_foward</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<h3 id="双向bfs搜索-正向回溯"><a class="header-anchor" href="#双向bfs搜索-正向回溯">¶</a>双向BFS搜索，正向回溯</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List <span class="comment"># 该模块作用即参数列表中冒号后面的部分，如wordList: List[str]，检查参数合法性</span></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLadders</span><span class="params">(self, beginWord: str, endWord: str, wordList: List[str])</span> -&gt; List[List[str]]:</span></span><br><span class="line"></span><br><span class="line">        tree, wordSet, n = collections.defaultdict(set), set(wordList), len(beginWord)</span><br><span class="line">        <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordSet:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        found, fq, bq, nq, isForward = <span class="literal">False</span>, &#123;beginWord&#125;, &#123;endWord&#125;, set(), <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> fq <span class="keyword">and</span> <span class="keyword">not</span> found:</span><br><span class="line">            wordSet -= fq</span><br><span class="line">            <span class="keyword">for</span> curWord <span class="keyword">in</span> fq:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(curWord)):</span><br><span class="line">                    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">'abcdefghijklmnopqrstuvwxyz'</span>:</span><br><span class="line">                        nextWord = curWord[:i] + c + curWord[i + <span class="number">1</span>:]</span><br><span class="line">                        <span class="keyword">if</span> nextWord <span class="keyword">in</span> wordSet:</span><br><span class="line">                            <span class="keyword">if</span> nextWord <span class="keyword">in</span> bq:</span><br><span class="line">                                found = <span class="literal">True</span></span><br><span class="line">                            <span class="keyword">else</span>:</span><br><span class="line">                                nq.add(nextWord)</span><br><span class="line">                            tree[curWord].add(nextWord) <span class="keyword">if</span> isForward <span class="keyword">else</span> tree[nextWord].add(curWord) <span class="comment"># 将后继结点加入当前结点的字典值</span></span><br><span class="line">            fq.clear()</span><br><span class="line">            fq, nq = nq, fq <span class="comment"># 此处很巧妙，将fq清空当做下一次的nq用，从而省去了重新分配和初始化nq的时间</span></span><br><span class="line">            <span class="keyword">if</span> len(fq) &gt; len(bq):</span><br><span class="line">                fq, bq, isForward = bq, fq, <span class="keyword">not</span> isForward</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bt</span><span class="params">(word)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> word == endWord:</span><br><span class="line">                <span class="keyword">return</span> [[word]]</span><br><span class="line"></span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">for</span> nextWord <span class="keyword">in</span> tree[word]:</span><br><span class="line">                results = bt(nextWord)</span><br><span class="line">                <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">                    result.insert(<span class="number">0</span>, word)</span><br><span class="line">                    res.append(result)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> bt(beginWord)</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">lidanyang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">50</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/lidanyang" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1261727840@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lidanyang</span>

  

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.0.0</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.0"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
