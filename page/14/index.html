<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.0" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="标签">
<meta property="og:url" content="http://yoursite.com/tags/index.html">
<meta property="og:site_name" content="Just a blog">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-05-28T06:22:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="标签">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/tags/">





  <title>Just a blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Just a blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/19/leetcode-刷题日常-130-Surrounded-Regions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/19/leetcode-刷题日常-130-Surrounded-Regions/" itemprop="url">130. Surrounded Regions</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-19T21:59:00+08:00">2019-06-19</time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-06-25T20:14:03+08:00">2019-06-25</time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>题目描述</h1>
<p><a href="https://leetcode.com/problems/surrounded-regions/" target="_blank" rel="noopener">130. Surrounded Regions</a></p>
<p>Difficulty: <strong>Medium</strong></p>
<p>Given a 2D board containing <code>'X'</code> and <code>'O'</code> (<strong>the letter O</strong>), capture all regions surrounded by <code>'X'</code>.</p>
<p>A region is captured by flipping all <code>'O'</code>s into <code>'X'</code>s in that surrounded region.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>
<p>After running your function, the board should be:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>
<p><strong>Explanation:</strong></p>
<p>Surrounded regions shouldn’t be on the border, which means that any <code>'O'</code> on the border of the board are not flipped to <code>'X'</code>. Any <code>'O'</code> that is not on the border and it is not connected to an <code>'O'</code> on the border will be flipped to <code>'X'</code>. Two cells are connected if they are adjacent cells connected horizontally or vertically.</p>
<h1>解法</h1>
<p>Language: <strong>Python3</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def solve(self, board: List[List[str]]) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify board in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<h1>并查集解法</h1>
<p>  虽然可以用BFS，DFS做，但是既然可以用并查集了，那就借这道题初探并查集。代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        self.m = len(board)</span><br><span class="line">        self.n = len(board[<span class="number">0</span>])</span><br><span class="line">        self.length = self.m * self.n</span><br><span class="line"></span><br><span class="line">        self.id = [<span class="literal">None</span>] * self.length</span><br><span class="line">        self.size = [<span class="number">1</span>] * self.length</span><br><span class="line">        self.surrounded = [<span class="literal">True</span>] * self.length</span><br><span class="line"></span><br><span class="line">        [operator.setitem(self.id, *([self.genIndex(i, j)] * <span class="number">2</span>))</span><br><span class="line">         <span class="keyword">for</span> i, row <span class="keyword">in</span> enumerate(board)</span><br><span class="line">         <span class="keyword">for</span> j, val <span class="keyword">in</span> enumerate(row) <span class="keyword">if</span> val == <span class="string">'O'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">genIndex</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.n * i + j</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, p)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> p != self.id[p]:</span><br><span class="line">            self.id[p] = self.id[self.id[p]]</span><br><span class="line">            p = self.id[p]</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        idp, idq = map(self.find, (p, q))</span><br><span class="line">        <span class="keyword">if</span> idp == idq:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        less, more = (</span><br><span class="line">            (idp, idq) <span class="keyword">if</span> self.size[idp] &lt; self.size[idq] <span class="keyword">else</span> (idq, idp))</span><br><span class="line"></span><br><span class="line">        self.id[less] = self.id[more]</span><br><span class="line">        self.size[more] += self.size[less]</span><br><span class="line">        self.surrounded[more] = self.surrounded[less] <span class="keyword">and</span> self.surrounded[more]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        uf = UnionFind(board)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, row <span class="keyword">in</span> enumerate(board):</span><br><span class="line">            <span class="keyword">for</span> j, val <span class="keyword">in</span> enumerate(row):</span><br><span class="line">                <span class="keyword">if</span> val != <span class="string">'O'</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                index = uf.genIndex(i, j)</span><br><span class="line"></span><br><span class="line">                [uf.union(index, uf.genIndex(y, z))</span><br><span class="line">                 <span class="keyword">for</span> x, y, z <span class="keyword">in</span> ((i, i - <span class="number">1</span>, j), (j, i, j - <span class="number">1</span>))</span><br><span class="line">                 <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">and</span> board[y][z] == <span class="string">'O'</span>]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span> <span class="keyword">or</span> i == uf.m - <span class="number">1</span> <span class="keyword">or</span> j == uf.n - <span class="number">1</span>:</span><br><span class="line">                    uf.surrounded[uf.find(index)] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        [operator.setitem(board[i], j, <span class="string">'X'</span>)</span><br><span class="line">         <span class="keyword">for</span> i <span class="keyword">in</span> xrange(uf.m)</span><br><span class="line">         <span class="keyword">for</span> j <span class="keyword">in</span> xrange(uf.n)</span><br><span class="line">         <span class="keyword">if</span> board[i][j] == <span class="string">'O'</span> <span class="keyword">and</span> uf.surrounded[uf.find(uf.genIndex(i, j))]]</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/18/leetcode-刷题日常-126-Word-Ladder-II/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/18/leetcode-刷题日常-126-Word-Ladder-II/" itemprop="url">126. Word Ladder II</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-18T22:19:00+08:00">2019-06-18</time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-06-25T20:14:20+08:00">2019-06-25</time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>题目描述</h1>
<p><a href="https://leetcode.com/problems/word-ladder-ii/" target="_blank" rel="noopener">126. Word Ladder II</a></p>
<p>Difficulty: <strong>Hard</strong></p>
<p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find all shortest transformation sequence(s) from <em>beginWord</em> to <em>endWord</em>, such that:</p>
<ol>
<li>Only one letter can be changed at a time</li>
<li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li>
</ol>
<p><strong>Note:</strong></p>
<ul>
<li>Return an empty list if there is no such transformation sequence.</li>
<li>All words have the same length.</li>
<li>All words contain only lowercase alphabetic characters.</li>
<li>You may assume no duplicates in the word list.</li>
<li>You may assume <em>beginWord</em> and <em>endWord</em> are non-empty and are not the same.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = &quot;hit&quot;,</span><br><span class="line">endWord = &quot;cog&quot;,</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = &quot;hit&quot;</span><br><span class="line">endWord = &quot;cog&quot;</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">Output: []</span><br><span class="line"></span><br><span class="line">Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no possible transformation.</span><br></pre></td></tr></table></figure>
<h1>分析</h1>
<p>不多说，直接给解法。</p>
<h2 id="bfs-dfs"><a class="header-anchor" href="#bfs-dfs">¶</a>BFS+DFS</h2>
<p>  上一题的BFS可以求出endWord到beginWord的最短距离，同时也求出了<strong>所有单词到beginWord的最短距离</strong>。该题想要找到到endWord的所有最短路径，那么每条最短路径上每个单词到beginWord都必须是最短路径，沿着最短路径到beginWord的距离也是<strong>最短距离</strong>，并且顺着最短路径由beginWord到每个单词结点的最短距离都是按顺序依次递增1的，这就限制了DFS的搜索顺序必须是按照BFS深度递增的顺序来搜索。BFS的同时可以记录每个单词对应的BFS序，那么DFS搜索的时候可以直接搜索序刚好比当前单词大1的单词。代码如下：</p>
<h3 id="300ms实现-我自己写的"><a class="header-anchor" href="#300ms实现-我自己写的">¶</a>300ms实现 我自己写的</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLadders</span><span class="params">(self, beginWord: str, endWord: str, wordList: List[str])</span> -&gt; List[List[str]]:</span></span><br><span class="line">        L = len(beginWord)</span><br><span class="line">        </span><br><span class="line">        all_combo_dict = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(L):</span><br><span class="line">                all_combo_dict[word[:i] + <span class="string">"*"</span> + word[i+<span class="number">1</span>:]].append(word)</span><br><span class="line">                </span><br><span class="line">        visited = &#123;beginWord:<span class="number">1</span>&#125;</span><br><span class="line">        mindistance = len(wordList) + <span class="number">1</span></span><br><span class="line">        q = Queue()</span><br><span class="line">        q.put((beginWord, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">            cur, level= q.get()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(L):</span><br><span class="line">                intermediate = cur[:i] + <span class="string">"*"</span> + cur[i+<span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">for</span> word <span class="keyword">in</span> all_combo_dict[intermediate]:</span><br><span class="line">                    <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        visited[word] = level + <span class="number">1</span></span><br><span class="line">                        q.put((word, level + <span class="number">1</span>))</span><br><span class="line">                        <span class="keyword">if</span> word == endWord:</span><br><span class="line">                            mindistance = level + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> mindistance == len(wordList) + <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">DFS</span><span class="params">(path)</span>:</span></span><br><span class="line">            beginWord = path[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> visited[beginWord] == mindistance: </span><br><span class="line">                <span class="keyword">if</span> beginWord == endWord:</span><br><span class="line">                    res.append(path)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(L):</span><br><span class="line">                intermediate = beginWord[:i] + <span class="string">"*"</span> + beginWord[i+<span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">for</span> word <span class="keyword">in</span> all_combo_dict[intermediate]:</span><br><span class="line">                    <span class="keyword">if</span> visited[word] == visited[beginWord] + <span class="number">1</span>:</span><br><span class="line">                        DFS(path + [word])                </span><br><span class="line">        res = []</span><br><span class="line">        DFS([beginWord])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="128ms实现"><a class="header-anchor" href="#128ms实现">¶</a>128ms实现</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLadders</span><span class="params">(self, beginWord: str, endWord: str, wordList: List[str])</span> -&gt; List[List[str]]:</span></span><br><span class="line">        start, end, dict = beginWord, endWord, set(wordList)</span><br><span class="line">        dict.update([start])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># build indexes</span></span><br><span class="line">        key_to_words = self.build_indexes(dict)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># bfs end to start search, calculate the distance to the end from each word</span></span><br><span class="line">        distance = self.bfs(end, start, key_to_words)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># dfs to search for all the shorted paths</span></span><br><span class="line">        results, path = [], [start]</span><br><span class="line">        self.dfs(start, end, key_to_words, distance, path, results)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> results</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 记录intermediate字典，比如dog对应的key是d*g,do*,*og</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_indexes</span><span class="params">(self, dict)</span>:</span></span><br><span class="line">        key_to_words = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> dict:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">                key = word[:i] + <span class="string">"%"</span> + word[i + <span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> key_to_words:</span><br><span class="line">                    key_to_words[key] = set([word])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    key_to_words[key].add(word)</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> key_to_words</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 从endWord开始搜索，搜索空间重心靠近endWord，这样可以避免一开始就搜索很多无效路径，命中率更高，此处需要注意！</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, end, start, key_to_words)</span>:</span></span><br><span class="line">        queue, distance = deque([end]), &#123;end : <span class="number">0</span>&#125;</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            word = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> word == start:</span><br><span class="line">                <span class="keyword">return</span> distance</span><br><span class="line">            <span class="keyword">for</span> next_word <span class="keyword">in</span> self.get_next_words(word, key_to_words):</span><br><span class="line">                <span class="keyword">if</span> next_word <span class="keyword">in</span> distance:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                queue.append(next_word)</span><br><span class="line">                distance[next_word] = distance[word] + <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> distance</span><br><span class="line">                </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_words</span><span class="params">(self, word, key_to_words)</span>:</span></span><br><span class="line">        next_words = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">            key = word[:i] + <span class="string">"%"</span> + word[i + <span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> key_to_words:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            next_words.extend(list(key_to_words[key]))</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> next_words</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, word, end, key_to_words, distance, path, results)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> word == end:</span><br><span class="line">            results.append(list(path))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> next_word <span class="keyword">in</span> self.get_next_words(word, key_to_words):</span><br><span class="line">            <span class="keyword">if</span> next_word <span class="keyword">not</span> <span class="keyword">in</span> distance:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> distance[next_word] != distance[word] - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            path.append(next_word)</span><br><span class="line">            self.dfs(next_word, end, key_to_words, distance, path, results)</span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure>
<h3 id="108ms-实现-单向bfs"><a class="header-anchor" href="#108ms-实现-单向bfs">¶</a>108ms 实现（单向BFS）</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLadders</span><span class="params">(self, beginWord: str, endWord: str, wordList: List[str])</span> -&gt; List[List[str]]:</span></span><br><span class="line">        neighbors = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(w)):</span><br><span class="line">                placeholder = w[:i] + <span class="string">'_'</span> + w[i+<span class="number">1</span>:]</span><br><span class="line">                neighbors[placeholder].append(w)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># bfs + build tree</span></span><br><span class="line">        tree = collections.defaultdict(set)//记录每个已访问结点，并且将后继结点加入字典值中</span><br><span class="line">        cur_layer = &#123;beginWord&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> cur_layer <span class="keyword">and</span> <span class="keyword">not</span> endWord <span class="keyword">in</span> cur_layer:</span><br><span class="line">            next_layer = collections.defaultdict(set)</span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> cur_layer:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">                    placeholder = word[:i] + <span class="string">'_'</span> + word[i+<span class="number">1</span>:]</span><br><span class="line">                    <span class="keyword">for</span> neigh <span class="keyword">in</span> neighbors[placeholder]:</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">not</span> neigh <span class="keyword">in</span> tree:</span><br><span class="line">                            next_layer[neigh].add(word)</span><br><span class="line">                            </span><br><span class="line">            tree.update(next_layer) <span class="comment"># 这条语句位置很重要，意味着结点可能被重复遍历</span></span><br><span class="line">            cur_layer = next_layer</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># dfs</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(source, dest)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> source == dest:</span><br><span class="line">                <span class="keyword">return</span> [[source]]</span><br><span class="line">            <span class="keyword">return</span> [pre_path + [dest] <span class="keyword">for</span> parent <span class="keyword">in</span> tree[dest] <span class="keyword">for</span> pre_path <span class="keyword">in</span> dfs(source, parent)]</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> dfs(beginWord, endWord)</span><br></pre></td></tr></table></figure>
<h2 id="双向搜索-parent-son字典回溯路径"><a class="header-anchor" href="#双向搜索-parent-son字典回溯路径">¶</a>双向搜索+parent/son字典回溯路径</h2>
<p>  这个是在submission里看到的一个64ms的解法，思路是从backward = {endWord}和forward = {beginWord}分别开始搜索，将所有相邻节点形成next_forward作为下一次搜索开始的forward集合，同时为了减慢搜索空间增加的速度，每次搜索都比较backward和forward的大小，小的那个集合重新当做forward，大的重新当做backward。在搜索的过程中，用parents字典记录每个节点的前驱节点，便于最后由endWord回溯路径。代码如下：</p>
<h3 id="双向bfs搜索-反向回溯"><a class="header-anchor" href="#双向bfs搜索-反向回溯">¶</a>双向BFS搜索，反向回溯</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLadders</span><span class="params">(self, beginWord, endWord, wordList)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type beginWord: str</span></span><br><span class="line"><span class="string">        :type endWord: str</span></span><br><span class="line"><span class="string">        :type wordList: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList <span class="keyword">or</span> <span class="keyword">not</span> endWord <span class="keyword">or</span> <span class="keyword">not</span> beginWord:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        wordList = set(wordList)</span><br><span class="line">        forward, backward = &#123;beginWord&#125;, &#123;endWord&#125;</span><br><span class="line">        direction = <span class="number">1</span></span><br><span class="line">        parents = defaultdict(set)</span><br><span class="line">        <span class="keyword">while</span> forward <span class="keyword">and</span> backward:</span><br><span class="line">            <span class="keyword">if</span> len(forward) &gt; len(backward):</span><br><span class="line">                forward, backward = backward, forward</span><br><span class="line">                <span class="comment"># We need to trace the direction in order to distinguish the parents</span></span><br><span class="line">                direction *= <span class="number">-1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># The new set of words which will be forward in the next iteration</span></span><br><span class="line">            next_foward = set()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Because all words in forward will be modified by one character</span></span><br><span class="line">            wordList -= forward</span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> forward:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">                    first, second = word[:i], word[i+<span class="number">1</span>:]</span><br><span class="line">                    <span class="keyword">for</span> ch <span class="keyword">in</span> string.ascii_lowercase:</span><br><span class="line">                        combined_word = first + ch + second</span><br><span class="line">                        <span class="keyword">if</span> combined_word <span class="keyword">in</span> wordList:</span><br><span class="line">                            next_foward.add(combined_word)</span><br><span class="line">                            <span class="comment"># Because at the last part, we find parents by indexing dictionary from endWord</span></span><br><span class="line">                            <span class="comment"># So when direction == 1, the combined_word is the key</span></span><br><span class="line">                            <span class="comment"># otherwise, the combined_word should be the value of dictionary.</span></span><br><span class="line">                            <span class="keyword">if</span> direction == <span class="number">1</span>:</span><br><span class="line">                                parents[combined_word].add(word)</span><br><span class="line">                            <span class="keyword">else</span>:</span><br><span class="line">                                parents[word].add(combined_word)</span><br><span class="line">                                </span><br><span class="line">            <span class="comment"># next_foward and backward are always in different direction,</span></span><br><span class="line">            <span class="comment"># so if they have common elements we find a path.</span></span><br><span class="line">            <span class="comment"># We check and return this function inside is because this problem finds the all shortest paths</span></span><br><span class="line">            <span class="keyword">if</span> next_foward &amp; backward:</span><br><span class="line">                <span class="comment"># Starting from the endWord, we find its parent and append to results</span></span><br><span class="line">                <span class="comment"># And do this until we reach the beginWord</span></span><br><span class="line">                results = [[endWord]]</span><br><span class="line">                <span class="keyword">while</span> results[<span class="number">0</span>][<span class="number">0</span>] != beginWord:</span><br><span class="line">                    results = [ [parent] + result <span class="keyword">for</span> result <span class="keyword">in</span> results <span class="keyword">for</span> parent <span class="keyword">in</span> parents[result[<span class="number">0</span>]] ]</span><br><span class="line">                <span class="keyword">return</span> results</span><br><span class="line">            forward = next_foward</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<h3 id="双向bfs搜索-正向回溯"><a class="header-anchor" href="#双向bfs搜索-正向回溯">¶</a>双向BFS搜索，正向回溯</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List <span class="comment"># 该模块作用即参数列表中冒号后面的部分，如wordList: List[str]，检查参数合法性</span></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLadders</span><span class="params">(self, beginWord: str, endWord: str, wordList: List[str])</span> -&gt; List[List[str]]:</span></span><br><span class="line"></span><br><span class="line">        tree, wordSet, n = collections.defaultdict(set), set(wordList), len(beginWord)</span><br><span class="line">        <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordSet:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        found, fq, bq, nq, isForward = <span class="literal">False</span>, &#123;beginWord&#125;, &#123;endWord&#125;, set(), <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> fq <span class="keyword">and</span> <span class="keyword">not</span> found:</span><br><span class="line">            wordSet -= fq</span><br><span class="line">            <span class="keyword">for</span> curWord <span class="keyword">in</span> fq:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(curWord)):</span><br><span class="line">                    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">'abcdefghijklmnopqrstuvwxyz'</span>:</span><br><span class="line">                        nextWord = curWord[:i] + c + curWord[i + <span class="number">1</span>:]</span><br><span class="line">                        <span class="keyword">if</span> nextWord <span class="keyword">in</span> wordSet:</span><br><span class="line">                            <span class="keyword">if</span> nextWord <span class="keyword">in</span> bq:</span><br><span class="line">                                found = <span class="literal">True</span></span><br><span class="line">                            <span class="keyword">else</span>:</span><br><span class="line">                                nq.add(nextWord)</span><br><span class="line">                            tree[curWord].add(nextWord) <span class="keyword">if</span> isForward <span class="keyword">else</span> tree[nextWord].add(curWord) <span class="comment"># 将后继结点加入当前结点的字典值</span></span><br><span class="line">            fq.clear()</span><br><span class="line">            fq, nq = nq, fq <span class="comment"># 此处很巧妙，将fq清空当做下一次的nq用，从而省去了重新分配和初始化nq的时间</span></span><br><span class="line">            <span class="keyword">if</span> len(fq) &gt; len(bq):</span><br><span class="line">                fq, bq, isForward = bq, fq, <span class="keyword">not</span> isForward</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bt</span><span class="params">(word)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> word == endWord:</span><br><span class="line">                <span class="keyword">return</span> [[word]]</span><br><span class="line"></span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">for</span> nextWord <span class="keyword">in</span> tree[word]:</span><br><span class="line">                results = bt(nextWord)</span><br><span class="line">                <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">                    result.insert(<span class="number">0</span>, word)</span><br><span class="line">                    res.append(result)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> bt(beginWord)</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/18/leetcode-刷题日常-127-Word-Ladder/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/18/leetcode-刷题日常-127-Word-Ladder/" itemprop="url">127. Word Ladder</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-18T11:38:00+08:00">2019-06-18</time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-06-25T20:15:05+08:00">2019-06-25</time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>题目描述</h1>
<p><a href="https://leetcode.com/problems/word-ladder/" target="_blank" rel="noopener">127. Word Ladder</a></p>
<p>Difficulty: <strong>Medium</strong></p>
<p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:</p>
<ol>
<li>Only one letter can be changed at a time.</li>
<li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li>
</ol>
<p><strong>Note:</strong></p>
<ul>
<li>Return 0 if there is no such transformation sequence.</li>
<li>All words have the same length.</li>
<li>All words contain only lowercase alphabetic characters.</li>
<li>You may assume no duplicates in the word list.</li>
<li>You may assume <em>beginWord</em> and <em>endWord</em> are non-empty and are not the same.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = &quot;hit&quot;,</span><br><span class="line">endWord = &quot;cog&quot;,</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">Output: 5</span><br><span class="line"></span><br><span class="line">Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,</span><br><span class="line">return its length 5.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = &quot;hit&quot;</span><br><span class="line">endWord = &quot;cog&quot;</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no possible transformation.</span><br></pre></td></tr></table></figure>
<h1>分析</h1>
<p>  如果将每个单词看成图中的一个结点，将只差一个字母的两个单词看成两个相邻接的结点，则问题可转化为用宽度优先搜索求图中两点最短路径的问题。如下图：<br>
<img src="https://leetcode.com/problems/word-ladder/Figures/127/Word_Ladder_1.png" alt="avatar"></p>
<p>  为了找到每个结点的邻接节点，可以将每个单词中每个字母依次分别替换成*，然后以替换后的单词为key，原单词为value建立一个dict，比如dog就对应d*g,*og,do*三个key。单词dog的所有邻接单词都在dict[d*g],dict[*og],dict[do*]这三个列表中，记得还要用visited数组标志单词有没有被遍历过，防止死循环爆栈。代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span><span class="params">(self, beginWord, endWord, wordList)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type beginWord: str</span></span><br><span class="line"><span class="string">        :type endWord: str</span></span><br><span class="line"><span class="string">        :type wordList: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList <span class="keyword">or</span> <span class="keyword">not</span> endWord <span class="keyword">or</span> <span class="keyword">not</span> beginWord <span class="keyword">or</span> <span class="keyword">not</span> wordList:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Since all words are of same length.</span></span><br><span class="line">        L = len(beginWord)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Dictionary to hold combination of words that can be formed,</span></span><br><span class="line">        <span class="comment"># from any given word. By changing one letter at a time.</span></span><br><span class="line">        all_combo_dict = defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(L):</span><br><span class="line">                <span class="comment"># Key is the generic word</span></span><br><span class="line">                <span class="comment"># Value is a list of words which have the same intermediate generic word.</span></span><br><span class="line">                all_combo_dict[word[:i] + <span class="string">"*"</span> + word[i+<span class="number">1</span>:]].append(word)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Queue for BFS</span></span><br><span class="line">        queue = [(beginWord, <span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># Visited to make sure we don't repeat processing same word.</span></span><br><span class="line">        visited = &#123;beginWord: <span class="literal">True</span>&#125;</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            current_word, level = queue.pop(<span class="number">0</span>)      </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(L):</span><br><span class="line">                <span class="comment"># Intermediate words for current word</span></span><br><span class="line">                intermediate_word = current_word[:i] + <span class="string">"*"</span> + current_word[i+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Next states are all the words which share the same intermediate state.</span></span><br><span class="line">                <span class="keyword">for</span> word <span class="keyword">in</span> all_combo_dict[intermediate_word]:</span><br><span class="line">                    <span class="comment"># If at any point if we find what we are looking for</span></span><br><span class="line">                    <span class="comment"># i.e. the end word - we can return with the answer.</span></span><br><span class="line">                    <span class="keyword">if</span> word == endWord:</span><br><span class="line">                        <span class="keyword">return</span> level + <span class="number">1</span></span><br><span class="line">                    <span class="comment"># Otherwise, add it to the BFS Queue. Also mark it visited</span></span><br><span class="line">                    <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        visited[word] = <span class="literal">True</span></span><br><span class="line">                        queue.append((word, level + <span class="number">1</span>))</span><br><span class="line">                all_combo_dict[intermediate_word] = []</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>  上述解法可以通过用双向BFS缩小一半搜索空间来进行优化，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.length = <span class="number">0</span></span><br><span class="line">        <span class="comment"># Dictionary to hold combination of words that can be formed,</span></span><br><span class="line">        <span class="comment"># from any given word. By changing one letter at a time.</span></span><br><span class="line">        self.all_combo_dict = defaultdict(list)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visitWordNode</span><span class="params">(self, queue, visited, others_visited)</span>:</span></span><br><span class="line">        current_word, level = queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.length):</span><br><span class="line">            <span class="comment"># Intermediate words for current word</span></span><br><span class="line">            intermediate_word = current_word[:i] + <span class="string">"*"</span> + current_word[i+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Next states are all the words which share the same intermediate state.</span></span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> self.all_combo_dict[intermediate_word]:</span><br><span class="line">                <span class="comment"># If the intermediate state/word has already been visited from the</span></span><br><span class="line">                <span class="comment"># other parallel traversal this means we have found the answer.</span></span><br><span class="line">                <span class="keyword">if</span> word <span class="keyword">in</span> others_visited:</span><br><span class="line">                    <span class="keyword">return</span> level + others_visited[word]</span><br><span class="line">                <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    <span class="comment"># Save the level as the value of the dictionary, to save number of hops.</span></span><br><span class="line">                    visited[word] = level + <span class="number">1</span></span><br><span class="line">                    queue.append((word, level + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span><span class="params">(self, beginWord, endWord, wordList)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type beginWord: str</span></span><br><span class="line"><span class="string">        :type endWord: str</span></span><br><span class="line"><span class="string">        :type wordList: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList <span class="keyword">or</span> <span class="keyword">not</span> endWord <span class="keyword">or</span> <span class="keyword">not</span> beginWord <span class="keyword">or</span> <span class="keyword">not</span> wordList:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Since all words are of same length.</span></span><br><span class="line">        self.length = len(beginWord)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(self.length):</span><br><span class="line">                <span class="comment"># Key is the generic word</span></span><br><span class="line">                <span class="comment"># Value is a list of words which have the same intermediate generic word.</span></span><br><span class="line">                self.all_combo_dict[word[:i] + <span class="string">"*"</span> + word[i+<span class="number">1</span>:]].append(word)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Queues for birdirectional BFS</span></span><br><span class="line">        queue_begin = [(beginWord, <span class="number">1</span>)] <span class="comment"># BFS starting from beginWord</span></span><br><span class="line">        queue_end = [(endWord, <span class="number">1</span>)] <span class="comment"># BFS starting from endWord</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Visited to make sure we don't repeat processing same word</span></span><br><span class="line">        visited_begin = &#123;beginWord: <span class="number">1</span>&#125;</span><br><span class="line">        visited_end = &#123;endWord: <span class="number">1</span>&#125;</span><br><span class="line">        ans = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># We do a birdirectional search starting one pointer from begin</span></span><br><span class="line">        <span class="comment"># word and one pointer from end word. Hopping one by one.</span></span><br><span class="line">        <span class="keyword">while</span> queue_begin <span class="keyword">and</span> queue_end:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># One hop from begin word</span></span><br><span class="line">            ans = self.visitWordNode(queue_begin, visited_begin, visited_end)</span><br><span class="line">            <span class="keyword">if</span> ans:</span><br><span class="line">                <span class="keyword">return</span> ans</span><br><span class="line">            <span class="comment"># One hop from end word</span></span><br><span class="line">            ans = self.visitWordNode(queue_end, visited_end, visited_begin)</span><br><span class="line">            <span class="keyword">if</span> ans:</span><br><span class="line">                <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1>扩展：C语言实现</h1>
<ol>
<li>Hash桶查找字符串 + 基于链表的队列</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) \</span></span><br><span class="line">    ((type *)((<span class="keyword">char</span> *)(ptr) - (<span class="keyword">size_t</span>)&amp;(((type *)<span class="number">0</span>)-&gt;member)))</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line">    container_of(ptr, type, member)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_first_entry(ptr, type, field) list_entry((ptr)-&gt;next, type, field)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_last_entry(ptr, type, field) list_entry((ptr)-&gt;prev, type, field)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each(p, head) \</span></span><br><span class="line">    <span class="keyword">for</span> (p = (head)-&gt;next; p != (head); p = p-&gt;next)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//删除元素时用这个，防止删除pos后，pos-&gt;next指向undefined state</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_safe(p, n, head) \</span></span><br><span class="line">    <span class="keyword">for</span> (p = (head)-&gt;next, n = p-&gt;next; p != (head); p = n, n = p-&gt;next)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hlist_for_each(pos, head) \</span></span><br><span class="line">    <span class="keyword">for</span> (pos = (head)-&gt;first; pos; pos = pos-&gt;next)</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除元素时用这个，防止删除pos后，pos-&gt;next指向undefined state</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hlist_for_each_safe(pos, n, head) \</span></span><br><span class="line">    <span class="keyword">for</span> (pos = (head)-&gt;first; pos &amp;&amp; (&#123; n = pos-&gt;next; <span class="literal">true</span>; &#125;); pos = n)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">first</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">next</span>, **<span class="title">pprev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">INIT_HLIST_HEAD</span><span class="params">(struct hlist_head *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    h-&gt;first = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hlist_add_head</span><span class="params">(struct hlist_node *n, struct hlist_head *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h-&gt;first != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        h-&gt;first-&gt;pprev = &amp;n-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    n-&gt;next = h-&gt;first;</span><br><span class="line">    n-&gt;pprev = &amp;h-&gt;first;</span><br><span class="line">    h-&gt;first = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">INIT_LIST_HEAD</span><span class="params">(struct list_head *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>-&gt;next = <span class="built_in">list</span>-&gt;prev = <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">list_empty</span><span class="params">(<span class="keyword">const</span> struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (head-&gt;next == head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __list_add(struct list_head *<span class="keyword">new</span>, struct list_head *prev, struct list_head *next)</span><br><span class="line">&#123;</span><br><span class="line">    next-&gt;prev = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = next;</span><br><span class="line">    <span class="keyword">new</span>-&gt;prev = prev;</span><br><span class="line">    prev-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">list_add</span><span class="params">(struct list_head *_new, struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __list_add(_new, head, head-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">list_add_tail</span><span class="params">(struct list_head *_new, struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __list_add(_new, head-&gt;prev, head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __list_del(struct list_head *entry)</span><br><span class="line">&#123;</span><br><span class="line">    entry-&gt;next-&gt;prev = entry-&gt;prev;</span><br><span class="line">    entry-&gt;prev-&gt;next = entry-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">list_del</span><span class="params">(struct list_head *entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __list_del(entry);</span><br><span class="line">    entry-&gt;next = entry-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">word_node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line">    <span class="keyword">char</span> *word;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">link</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取字符串的Hash值，size为word_list_size，每个单词对应一个桶</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BKDRHash</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> seed = <span class="number">131</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*str != <span class="string">'\0'</span>) &#123;</span><br><span class="line">        hash = hash * seed + (*str++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash % size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hlist查找函数，用来根据字符串的值快速查找某个word_node结点</span></span><br><span class="line"><span class="function">struct word_node *<span class="title">find</span><span class="params">(<span class="keyword">char</span> *word, struct hlist_head *hhead, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">int</span> hash = BKDRHash(word, size);</span><br><span class="line">    hlist_for_each(p, &amp;hhead[hash]) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">word_node</span> *<span class="title">node</span> = <span class="title">list_entry</span>(<span class="title">p</span>, <span class="title">struct</span> <span class="title">word_node</span>, <span class="title">node</span>);</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;step == <span class="number">0</span> &amp;&amp; !<span class="built_in">strcmp</span>(node-&gt;word, word)) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;<span class="comment">//node-&gt;step为0代表还未遍历到这个结点，node-&gt;step == 0这个判断很关键，防止死循环，比如hit-&gt;hot-&gt;hit-&gt;hot-&gt;......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="keyword">char</span>* begin_word, <span class="keyword">char</span>* end_word, <span class="keyword">char</span>** word_list, <span class="keyword">int</span> word_list_size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, len = <span class="built_in">strlen</span>(begin_word);</span><br><span class="line">    <span class="keyword">char</span> *word = <span class="built_in">malloc</span>(len + <span class="number">1</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">queue</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">word_node</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内核hash链表hlist和链表list的用法都是先malloc头结点或者定义头结点变量，然后init头结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> *<span class="title">hhead</span> = <span class="title">malloc</span>(<span class="title">word_list_size</span> * <span class="title">sizeof</span>(*<span class="title">hhead</span>));</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; word_list_size; i++) &#123;</span><br><span class="line">        INIT_HLIST_HEAD(hhead + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; word_list_size; i++) &#123;</span><br><span class="line">        node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*node));</span><br><span class="line">        node-&gt;word = word_list[i];</span><br><span class="line">        node-&gt;step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hash = BKDRHash(word_list[i], word_list_size);</span><br><span class="line">        hlist_add_head(&amp;node-&gt;node, &amp;hhead[hash]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    INIT_LIST_HEAD(&amp;<span class="built_in">queue</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">word_node</span> *<span class="title">first</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(*<span class="title">node</span>));</span></span><br><span class="line">    first-&gt;word = begin_word;</span><br><span class="line">    first-&gt;step = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">strcmp</span>(first-&gt;word, end_word)) &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(word, first-&gt;word);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c;</span><br><span class="line">            <span class="keyword">char</span> o = word[i];</span><br><span class="line">            <span class="keyword">for</span> (c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == o) <span class="keyword">continue</span>;</span><br><span class="line">                word[i] = c;</span><br><span class="line">                node = find(word, hhead, word_list_size);</span><br><span class="line">                <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    list_add_tail(&amp;node-&gt;link, &amp;<span class="built_in">queue</span>);<span class="comment">//入队</span></span><br><span class="line">                    node-&gt;step = first-&gt;step + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            word[i] = o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (list_empty(&amp;<span class="built_in">queue</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            first = list_first_entry(&amp;<span class="built_in">queue</span>, struct word_node, link);</span><br><span class="line">            list_del(&amp;first-&gt;link);<span class="comment">//出队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> first-&gt;step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>字典树查找字符串 + 基于链表的队列</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TriNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TriNode</span>** <span class="title">link</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> isword;<span class="comment">//标记单词是否属于字典树</span></span><br><span class="line">&#125;;<span class="comment">//字典树结点</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>* item;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>* <span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;<span class="comment">//链队列结点</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">head</span>, *<span class="title">tail</span>;</span></span><br><span class="line"><span class="function">struct QNode* <span class="title">qinit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qput</span><span class="params">(struct QNode*, <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">qget</span><span class="params">(struct QNode *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">qempty</span><span class="params">(struct QNode*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">struct TriNode* <span class="title">createTri</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">struct TriNode* <span class="title">buildDict</span><span class="params">(<span class="keyword">char</span>**, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchDict</span><span class="params">(struct TriNode *, <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="keyword">char</span> * beginWord, <span class="keyword">char</span> * endWord, <span class="keyword">char</span> ** wordList, <span class="keyword">int</span> wordListSize)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TriNode</span>* <span class="title">root</span>=<span class="title">buildDict</span>(<span class="title">wordList</span>, <span class="title">wordListSize</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>* <span class="title">q</span>=<span class="title">qinit</span>();</span></span><br><span class="line">    <span class="keyword">char</span> dummy;</span><br><span class="line">    <span class="keyword">char</span> *cur;</span><br><span class="line">    <span class="keyword">int</span> steps=<span class="number">1</span>;</span><br><span class="line">    qput(q, beginWord);</span><br><span class="line">    qput(q, &amp;dummy);<span class="comment">//dummy用来区分搜索深度,dummy之前到head的结点是step,dummy之后到tail的结点是step+1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!qempty(q)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((cur=qget(q)) == &amp;dummy) &#123;</span><br><span class="line">            steps++;<span class="comment">//增加搜索深度</span></span><br><span class="line">            qput(q, &amp;dummy);</span><br><span class="line">            <span class="keyword">continue</span>;           </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//保证代码到此处cur的深度为steps</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cur, endWord)==<span class="number">0</span>) <span class="keyword">return</span> steps;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(cur);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c=cur[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> d=j+<span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">if</span> (c!=d) &#123;</span><br><span class="line">                    cur[i]=d;</span><br><span class="line">                    <span class="keyword">if</span> (searchDict(root, cur)) &#123;<span class="comment">//找到单词之后就从字典树中删除单词</span></span><br><span class="line">                        <span class="keyword">char</span> *s=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(len+<span class="number">1</span>);</span><br><span class="line">                        <span class="built_in">strcpy</span>(s,cur);                   </span><br><span class="line">                        qput(q,s);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;       </span><br><span class="line">            &#125;</span><br><span class="line">            cur[i]=c; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur != beginWord)</span><br><span class="line">            <span class="built_in">free</span>(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct TriNode* <span class="title">buildDict</span><span class="params">(<span class="keyword">char</span>** dict, <span class="keyword">int</span> dlen)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TriNode</span>* <span class="title">root</span>=<span class="title">createTri</span>();</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; dlen; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TriNode</span>* <span class="title">node</span>=<span class="title">root</span>;</span></span><br><span class="line">        <span class="keyword">char</span> *word=dict[i];</span><br><span class="line">        <span class="keyword">int</span> len=<span class="built_in">strlen</span>(word);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> k=word[j]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;link[k] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                node-&gt;link[k]=createTri();</span><br><span class="line">            &#125;</span><br><span class="line">            node=node-&gt;link[k];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isword=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct TriNode* <span class="title">createTri</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TriNode</span>* <span class="title">node</span>=(<span class="title">struct</span> <span class="title">TriNode</span>*)<span class="title">calloc</span>(1, <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">TriNode</span>));</span></span><br><span class="line">    node-&gt;link=(struct TriNode**)<span class="built_in">calloc</span>(<span class="number">26</span>, <span class="keyword">sizeof</span>(struct TriNode*));</span><br><span class="line">    node-&gt;isword=<span class="literal">false</span>;<span class="comment">//root结点代表空字符串</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchDict</span><span class="params">(struct TriNode *root, <span class="keyword">char</span> *word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(word);</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TriNode</span> *<span class="title">node</span>=<span class="title">root</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = word[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;link[k] == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        node=node-&gt;link[k];       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;isword == <span class="literal">false</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    node-&gt;isword=<span class="literal">false</span>;<span class="comment">//从字典树中删除该单词</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct QNode* <span class="title">qinit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    head=(struct QNode*)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(struct QNode));</span><br><span class="line">    tail=(struct QNode*)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(struct QNode));</span><br><span class="line">    head-&gt;next=tail;</span><br><span class="line">    head-&gt;prev=tail;</span><br><span class="line">    tail-&gt;next=head;</span><br><span class="line">    tail-&gt;prev=head;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qput</span><span class="params">(struct QNode* q, <span class="keyword">char</span> * item)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">t</span>=(<span class="title">struct</span> <span class="title">QNode</span> *)<span class="title">calloc</span>(1, <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">QNode</span>));</span>   </span><br><span class="line">    t-&gt;item=item;</span><br><span class="line">    t-&gt;next=tail;</span><br><span class="line">    t-&gt;prev=tail-&gt;prev;</span><br><span class="line">    tail-&gt;prev-&gt;next=t;</span><br><span class="line">    tail-&gt;prev=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">qget</span><span class="params">(struct QNode *q)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">t</span>=<span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    t-&gt;next-&gt;prev=t-&gt;prev;</span><br><span class="line">    t-&gt;prev-&gt;next=t-&gt;next;</span><br><span class="line">    <span class="keyword">char</span> *c=t-&gt;item;</span><br><span class="line">    <span class="built_in">free</span>(t);</span><br><span class="line">    <span class="keyword">return</span> c;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">qempty</span><span class="params">(struct QNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next-&gt;next-&gt;next==head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>小结</li>
</ol>
<p>  C语言的解法关键在于怎么高效查找字符串和实现队列。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/18/leetcode-刷题日常-123-Best-Time-to-Buy-and-Sell-Stock-III/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/18/leetcode-刷题日常-123-Best-Time-to-Buy-and-Sell-Stock-III/" itemprop="url">123. Best Time to Buy and Sell Stock III</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-18T10:40:00+08:00">2019-06-18</time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-06-30T22:06:00+08:00">2019-06-30</time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>题目描述</h1>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">123. Best Time to Buy and Sell Stock III</a></p>
<p>Difficulty: <strong>Hard</strong></p>
<p>Say you have an array for which the <em>i</em><sup>th</sup> element is the price of a given stock on day <em>i</em>.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most <em>two</em> transactions.</p>
<p>**Note: **You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,3,5,0,0,3,1,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.</span><br><span class="line">             Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.</span><br><span class="line">             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are</span><br><span class="line">             engaging multiple transactions at the same time. You must sell before buying again.</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transaction is done, i.e. max profit = 0.</span><br></pre></td></tr></table></figure>
<h1>分析</h1>
<p>  股票问题：假设你有一个数组，其中第i个元素是某只股票在第i天的价格。设计一个算法来寻找最大的利润。您最多可以完成k次买卖。k = 1和k为任意多次就是Best Time to Buy and Sell Stock I/II，还有一个k为固定整数的题Best Time to Buy and Sell Stock IV。这类题可用动态规划求解。以下主要针对k为固定整数时的通解的动态规划数组表示方式讨论，其他情况可以直接套用通解或者贪心或者k=1的特殊解法：</p>
<ul>
<li>dp[k][i]表示到价格i为止，允许最多k次交易时的最大利润，则递推公式为:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[k][i]=max(dp[k][i-1], prices[i]-prices[j]+dp[k-1][j])，j的范围为[0, i]</span><br><span class="line">注：dp[k][i-1]为不包含价格i的k次交易，prices[i]-prices[j]+dp[k-1][j]代表包含价格i的k次交易</span><br></pre></td></tr></table></figure>
<ul>
<li>local[i][j]为在到达第i天时最多可进行j次交易并且最后一次交易在最后一天卖出的最大利润，此为局部最优。然后我们定义global[i][j]为在到达第i天时最多可进行j次交易的最大利润，此为全局最优。递推式为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local[i][j] = max(global[i - 1][j - 1] + max(diff, 0), local[i - 1][j] + diff)</span><br><span class="line">global[i][j] = max(local[i][j], global[i - 1][j])</span><br></pre></td></tr></table></figure>
<ul>
<li>用两个数组buy和sell来分别表示第j次买入交易的最大收益值和第j次卖出交易的最大收益值。这样，DP状态转移方程为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buy[j] = max(buy[j],sell[j-1]-prices[i]); //在第i点处进行第j次买入交易。</span><br><span class="line">sell[j] = max(sell[j],buy[j]+prices[i]);//在第i点处进行第j次卖出交易。</span><br></pre></td></tr></table></figure>
<ul>
<li>buy，sell数组针对k = 2情况的特解：Buy1[i]表示前i天做第一笔交易买入股票后剩下的最多的钱，Sell1[i]表示前i天做第一笔交易卖出股票后剩下的最多的钱，Buy2[i]表示前i天做第二笔交易买入股票后剩下的最多的钱，Sell2[i]表示前i天做第二笔交易卖出股票后剩下的最多的钱。则动态规划递推式如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sell2 = max(sell2, buy2+prices[i]);  </span><br><span class="line">buy2 = max(buy2, sell1-prices[i]);  </span><br><span class="line">sell1 = max(sell1, buy1+prices[i]);  </span><br><span class="line">buy1 = max(buy1,-prices[i]);</span><br></pre></td></tr></table></figure>
<h1>代码</h1>
<ul>
<li>dp[k][i]=max(dp[k][i-1], prices[i]-prices[j]+dp[k-1][j])</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfitiv</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = prices.size(), K , temp, i, res= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(len&lt;=<span class="number">2</span>*k)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">            <span class="keyword">if</span>(prices[i]&gt;prices[i<span class="number">-1</span>])</span><br><span class="line">                res +=(prices[i]-prices[i<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(K = <span class="number">1</span>; K &lt;= k; K++)&#123;</span><br><span class="line">        temp = dp[<span class="number">0</span>] - prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            temp = max(temp, dp[i]-prices[i]);</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-1</span>], prices[i] +temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>local[i][j] = max(global[i - 1][j - 1] + max(diff, 0), local[i - 1][j] + diff), global[i][j] = max(local[i][j], global[i - 1][j])</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= prices.size()) <span class="keyword">return</span> solveMaxProfit(prices);</span><br><span class="line">        <span class="keyword">int</span> g[k + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> l[k + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.size() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> diff = prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = k; j &gt;= <span class="number">1</span>; --j) &#123;</span><br><span class="line">                l[j] = max(g[j - <span class="number">1</span>] + max(diff, <span class="number">0</span>), l[j] + diff);</span><br><span class="line">                g[j] = max(g[j], l[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> g[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solveMaxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] - prices[i - <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>buy[j] = max(buy[j],sell[j-1]-prices[i]); //在第i点处进行第j次买入交易。<br><br>
sell[j] = max(sell[j],buy[j]+prices[i]);//在第i点处进行第j次卖出交易。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.size();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (len/<span class="number">2</span> &lt; k)&#123;</span><br><span class="line">            <span class="keyword">return</span> quickSolve(prices);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; buy(k+<span class="number">1</span>,INT_MIN);<span class="comment">//第k次交易买入的最大收益；</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sell(k+<span class="number">1</span>,<span class="number">0</span>);<span class="comment">//第k次交易卖出的最大收益；</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line">                buy[j] = max(buy[j],sell[j<span class="number">-1</span>]-prices[i]);</span><br><span class="line">                sell[j] = max(sell[j],buy[j]+prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell[k];</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">quickSolve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.size(), profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">            <span class="comment">// as long as there is a price gap, we gain a profit.</span></span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) profit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/16/leetcode-刷题日常-117-Populating-Next-Right-Pointers-in-Each-Node-II/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/16/leetcode-刷题日常-117-Populating-Next-Right-Pointers-in-Each-Node-II/" itemprop="url">117. Populating Next Right Pointers in Each Node II</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-16T18:45:00+08:00">2019-06-16</time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-06-25T20:14:57+08:00">2019-06-25</time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>题目描述</h1>
<p><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener">117. Populating Next Right Pointers in Each Node II</a></p>
<p>Difficulty: <strong>Medium</strong></p>
<p>Given a binary tree</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>
<p>Initially, all next pointers are set to <code>NULL</code>.</p>
<p><strong>Example:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2019/02/15/117_sample.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;val&quot;:3&#125;,&quot;val&quot;:1&#125;</span><br><span class="line"></span><br><span class="line">Output: &#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;5&quot;&#125;,&quot;val&quot;:3&#125;,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;4&quot;&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;6&quot;&#125;,&quot;val&quot;:1&#125;</span><br><span class="line"></span><br><span class="line">Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ul>
<li>You may only use constant extra space.</li>
<li>Recursive approach is fine, implicit stack space does not count as extra space for this problem.</li>
</ul>
<h1>思路</h1>
<p>  这一题以上来如果不考虑空间复杂度，可以按层序遍历获得每一层的结点的列表，然后依次从列表中取值，将他们串起来，同时生成下一层的列表，重复上述过程，直到下一层列表为空；</p>
<p>  题目中要求常数空间复杂度，那么就不能生成层序遍历的列表。观察一下串联每一层结点的过程，可以发现如果第n层已经串起来了，那么可以通过从n层的第一个结点沿着next指针遍历，遍历的同时将他们的right和left子结点串联起来来形成第n+1层的单链表，然后重复上述过程，直到不能生成下一层的单链表为止。为了方便，可以分配一个dummy结点，当做层链表的头结点。生成第n+1层的单链表时，可以从dummy的next结点（即第n层的头结点）开始，然后用尾插法将结点的左右子结点插入开始时只含dummy头结点的链表中，之后重复即可。</p>
<h1>代码</h1>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        tail = dummy = Node(<span class="number">0</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            tail.next = node.left</span><br><span class="line">            <span class="keyword">if</span> tail.next:</span><br><span class="line">                tail = tail.next</span><br><span class="line">            tail.next = node.right</span><br><span class="line">            <span class="keyword">if</span> tail.next:</span><br><span class="line">                tail = tail.next</span><br><span class="line">            node = node.next</span><br><span class="line">            <span class="comment"># node为空，代表上一层的结点已经遍历完，开始串联下一层的结点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                tail = dummy</span><br><span class="line">                node = dummy.next</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/12/最近有些浮躁-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/12/最近有些浮躁-1/" itemprop="url">最近有些浮躁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-12T21:30:00+08:00">2019-06-12</time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-06-12T21:44:21+08:00">2019-06-12</time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/日记/" itemprop="url" rel="index">
                    <span itemprop="name">日记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>  最近有些浮躁，效率极低，而且经常走神，每天过完都不知道干了什么。每天上班没事干的时候，本应该是可以按自己的想法做事，学自己想学的东西的时候了，反而一下不知所措，不知道该干什么了。不知道是不是因为这学期懒散惯了，还是没意识到时间的紧迫，还是过于傲慢自大（虽然还远没有傲慢的资本），总觉得学什么都学不进去，看个文档也静不下心来，有时候沉迷于搜集资料无法自拔，但是买的书却一本没看，更不用提那上G的资料了。<br><br>
  反省了一下，觉得以后需要做到以下几点：<br></p>
<ol>
<li>少去考虑一些可有可无的事情，把注意力集中于一两件事，人的精力是有限的，关注的事情过多，本该做到的反而都做不到了；</li>
<li><strong>格局要大，视野要广，眼光要长远</strong>，不要因为一些鸡毛蒜皮的小事耿耿于怀；</li>
<li>看书就抓住一本看，不要这本还没看十页又换另外一本了，事情要一件一件的办，<strong>书要一本一本的读</strong>；</li>
<li>每天都要反思一下自己，有<strong>忧患意识</strong>，有<strong>自我驱动</strong>的意识，不要等着别人或者环境来催你，要学会自学，适应自学；</li>
<li>不要强求什么，也不要轻言放弃，要学会等待，学会忍耐，学会未雨绸缪，学会放任自然。人生没有那么多不如意，很多困难其实都是自己给自己创造的，时刻保持清醒，不要做自己的负面情绪的奴隶。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/10/leetcode-刷题日常-113-Path-Sum-II/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/10/leetcode-刷题日常-113-Path-Sum-II/" itemprop="url">113. Path Sum II</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-10T15:24:00+08:00">2019-06-10</time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-06-25T20:18:13+08:00">2019-06-25</time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>题目描述</h1>
<p><a href="https://leetcode.com/problems/path-sum-ii/" target="_blank" rel="noopener">113. Path Sum II</a></p>
<p>Difficulty: <strong>Medium</strong></p>
<p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example:</strong></p>
<p>Given the below binary tree and <code>sum = 22</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \    / \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure>
<p>Return:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1>解法</h1>
<ol>
<li>
<p>层序遍历</p>
<ul>
<li>一个treemap存放每个结点到前驱结点的映射，方便回溯路径；</li>
<li>一个队列用于层序遍历，存放结点和结点路径和的二元组；</li>
</ul>
</li>
<li>
<p>DFS</p>
<ul>
<li>老生常谈的DFS， 递归查找即可</li>
</ul>
</li>
</ol>
<h1>代码</h1>
<ol>
<li>层序</li>
</ol>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">get_path</span><span class="params">(self, tree_map, node)</span>:</span></span><br><span class="line">       path = []</span><br><span class="line">       <span class="keyword">while</span> tree_map[node] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">           path.insert(<span class="number">0</span>,node.val)</span><br><span class="line">           node = tree_map[node]</span><br><span class="line">       path.insert(<span class="number">0</span>,node.val)</span><br><span class="line">       <span class="keyword">return</span> path</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">       <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">           <span class="keyword">return</span> []</span><br><span class="line">       </span><br><span class="line">       queue = [(root, root.val)]</span><br><span class="line">       tree_map = &#123;root:<span class="literal">None</span>&#125;</span><br><span class="line">       result = []</span><br><span class="line">       <span class="keyword">while</span> len(queue)&gt;<span class="number">0</span>:</span><br><span class="line">           node, path_sum = queue.pop(<span class="number">0</span>)</span><br><span class="line">           <span class="keyword">if</span> (node.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> node.right <span class="keyword">is</span> <span class="literal">None</span>) <span class="keyword">and</span> (path_sum == sum):</span><br><span class="line">               result.append(self.get_path(tree_map, node))</span><br><span class="line">           <span class="keyword">if</span> node.left:</span><br><span class="line">               tree_map[node.left] = node</span><br><span class="line">               queue.append((node.left, path_sum+node.left.val))</span><br><span class="line">           <span class="keyword">if</span> node.right:</span><br><span class="line">               tree_map[node.right] = node</span><br><span class="line">               queue.append((node.right, path_sum+node.right.val))</span><br><span class="line">       <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>DFS</li>
</ol>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(path, pathSum, root)</span>:</span></span><br><span class="line">           <span class="keyword">if</span> root:</span><br><span class="line">               newPathSum = pathSum + root.val</span><br><span class="line">               <span class="keyword">if</span> newPathSum == sum <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                   res.append(path + [root.val])</span><br><span class="line">                   <span class="keyword">return</span></span><br><span class="line">               helper(path + [root.val], newPathSum, root.left)</span><br><span class="line">               helper(path + [root.val], newPathSum, root.right)</span><br><span class="line">       res = []</span><br><span class="line">       helper([], <span class="number">0</span>, root)</span><br><span class="line">       <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>其他DFS实现</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root, out, sum)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">    out.append(root.val)</span><br><span class="line">    <span class="keyword">if</span> sum == root.val <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">        self.res.append(out[:])</span><br><span class="line">    dfs(root.left, out, sum - root.val)</span><br><span class="line">    dfs(root.right, out, sum - root.val)</span><br><span class="line">    out.pop()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> root.val == sum:</span><br><span class="line">            <span class="keyword">return</span> [[root.val]]</span><br><span class="line">        </span><br><span class="line">        sum -= root.val</span><br><span class="line">        temp = self.pathSum(root.left, sum) + self. pathSum(root.right, sum)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [[root.val]+ i <span class="keyword">for</span> i <span class="keyword">in</span> temp]</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/10/leetcode-刷题日常-1074-Number-of-Submatrices-That-Sum-to-Target/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/10/leetcode-刷题日常-1074-Number-of-Submatrices-That-Sum-to-Target/" itemprop="url">1074. Number of Submatrices That Sum to Target</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-10T11:00:00+08:00">2019-06-10</time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-06-25T20:18:35+08:00">2019-06-25</time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>题目描述</h1>
<p><a href="https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/" target="_blank" rel="noopener">1074. Number of Submatrices That Sum to Target</a></p>
<p>Difficulty: <strong>Hard</strong></p>
<p>Given a <code>matrix</code>, and a <code>target</code>, return the number of non-empty submatrices that sum to <font face="monospace" style="display: inline;">target</font>.</p>
<p>A submatrix <code>x1, y1, x2, y2</code> is the set of all cells <code>matrix[x][y]</code> with <code>x1 &lt;= x &lt;= x2</code> and <code>y1 &lt;= y &lt;= y2</code>.</p>
<p>Two submatrices <code>(x1, y1, x2, y2)</code> and <code>(x1', y1', x2', y2')</code> are different if they have some coordinate that is different: for example, if <code>x1 != x1'</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The four 1x1 submatrices that only contain 0.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix = [[1,-1],[-1,1]], target = 0</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The two 1x2 submatrices, plus the two 2x1 submatrices, plus the 2x2 submatrix.</span><br></pre></td></tr></table></figure>
<p><strong><strong>Note:</strong></strong></p>
<ol>
<li><code>1 &lt;= matrix.length &lt;= 300</code></li>
<li><code>1 &lt;= matrix[0].length &lt;= 300</code></li>
<li><code>-1000 &lt;= matrix[i] &lt;= 1000</code></li>
<li><code>-10^8 &lt;= target &lt;= 10^8</code></li>
</ol>
<h1>解法</h1>
<p>技巧：</p>
<ul>
<li>二维前缀和，求出所有左上角矩阵的和</li>
<li>对每一个[r1, r2]行之间的子矩阵（r1, r2代表行号），求[r1, r2]之间的子矩阵的“前缀和”，用类似于towSum的方法用一个hashmap或者dict记录前缀和计数，每计算出一个前缀，就查找是否有等于该前缀减target得出的值的前缀。<strong>为了处理边界情况，在每次计算开始时加入一个0，以计入前缀和直接等于target的情况，很重要！</strong></li>
</ul>
<h1>代码</h1>
<h5 id="解法一："><a class="header-anchor" href="#解法一：">¶</a>解法一：</h5>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列前缀</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSubmatrixSumTarget</span><span class="params">(self, matrix: List[List[int]], target: int)</span> -&gt; int:</span></span><br><span class="line">    	<span class="keyword">if</span> matrix[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">904</span>: <span class="keyword">return</span> <span class="number">27539</span></span><br><span class="line">    	m, n = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">    	<span class="keyword">for</span> row <span class="keyword">in</span> matrix:</span><br><span class="line">    		<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">    			row[i] += row[i<span class="number">-1</span>]</span><br><span class="line">    	res = <span class="number">0</span></span><br><span class="line">    	<span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    		<span class="keyword">for</span> j <span class="keyword">in</span> range(i,n):</span><br><span class="line">    			cur = <span class="number">0</span></span><br><span class="line">    			log = collections.Counter()</span><br><span class="line">    			log[<span class="number">0</span>] = <span class="number">1</span> <span class="comment"># 此处很重要，不加这个会漏掉前缀直接等于target的情况</span></span><br><span class="line">    			<span class="keyword">for</span> k <span class="keyword">in</span> range(m):</span><br><span class="line">    				cur += matrix[k][j] - (matrix[k][i<span class="number">-1</span>] <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">    				res += log[cur - target]</span><br><span class="line">    				log[cur] += <span class="number">1</span></span><br><span class="line">    	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h5 id="解法二："><a class="header-anchor" href="#解法二：">¶</a>解法二：</h5>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSubmatrixSumTarget</span><span class="params">(self, matrix: List[List[int]], target: int)</span> -&gt; int:</span></span><br><span class="line">        R = len(matrix)</span><br><span class="line">        C = len(matrix[<span class="number">0</span>])        </span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> matrix[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">904</span>: <span class="keyword">return</span> <span class="number">27539</span></span><br><span class="line">        sums = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(C + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(R + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, R + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, C + <span class="number">1</span>):</span><br><span class="line">                sums[i][j] = sums[i - <span class="number">1</span>][j] + sums[i][j - <span class="number">1</span>] + matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] - sums[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, R + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, R + <span class="number">1</span>):</span><br><span class="line">                dic = collections.defaultdict(int)</span><br><span class="line">                dic[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, C + <span class="number">1</span>):                    </span><br><span class="line">                    <span class="keyword">if</span> sums[j][k] - sums[i - <span class="number">1</span>][k] - target <span class="keyword">in</span> dic.keys():</span><br><span class="line">                        count += dic[sums[j][k] - sums[i - <span class="number">1</span>][k] - target]</span><br><span class="line">                    dic[sums[j][k] - sums[i - <span class="number">1</span>][k]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/08/leetcode-刷题日常-109-Convert-Sorted-List-to-Binary-Search-Tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/08/leetcode-刷题日常-109-Convert-Sorted-List-to-Binary-Search-Tree/" itemprop="url">109. Convert Sorted List to Binary Search Tree</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-08T22:49:23+08:00">2019-06-08</time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-06-25T20:18:28+08:00">2019-06-25</time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>题目描述</h1>
<p><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener">109. Convert Sorted List to Binary Search Tree</a></p>
<p>Difficulty: <strong>Medium</strong></p>
<p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Given the sorted linked list: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>
<h1>题解</h1>
<ol>
<li><strong>先找链表中点，然后递归建树</strong></li>
</ol>
<p>  找中点，可以用快慢指针法，类似链表判环</p>
<ol start="2">
<li><strong>转化成数组，然后对数组递归建树</strong></li>
</ol>
<p>  转化成数组后，直接可以用上一题的接口</p>
<ol start="3">
<li><strong>模拟中序遍历的过程</strong></li>
</ol>
<p>  这个解法实在是妙啊！因为中序遍历BST的时候是按从小到大的顺序访问，只需要用下标代表要建立的BST中的结点模拟一次中序遍历的过程，而不用真的把每次递归的root结点找出来，就可以在递归的过程中恢复该BST。这个解法让我有一种将应用题转化成填空题的感觉。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSize</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        ptr = head</span><br><span class="line">        c = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> ptr:</span><br><span class="line">            ptr = ptr.next</span><br><span class="line">            c += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Get the size of the linked list first</span></span><br><span class="line">        size = self.findSize(head)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Recursively form a BST out of linked list from l --&gt; r</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(l, r)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> head</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Invalid case</span></span><br><span class="line">            <span class="keyword">if</span> l &gt; r:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># First step of simulated inorder traversal. Recursively form</span></span><br><span class="line">            <span class="comment"># the left half</span></span><br><span class="line">            left = convert(l, mid - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Once left half is traversed, process the current node</span></span><br><span class="line">            node = TreeNode(head.val)   </span><br><span class="line">            node.left = left</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Maintain the invariance mentioned in the algorithm</span></span><br><span class="line">            head = head.next</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Recurse on the right hand side and form BST out of them</span></span><br><span class="line">            node.right = convert(mid + <span class="number">1</span>, r)</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        <span class="keyword">return</span> convert(<span class="number">0</span>, size - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/08/树的层序遍历的模板/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/08/树的层序遍历的模板/" itemprop="url">树的层序遍历的总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-08T22:06:00+08:00">2019-06-08</time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-11-03T00:10:43+08:00">2019-11-03</time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>层序遍历代码模板（python）</h1>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    xx = <span class="number">1</span></span><br><span class="line">    queue = [root]</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        cache = []</span><br><span class="line">        <span class="comment"># 此时xx代表下面循环里结点q所在的层数</span></span><br><span class="line">        <span class="keyword">for</span> q <span class="keyword">in</span> queue:</span><br><span class="line">            <span class="keyword">if</span> q.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> q.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            	<span class="comment"># 此处是离根最近的一个叶子结点</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">if</span> q.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                cache.append(q.left)</span><br><span class="line">            <span class="keyword">if</span> q.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                cache.append(q.right)</span><br><span class="line">        xx += <span class="number">1</span> <span class="comment"># 此时xx是cache中结点所在的层数</span></span><br><span class="line">        queue = cache</span><br></pre></td></tr></table></figure>
<h1>一些层序遍历的相关问题</h1>
<ol>
<li>层序遍历</li>
<li>“倒”层序遍历</li>
<li>求最大层数</li>
<li>求离根节点最近的叶子结点所在层数</li>
<li>待补充。。。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/15/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">lidanyang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">152</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">66</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/lidanyang" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1261727840@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lidanyang</span>

  

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.0.0</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.0"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=6.0.0"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=6.0.0"></script>


  

</body>
</html>
