<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.0" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="分类">
<meta property="og:url" content="http://yoursite.com/categories/index.html">
<meta property="og:site_name" content="Just a blog">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-05-28T06:22:34.105Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="分类">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/categories/">





  <title>Just a blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Just a blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/13/C-Primer学习笔记：第5章-语句/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/13/C-Primer学习笔记：第5章-语句/" itemprop="url">C++ Primer学习笔记：第5章 语句</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-13T19:36:00+08:00">2019-07-13</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++ </span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>5.1 简单语句</h1>
<ul>
<li>空语句</li>
<li>别漏写分号，也别多写分号</li>
<li>复合语句（块）</li>
</ul>
<h1>5.2 语句作用域</h1>
<blockquote>
<p>这一节有什么意义？</p>
</blockquote>
<h1>5.3 条件语句</h1>
<h2 id="5-3-1-if语句"><a class="header-anchor" href="#5-3-1-if语句">¶</a>5.3.1 if语句</h2>
<ul>
<li>
<p>使用if else语句</p>
</li>
<li>
<p>嵌套if语句</p>
</li>
<li>
<p>注意使用花括号</p>
</li>
<li>
<p>悬垂else（dangling else）</p>
<ul>
<li>else与离它最近的尚未匹配的if匹配</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (grade % <span class="number">10</span> &gt;= <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">if</span> (grade % <span class="number">10</span> &gt; <span class="number">7</span>)</span><br><span class="line">        lettergrade += <span class="string">'+'</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    lettergrade += <span class="string">'-'</span>;</span><br><span class="line"><span class="comment">//上述代码的执行过程和缩进格式不相符，其执行过程实际上等价于如下形式</span></span><br><span class="line"><span class="keyword">if</span> (grade % <span class="number">10</span> &gt;= <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">if</span> (grade % <span class="number">10</span> &gt; <span class="number">7</span>)</span><br><span class="line">        lettergrade += <span class="string">'+'</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        lettergrade += <span class="string">'-'</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用花括号控制执行路径</li>
</ul>
</li>
</ul>
<h2 id="5-3-2-switch语句"><a class="header-anchor" href="#5-3-2-switch语句">¶</a>5.3.2 switch语句</h2>
<ul>
<li>
<p>case关键字和它对应的值一起被称为case标签。case标签必须是整型常量表达式</p>
</li>
<li>
<p>switch内部控制流</p>
<ul>
<li>
<p>case标签匹配成功，将从该标签开始往后顺序执行所有case分支，除非程序显示中断这一过程，否则直到switch结尾才会停下来</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (ch)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'a'</span>:<span class="keyword">case</span> <span class="string">'e'</span>:<span class="keyword">case</span> <span class="string">'i'</span>:<span class="keyword">case</span> <span class="string">'o'</span>:<span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">        ++vowelCnt;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>漏写break容易引发缺陷</p>
</li>
<li>
<p>default标签</p>
<ul>
<li>没有任何一个case标签匹配上的时候，程序会执行紧跟于default之后的语句</li>
<li>如果switch结构以一个空的default标签作为结束，则该default标签后面必须跟上一条空语句或者空块</li>
</ul>
</li>
<li>
<p>switch内部的变量定义</p>
<ul>
<li>
<p>如果在某处一个带有初值的变量位于作用域之外，在另一处该变量位于作用域之内，则从前一处跳转到后一处的行为是非法行为（也就是<strong>跳过带有显示或隐式初始化的变量的声明</strong>）</p>
</li>
<li>
<p>不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置</p>
</li>
<li>
<p>如果要为某个case分支定义并初始化一个变量，应该把变量定义在块内，从而确保后面的所有case都在变量的作用域之外</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">	<span class="comment">//因为程序的执行流程可能绕开下面的初始化语句，所以该switch语句不合法</span></span><br><span class="line">	<span class="built_in">string</span> file_name;<span class="comment">//错误：控制流绕过一个隐式初始化的变量</span></span><br><span class="line">	<span class="keyword">int</span> ival = <span class="number">0</span>;<span class="comment">//错误：控制流绕过一个显示初始化的变量</span></span><br><span class="line">	<span class="keyword">int</span> jval;<span class="comment">//正确：因为jval没有初始化</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">	<span class="comment">//正确：jval虽然在作用域内，但是它没有被初始化</span></span><br><span class="line">	jval = next_num();<span class="comment">//正确：给jval赋一个值</span></span><br><span class="line">	<span class="keyword">if</span> (file_name.empty())<span class="comment">//file_name在作用域内，但是没有被初始化</span></span><br><span class="line">        <span class="comment">//...</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1>5.4 迭代语句</h1>
<h2 id="5-4-1-while语句"><a class="header-anchor" href="#5-4-1-while语句">¶</a>5.4.1 while语句</h2>
<ul>
<li>定义在while条件部分或者while循环体内的变量每次迭代都经历从创建到销毁的过程</li>
<li>使用while循环的场合
<ul>
<li>不确定要迭代多少次</li>
<li>循环后想访问循环控制变量</li>
</ul>
</li>
</ul>
<h2 id="5-4-2-传统for语句"><a class="header-anchor" href="#5-4-2-传统for语句">¶</a>5.4.2 传统for语句</h2>
<ul>
<li>
<p>传统for的执行流程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(initializer;condition;expression) </span><br><span class="line">	statement</span><br></pre></td></tr></table></figure>
</li>
</ul>
<div id="flowchart-0" class="flow-chart"></div>
<ul>
<li>for语句头中的多重声明
<ul>
<li>init-statement可以定义多个对象，但是只能有一条声明语句，所有变量的基础类型必须相同</li>
</ul>
</li>
<li>省略for语句头中的某些部分
<ul>
<li>可以省略任何一个或者全部</li>
</ul>
</li>
</ul>
<h2 id="5-4-3-范围for语句"><a class="header-anchor" href="#5-4-3-范围for语句">¶</a>5.4.3 范围for语句</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for(declaration : expression)</span></span><br><span class="line"><span class="comment">//	statement;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;r : v)</span><br><span class="line">    r *= <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h2 id="5-4-4-do-while语句"><a class="header-anchor" href="#5-4-4-do-while语句">¶</a>5.4.4 do while语句</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//do</span></span><br><span class="line"><span class="comment">//	statement</span></span><br><span class="line"><span class="comment">//while (condition);</span></span><br><span class="line"><span class="comment">//condition使用的变量必须定义在循环体之外</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不允许在条件部分定义变量</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    mumble(foo);</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="keyword">int</span> foo = get_foo());<span class="comment">//错误：将变量声明放在了do的条件部分</span></span><br></pre></td></tr></table></figure>
<h1>5.5 跳转语句</h1>
<h2 id="5-5-1-break语句"><a class="header-anchor" href="#5-5-1-break语句">¶</a>5.5.1 break语句</h2>
<h2 id="5-5-2-continue语句"><a class="header-anchor" href="#5-5-2-continue语句">¶</a>5.5.2 continue语句</h2>
<ul>
<li>只有switch语句嵌套在迭代语句内部，才能在switch里使用continue</li>
<li>continue中断迭代，对于while或者do while来说，继续判断条件的值；对于传统的for循环，继续执行for语句头的expression；对于范围for来说，使用序列中的下一个元素初始化循环控制变量</li>
</ul>
<h2 id="5-5-3-goto语句"><a class="header-anchor" href="#5-5-3-goto语句">¶</a>5.5.3 goto语句</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> label;</span><br><span class="line"></span><br><span class="line">label: statement</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>//goto语句的作用是从goto语句无条件跳转到<strong>同一函数内</strong>的另一条语句</p>
</li>
<li>
<p>标签标示符独立于变量或其他标示符的名字，所以可以和程序中其他实体的标示符用同一个名字而不会互相干扰</p>
</li>
<li>
<p>goto语句和label语句必须在同一个函数之内</p>
</li>
<li>
<p>和switch类似，goto也不能将控制权从变量的作用域之外转移到作用域之内</p>
</li>
<li>
<p>向后跳过一个已经执行的定义是合法的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">begin:</span><br><span class="line">	<span class="keyword">int</span> sz = get_size();</span><br><span class="line">	<span class="keyword">if</span> (sz &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> begin;<span class="comment">//goto执行后销毁sz，sz会重新定义和初始化</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>5.6 try语句块和异常处理</h1>
<blockquote>
<p>异常处理机制为程序中异常检测和异常处理两部分的协作提供支持</p>
</blockquote>
<h2 id="5-6-1-throw表达式"><a class="header-anchor" href="#5-6-1-throw表达式">¶</a>5.6.1 throw表达式</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (item1.isbn() != item2.isbn())</span><br><span class="line">	<span class="keyword">throw</span> runtime_error(<span class="string">"Data must refer to same ISBN"</span>);</span><br><span class="line"><span class="comment">//抛出异常将终止当前函数，并把控制权转移给能处理该异常的代码</span></span><br><span class="line"><span class="comment">//runtime_error定义在stdexcept中</span></span><br></pre></td></tr></table></figure>
<h2 id="5-6-2-try语句块"><a class="header-anchor" href="#5-6-2-try语句块">¶</a>5.6.2 try语句块</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	program-statements</span><br><span class="line">&#125; <span class="keyword">catch</span> (exception-declaration) &#123;</span><br><span class="line">    handler-statements</span><br><span class="line">&#125; <span class="keyword">catch</span> (exception-declaration) &#123;</span><br><span class="line">    handler-statements</span><br><span class="line">&#125;<span class="comment">//...</span></span><br><span class="line"><span class="comment">//catch括号中是一个（可能未命名的）对象的声明，称作异常声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; item1 &gt;&gt; item2) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//执行添加两个Sales_item对象的代码</span></span><br><span class="line">        <span class="comment">//如果添加失败，抛出runtime_error异常</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (runtime_error err) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; err.what()<span class="comment">//what函数返回初始化具体对象时所用的string对象的副本，是一个C风格的字符串(const char *)，what函数没有参数，每个标准库异常类都定义了what函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数在寻找处理代码的过程中退出
<ul>
<li>沿着程序执行路径逐层回退，直到找到适当类型的catch子句为止</li>
<li>如果没有找到匹配的catch子句，则转到名为terminate的标准库函数，此函数的行为与系统有关，一般情况下，执行此函数将导致程序非正常退出。</li>
</ul>
</li>
</ul>
<h2 id="5-6-3-标准异常"><a class="header-anchor" href="#5-6-3-标准异常">¶</a>5.6.3 标准异常</h2>
<ul>
<li>C++标准库定义了一组类，用于报告标准库函数遇到的问题。这些异常类可以在用户编写的程序中使用。
<ul>
<li>exception 头文件定义了最通用的异常类 exception。它只报告异常的发生，不提供任何额外信息</li>
</ul>
</li>
<li>stdexcept 头文件定义了几种常用的异常类
<ul>
<li>new 头文件定义了 bad_alloc 异常类型</li>
<li>type_info 头文件定义了 bad_cast 异常类型</li>
</ul>
</li>
<li>我们只能以默认初始化的方式初始化 exception、bad_alloc 和 bad_cast 对象，不允许为它们提供初始值</li>
<li>其他异常类型的行为则恰好相反：应该使用 string 对象或者 C 风格字符串初始化这些类型的对象，但是不允许使用默认初始化的方式</li>
<li>what 函数返回的 C 风格字符串的内容与其他异常对象的类型有关。如果异常类型有一个字符串初始值，则 what 返回该字符串。对于其他无初始值的异常类型来说，what 返回的内容也由编译器决定<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Start
ed=>end: End
cond1=>condition: condition
init=>operation: initializer
statement=>operation: statement
expr=>operation: expression
st->init
init->cond1
cond1(no)->ed
cond1(yes)->statement
statement->expr
expr->cond1</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/12/C-Primer学习笔记：第4章-表达式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/12/C-Primer学习笔记：第4章-表达式/" itemprop="url">C++ Primer学习笔记：第4章 表达式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-12T19:15:00+08:00">2019-07-12</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>4.1 基础</h1>
<ul>
<li>
<p>4.1.1 基本概念</p>
<ul>
<li>组合运算符和运算对象
<ul>
<li>优先级、结合律、求值顺序</li>
</ul>
</li>
<li>运算对象转换</li>
<li>运算符重载
<ul>
<li>运算对象个数，优先级和结合律无法改变</li>
</ul>
</li>
<li>左值和右值
<ul>
<li>当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值时，用的是对象的身份（内存中的位置）</li>
<li>在需要右值的地方可以用左值代替，但是不能把右值当成左值（位置）使用。当一个左值被当成右值使用时，实际使用的是它的内容。</li>
<li>内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector下标运算符的求值结果都是左值</li>
<li>内置类型和迭代器的递增递减运算符作用于左值对象，其前置版的结果亦是左值</li>
<li>如果表达式求值结果是左值，decltype作用于该表达式（不是变量）得到一个引用类型。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>4.1.2 优先级与结合律</p>
<ul>
<li>结合律：从右到左，还是从左到右</li>
<li>优先级：乘法和除法的优先级相同且都高于加法优先级</li>
<li>括号无视优先级和结合律</li>
</ul>
</li>
<li>
<p>4.1.3 求值顺序</p>
<ul>
<li>只有4种运算符明确规定了运算对象的求值顺序（&amp;&amp; 、|| 、?:和,）</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结合律和优先级确定的是运算符的运算对象是谁，但并没有规定算的顺序。2+3*4+5它的结合性是(2+(3*4))+5，但是不代表3*4是最先计算的，它的计算次序是未知的，未定义的。比如3*4-&gt;2+3*4-&gt;2+3*4+5以及2-&gt;3*4-&gt;2+3*4-&gt;2+3*4+5和5-&gt;3*4-&gt;2+3*4-&gt;2+3*4+5这些次序都是有可能的。虽然它们的计算次序不同，但是对最终结果是没有影响的。</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>求值顺序、优先级、结合律</p>
<ul>
<li>运算对象的求值顺序与优先级和结合律无关</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如f()+g()*h()+j()，如果f,g,h,j会改变同一对象，则是错误表达式，会产生未定义行为</span><br></pre></td></tr></table></figure>
<ul>
<li>两个处理复合表达式的原则
<ul>
<li>拿不准的时候用括号</li>
<li>如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算符。改变运算对象的子表达式本身就是另外一个子表达式的运算对象时，该规则无效。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1>4.2 算术运算符</h1>
<table>
<thead>
<tr>
<th>运算符</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>一元正号</td>
<td>+ expr</td>
</tr>
<tr>
<td>-</td>
<td>一元负号</td>
<td>- expr</td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
<td>expr*expr</td>
</tr>
<tr>
<td>/</td>
<td>除法</td>
<td>expr/expr</td>
</tr>
<tr>
<td>%</td>
<td>求余</td>
<td>expr%expr</td>
</tr>
<tr>
<td>+</td>
<td>加法</td>
<td>expr+expr</td>
</tr>
<tr>
<td>-</td>
<td>减法</td>
<td>expr-expr</td>
</tr>
</tbody>
</table>
<ul>
<li>以上表格运算符均为左结合律</li>
<li>除法运算，结果为负值时向0取整</li>
<li>根据取余运算定义，如果m，n是整数且n非0，则表达式（m/n）*n+m%n的结果与m相等。即如果m%n不等于0，则其符号与m相同。除了-m导致溢出的情况，其他时候(-m)/n和m/(-n)都等于-(m/n)，m%(-n)等于m%n，(-m)%n等于-(m%n)</li>
</ul>
<h1>4.3 逻辑和关系运算符</h1>
<table>
<thead>
<tr>
<th>结合律</th>
<th>运算符</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>右</td>
<td>!</td>
<td>逻辑非</td>
<td>!expr</td>
</tr>
<tr>
<td>左</td>
<td>&lt;</td>
<td>小于</td>
<td>expr&lt;expr</td>
</tr>
<tr>
<td>左</td>
<td>&lt;=</td>
<td>小于等于</td>
<td>expr&lt;=expr</td>
</tr>
<tr>
<td>左</td>
<td>&gt;</td>
<td>大于</td>
<td>expr&gt;expr</td>
</tr>
<tr>
<td>左</td>
<td>&gt;=</td>
<td>大于等于</td>
<td>expr&gt;=expr</td>
</tr>
<tr>
<td>左</td>
<td>==</td>
<td>相等</td>
<td>expr==expr</td>
</tr>
<tr>
<td>左</td>
<td>!=</td>
<td>不相等</td>
<td>expr!=expr</td>
</tr>
<tr>
<td>左</td>
<td>&amp;&amp;</td>
<td>逻辑与</td>
<td>expr&amp;&amp;expr</td>
</tr>
<tr>
<td>左</td>
<td>||</td>
<td>逻辑或</td>
<td>expr||expr</td>
</tr>
</tbody>
</table>
<ul>
<li>关系运算符作用于算术或指针类型，逻辑运算符作用于能转换成布尔值的类型</li>
<li>逻辑与和逻辑或
<ul>
<li>短路求值</li>
</ul>
</li>
<li>逻辑非</li>
<li>关系运算符
<ul>
<li>不要连写，如i &lt; j &lt; k</li>
</ul>
</li>
<li>相等性测试与布尔字面值
<ul>
<li><code>if(val==true)</code>是有问题的写法，因为比较之前会将true转换成val类型，则代码可以改写成`if(val==1)</li>
<li>进行比较运算时，除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为运算对象</li>
</ul>
</li>
</ul>
<h1>4.4 赋值运算符</h1>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">初始值列表赋值时，如果左侧对象是内置类型，则初值列表最多只能包含一个值，而且该值即使转换其空间也不应该大于目标类型空间。</span><br></pre></td></tr></table></figure>
<ul>
<li>赋值运算满足右结合律</li>
<li>赋值运算符优先级较低
<ul>
<li>条件语句中的赋值部分应该加上括号</li>
</ul>
</li>
<li>切勿混淆相等运算符和赋值运算符</li>
<li>复合赋值运算符(如+=,-=,…)
<ul>
<li>和对应的非复合赋值表达式的区别在于左侧对象的求值次数:复合运算符只求值一次，普通运算符求值两次</li>
</ul>
</li>
</ul>
<h1>4.5 递增递减运算符</h1>
<ul>
<li>除非必须，否则不用递增递减运算符的后置版本</li>
<li>在一条语句中混用解引用和递增</li>
<li>运算对象可按任意顺序求值，如<code>*beg = toupper(*beg++)</code>将产生未定义的行为</li>
</ul>
<h1>4.6 成员访问运算符</h1>
<ul>
<li>
<p>解引用运算符优先级低于点运算符，如<code>*p.size()</code>等价于<code>*(p.size())</code></p>
</li>
<li>
<p><strong>箭头运算符作用于一个指针类型的运算对象，结果是一个左值；</strong></p>
</li>
<li>
<p>点运算符分两种情况</p>
<ul>
<li>
<p>如果成员所属对象是左值，则结果是左值；</p>
</li>
<li>
<p>反之，如果成员所属对象是右值，则结果是右值；</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    A() = <span class="keyword">default</span>;</span><br><span class="line">    A(<span class="keyword">int</span> m): n(m) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">st</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    A* pst = &amp;st;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; st.n &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//输出5，st是左值，在该表达式执行完毕后依然存在</span></span><br><span class="line">    st.n = <span class="number">6</span>;               <span class="comment">//合法，可以对左值赋值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pst-&gt;n &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出6，pst是左值，在该表达式执行完毕后依然存在</span></span><br><span class="line">    pst-&gt;n = <span class="number">7</span>;             <span class="comment">//合法，可以对左值赋值</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; A(<span class="number">8</span>).n &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出8，A(8)是右值，在该表达式执行完毕后被销毁</span></span><br><span class="line">    A(<span class="number">8</span>).n = <span class="number">9</span>;             <span class="comment">//非法，不能对右值赋值</span></span><br><span class="line">    pst = &amp;(A(<span class="number">8</span>));          <span class="comment">//非法，不能取右值的地址</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为指针所指的对象一定是一个左值，所以使用-&gt;返回的成员也一定是左值。而对右值对象调用成员调用运算符（.）是合法行为，但是这个被调用的成员在对象被销毁时也一并被销毁，所以整个成员也是右值。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1>4.7 条件运算符(?:)</h1>
<ul>
<li>当条件运算符两个表达式都是左值或者能转换成同一种左值类型时，则运算的结果是左值；否则运算结果是右值</li>
</ul>
<blockquote>
<p>关于“能转换成同一种左值类型时，则运算的结果是左值”的问题:</p>
<p>I read this post to get an overview of the type and value category returned from the conditional operator: <a href="https://stackoverflow.com/questions/8535226/return-type-of-ternary-conditional-operator" target="_blank" rel="noopener">Return type of ‘?:’ (ternary conditional operator)</a></p>
<p>That answers pretty much my question, except the phrasing in C++ Primer to describe the same thing confuses me slightly.</p>
<p>“That result of the conditional operator is an lvalue if both expressions are lvalues <strong>or if they convert to a common lvalue type</strong>. Otherwise the result is an rvalue.”</p>
<p>The bolded bit throws me off. This would suggest to me that, for instance</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">&gt;     <span class="keyword">char</span> z = <span class="number">3</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     ((<span class="number">50</span>&lt;<span class="number">60</span>) ? y : z) = <span class="number">3</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>would be fine, because y and z can be both converted to int (well, z would be the one converted) which is an lvalue type (right?), thus the conditional operator would give an lvalue as its value category. This codedoes not compile however, because it actually gives out an rvalue. Can anyone provide an example of the exceptional case mentioned by the bolded bit, so I can understand what point it’s trying to make?</p>
<p>My understanding seems to be that: If the expression are lvalues of the same type, then an lvalue of that type is returned. Otherwise an rvalue (of some compiler-determined type) is returned.</p>
<p>解答:</p>
<p>If <code>z</code> is converted to <code>int</code>, the lvalue-to-rvalue conversion has already been applied, and the result is a prvalue, not an lvalue.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; int a = 10;</span><br><span class="line">&gt; (long)a = 1;//非法，因为a发生了左值到右值(lvalue-to-rvalue)的类型转换，(long)a是右值</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>One example of <code>?:</code> where the two operands have different types, but the result is an lvalue, is when one is <code>const</code>-qualified and the other isn’t:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">const</span> <span class="keyword">int</span> &amp;<span class="title">f</span><span class="params">(<span class="keyword">bool</span> a, <span class="keyword">int</span> &amp;b, <span class="keyword">const</span> <span class="keyword">int</span> &amp;c)</span> </span>&#123;</span><br><span class="line">&gt;   <span class="comment">// b has type int, c has type const int, the result is an lvalue of type const int</span></span><br><span class="line">&gt;   <span class="keyword">return</span> a ? b : c;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>Another example is where one is a class with a custom conversion operator:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">&gt;   <span class="keyword">operator</span> <span class="keyword">int</span>&amp;();</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; <span class="function"><span class="keyword">int</span> &amp;<span class="title">f</span><span class="params">(<span class="keyword">bool</span> a, <span class="keyword">int</span> &amp;b, S &amp;c)</span> </span>&#123;</span><br><span class="line">&gt;   <span class="comment">// b has type int, c has type S, the result is an lvalue of type int</span></span><br><span class="line">&gt;   <span class="comment">// if a is false, c's conversion operator is called</span></span><br><span class="line">&gt;   <span class="keyword">return</span> a ? b : c;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>
<p>嵌套条件运算符</p>
<ul>
<li>右结合律</li>
<li>条件运算的嵌套最好别超过两到三层。</li>
</ul>
</li>
<li>
<p>在输出表达式中使用条件运算符</p>
<ul>
<li>
<p>条件运算符的优先级非常低，因此当一条长表达式中嵌套了条件运算子表达式时，通常需要加上括号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; ((grade &lt; <span class="number">60</span>) ? <span class="string">"fail"</span> : <span class="string">"pass"</span>);<span class="comment">//输出pass或fail</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (grade &lt; <span class="number">60</span>) ? <span class="string">"fail"</span> : <span class="string">"pass"</span>;<span class="comment">//输出1或者0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; grade &lt; <span class="number">60</span> ? <span class="string">"fail"</span> : <span class="string">"pass"</span>;<span class="comment">//错误，师徒比较cout和60</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1>4.8 位运算符</h1>
<ul>
<li>位运算符（左结合律）</li>
</ul>
<table>
<thead>
<tr>
<th>运算符</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>~</td>
<td>位求反</td>
<td>~expr</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移</td>
<td>expr1&lt;&lt;expr2</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
<td>expr1&gt;&gt;expr2</td>
</tr>
<tr>
<td>&amp;</td>
<td>位与</td>
<td>expr&amp;expr</td>
</tr>
<tr>
<td>^</td>
<td>位异或</td>
<td>expr^expr</td>
</tr>
<tr>
<td>|</td>
<td>位或</td>
<td>expr|expr</td>
</tr>
</tbody>
</table>
<ul>
<li>移位运算符
<ul>
<li>运算对象如果是“小整型”，则它的值会被自动提升成较大整型</li>
<li>左侧运算对象按照右侧的要求移动位数，然后将经过移动的（可能进行了类型提升）左侧运算对象的拷贝作为求值结果。其中右侧运算对象一定不能为负，而且值必须严格小于结果的位数。</li>
<li>左移右侧插入0</li>
<li>右移根据有无符号和具体环境</li>
</ul>
</li>
<li>位求反运算符
<ul>
<li>char类型首先提升成int类型，然后逐位求反</li>
</ul>
</li>
<li>位与、位或、位异或运算符</li>
<li>使用位运算符
<ul>
<li>unsigned long在任何机器上都至少有32位</li>
</ul>
</li>
<li>移位运算符（IO运算符）满足左结合律
<ul>
<li>移位运算符优先级不高不低，介于中间：比算术运算符优先级低，但是比关系运算符、赋值运算符和条件运算符要高</li>
</ul>
</li>
</ul>
<h1>4.9 sizeof运算符</h1>
<ul>
<li>形式
<ul>
<li><code>sizeof (type)</code></li>
<li><code>sizeof expr</code></li>
</ul>
</li>
<li>sizeof满足右结合律并且和*解引用运算符优先级一样，所以以下两者等价
<ul>
<li><code>sizeof *p</code></li>
<li><code>sizeof(*p)</code></li>
</ul>
</li>
<li>C++11允许使用作用域运算符获取类成员大小
<ul>
<li>sizeof运算符的结果部分依赖于其作用的类型</li>
<li>引用类型返回被引用对象的空间的大小</li>
<li>对指针执行sizeof运算返回的是指针所占的空间的大小</li>
<li>对指针解引用执行sizeof运算，返回其指向的对象的所占空间大小。</li>
<li>对指针解引用执行sizeof运算，不需要其指向对象有效，只要有类型即可。</li>
<li>对数组进行sizeof运算，返回的是数组的大小，也就是相当于对数组的所有元素执行一次sizeof 并且相加！</li>
<li>对string和vector对象进行sizeof运算只返回该类型固定部分的大小，不会计算对象元素占用多少空间</li>
</ul>
</li>
<li>sizeof返回值是常量表达式，可以用sizeof结果声明数组的维数</li>
</ul>
<h1>4.10 运算符</h1>
<ul>
<li>逗号运算符和逻辑与，逻辑或，条件运算符一样，也规定了运算对象的求值顺序</li>
<li>逗号运算符的真正结果是右侧表达式的值。右侧对象如果是左值，则最终结果也是左值</li>
</ul>
<h1>4.11 类型转换</h1>
<ul>
<li>
<p>何时转换</p>
<ul>
<li>在大多数表达式中，比int小的首先提升为较大整数类型</li>
<li><strong>在条件中</strong>，非布尔值转换成布尔</li>
<li>初始化时，初始值转换为变量的类型；赋值语句右侧转为左侧的类型</li>
<li>算术或关系的运算对象需要转换成同一种类型</li>
<li>函数调用也会发生转换</li>
</ul>
</li>
<li>
<p>4.11.1 算术转换</p>
<ul>
<li>
<p>整型提升</p>
</li>
<li>
<p>char类型提升成int，unsigned int，long，unsigned long、long long和unsigned long long中最小的一种类型</p>
</li>
<li>
<p>无符号类型运算对象</p>
<ul>
<li>首先，整型提升。如果类型匹配（同为有符号或无符号），则小类型转为大类型</li>
<li>如果一个是有符号，一个无符号，无符号类型不小于有符号类型，则有符号转换成无符号的类型。如unsigned int和int，int转换成unsigned int</li>
<li>如果有符号大于无符号类型，此时依赖于机器。如果无符号<strong>所有值都能存在有符号类型中</strong>，则无符号转成有符号的类型；否则有符号转换成无符号类型。如long和unsigned int，大小相同，则long转为unsigned int；否则，unsigned int转为long</li>
</ul>
</li>
<li>
<p>4.11.2 其它隐式类型转换</p>
<ul>
<li>数组转换成指针
<ul>
<li>当数组用作decltype的参数，或者取地址符、sizeof和typeid的运算对象时，不会发生转换</li>
<li>初始化一个数组的引用时，也不会发生转换</li>
</ul>
</li>
<li>指针转换
<ul>
<li>常量整数值0或字面值nullptr能转换成任意指针类型</li>
<li>指向任意非常量的指针可以转换成void*</li>
<li>指向任意对象的指针可以转换成const void*</li>
</ul>
</li>
<li>转换成bool类型
<ul>
<li>如果指针或算术类型的值为0，转换结果为false，否则为true</li>
</ul>
</li>
<li>转换成常量
<ul>
<li>允许将指向非常量类型的指针转换成指向相应的常量类型指针，反过来不行</li>
</ul>
</li>
<li>类类型的转换
<ul>
<li>类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换</li>
<li>istream类对象向bool值转换时，读入成功，则转成true；读入失败，转成false</li>
</ul>
</li>
</ul>
</li>
<li>
<p>4.11.3 显示转换</p>
<ul>
<li>
<p>命名的强制转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cast-name&lt;type&gt;(expression);<span class="comment">//type是目标类型，expression是要转换的值，cast-name是static_cast、dynamic_cast、const_cast和reinterpret_cast中的一种，用来指定执行的转换类型</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>static_cast</p>
<ul>
<li>
<p>任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进行强制类型转换以便执行浮点数除法</span></span><br><span class="line"><span class="keyword">double</span> slope = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(j) / i;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>const_cast</p>
<ul>
<li>
<p>const_cast<strong>只能改变运算对象的底层const</strong>。对于将常量对象转换成非常量对象的行为，我们一般称为“<strong>去掉cosnt性质</strong>”。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *pc;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(pc);  <span class="comment">// 正确：但是通过p写值是未定义的行为</span></span><br><span class="line"><span class="comment">// 一旦去掉某个对象的const性质，编译器就不再阻止我们对该对象进行写操作了</span></span><br><span class="line"><span class="comment">//如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为</span></span><br><span class="line"><span class="comment">//如果对象是一个常量，再使用const_cast执行写操作就会产生未定义的后果</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>const_cast只能也只有const_cast能用来改变表达式的常量属性，不能用const_cast改变变量类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> <span class="keyword">char</span> *cp;</span><br><span class="line"> <span class="keyword">char</span> *q = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span> *&gt;(cp);   <span class="comment">// 错误：static_cast不能转换掉const性质</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="built_in">string</span>&gt;(cp);     <span class="comment">// 正确：字符串字面值转换成stirng类型    </span></span><br><span class="line"><span class="keyword">const_cast</span>&lt;<span class="built_in">string</span>&gt;(cp);    <span class="comment">// 错误：const_cast只能改变常量属性</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>reinterpret_cast</p>
<ul>
<li>reinterpret_cast 通常为运算对象的位模式提供较低层次上的<strong>重新解释</strong>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip;</span><br><span class="line"><span class="keyword">char</span> *pc = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(ip);  <span class="comment">// 我们必须牢记pc所指真实对象是一个int而非字符</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>旧式的强制类型转换：</p>
</li>
</ul>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *pc = (<span class="keyword">char</span> *) ip;    <span class="comment">// ip是指向整数的指针</span></span><br><span class="line"><span class="comment">// 效果与使用reinterpret_cast一样</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/12/C-Primer学习笔记：第3章-字符串、向量和数组/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/12/C-Primer学习笔记：第3章-字符串、向量和数组/" itemprop="url">C++ Primer学习笔记：第3章 字符串、向量和数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-12T13:22:00+08:00">2019-07-12</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>
<p>string上的操作</p>
<ul>
<li>
<p>读写</p>
</li>
<li>
<p>getline(cin,line)</p>
<ul>
<li>getline返回的是流参数cin,而不是line</li>
</ul>
</li>
<li>
<p>empty，size函数</p>
</li>
<li>
<p>string::size_type</p>
<ul>
<li>s.size &lt; n，n为负数时，判断结果肯定是True</li>
<li>一条表达式如果已经用size()，就别用int，避免有无符号数混用</li>
</ul>
</li>
<li>
<p>比较大小，大小写敏感</p>
</li>
<li>
<p>对象直接赋值</p>
</li>
<li>
<p>string对象相加</p>
</li>
<li>
<p>字面值和string对象相加</p>
<ul>
<li>字符串和字符字面值都能转化为string类型</li>
<li>加法运算符两侧的运算对象至少有一个是string</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s6 = s1 +<span class="string">","</span>+<span class="string">"world"</span><span class="comment">//正确，（s1+","）是string对象，再"world"运算</span></span><br><span class="line"><span class="built_in">string</span> s7 = <span class="string">","</span>+<span class="string">"world"</span>+s1<span class="comment">//错误，第一个加法运算符两侧都是字面值</span></span><br></pre></td></tr></table></figure>
<ul>
<li>字符串字面值和string是不同对象</li>
</ul>
</li>
</ul>
</li>
<li>
<p>处理string中的字符</p>
<ul>
<li>cctype头文件（isalnum,isalpha,iscntrl,isdigit,isgraph,islowe,isprint,ispunct,isspace,isupper,isxdigit,tolower,toupper）
<ul>
<li>C++头文件和C语言头文件的对应关系:cname&lt;—&gt;name.h</li>
<li>区别:C语言头文件中定义的名字不是std命名空间，而C++是</li>
</ul>
</li>
<li>处理每个字符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(auto c : str)</span><br><span class="line">	cout &lt;&lt; c &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用for修改字符串中字符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(auto &amp;c : s)</span><br><span class="line">	c = toupper(c);</span><br></pre></td></tr></table></figure>
<ul>
<li>只处理一部分字符
<ul>
<li>下标(类型为string::size_type，可以确保大于0，但是要检查是否小于s.size())</li>
<li>迭代器</li>
</ul>
</li>
</ul>
</li>
<li>
<p>标准库类型vector</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.vector是模板而非类型，类型要包含元素类型，如vector&lt;int&gt;</span><br><span class="line">2.元素为vector的vector对象，要在外层的右尖括号和元素类型之间加一个空格，如vector&lt;vector&lt;int&gt; &gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义和初始化vector对象</li>
</ul>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;T&gt; v3(n, val);</span><br><span class="line">  	<span class="built_in">vector</span>&lt;T&gt; v4(n);<span class="comment">//n个进行了值初始化的对象</span></span><br><span class="line">  	<span class="built_in">vector</span>&lt;T&gt; v5&#123;a,b,c...&#125;</span><br></pre></td></tr></table></figure>
<pre><code>  - 列表初始化注意事项，C++初始化方式互相等价使用的例外
      - 使用拷贝初始化，只能提供一个初始值
      - 如果提供类内初始值，则只能用拷贝初始化或者花括号形式初始化，不能使用
      - 如果提供初始元素值的列表。则只能把初始值都放在花括号里进行列表初始化，不能放在圆括号里
  - 创建指定数量的元素
  - 值初始化
      - 必须要类型支持
      - 只能使用直接初始化，不能用拷贝初始化
  - 圆括号和花括号
      - 圆括号是用提供的值来构造vector对象的，提供的值是容量和元素初始值的信息
      - 花括号提供的一般是元素初始值的列表，只有提供的值无法拿来执行列表初始化时才会考虑用这样的值来构造vector对象
</code></pre>
<ul>
<li>向vector中添加元素</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector对象高效增长，除非所有元素值都一样，否则最好先定一个空vector，再在运行时向其添加具体值</span><br></pre></td></tr></table></figure>
<pre><code>- 循环体内部包含有向vector添加元素的语句，则不能使用范围for循环，即for语句体内不应该改变其所遍历序列的大小
</code></pre>
<ul>
<li>其他vector操作</li>
</ul>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">v.empty()</span><br><span class="line">v.size()</span><br><span class="line">v.push_back()</span><br><span class="line">v[n]<span class="comment">//返回第n个位置上元素的引用</span></span><br><span class="line">v1 = v2</span><br><span class="line">v1 = &#123;a,b,c...&#125;</span><br><span class="line">v1 == v2</span><br><span class="line">v1 != v2</span><br><span class="line">&lt;,&lt;=,&gt;,&gt;=</span><br></pre></td></tr></table></figure>
<ul>
<li>vector<int>::size_type和vector::size_type的区别
<ul>
<li>vector<int>::size_type是内部元素的size()返回类型</int></li>
<li>vector::size是vector的size()的返回类型</li>
</ul>
</int></li>
<li>不能用下标形式添加元素，会造成缓冲区溢出，尽可能使用范围for语句</li>
</ul>
</li>
<li>
<p>迭代器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">所有标准库容器都可以使用迭代器，而下标运算符只有少数几种支持。</span><br><span class="line">string不属于容器类型，但是支持很多与容器类型类似的操作。</span><br><span class="line">类似指针，迭代器提供了对对象的间接访问。有效迭代器指向某个元素，或者指向容器中尾元素的下一位置</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>使用迭代器</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto b = v.begin(), e = v.end();</span><br></pre></td></tr></table></figure>
<ul>
<li>begin成员返回第一个元素的迭代器，end返回尾元素下一位置的迭代器，即“尾后迭代器”</li>
</ul>
</li>
<li>
<p>迭代器运算符</p>
<ul>
<li>迭代器用法类似于指针</li>
<li>同样和指针类似，可以用解引用运算符来获取元素</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s(&quot;something&quot;)</span><br><span class="line">if (s.begin() != s.end())&#123;</span><br><span class="line">	auto it = s.begin();</span><br><span class="line">	*it = toupper(*it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>移动迭代器</p>
<ul>
<li>++it</li>
<li>–it</li>
</ul>
</li>
<li>
<p>迭代器类型</p>
<ul>
<li>有迭代器的标准库类型用iterator和const_iterator表示迭代器类型</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;::iterator it;</span><br><span class="line">vector&lt;int&gt;::const_iterator it2;</span><br></pre></td></tr></table></figure>
<ul>
<li>常量vector对象只能用const_iterator</li>
<li>cbegin(),cend()不论vector是不是常量，都返回const_iterator迭代器</li>
</ul>
</li>
<li>
<p>解引用和成员运算符结合</p>
<ul>
<li>(*it).empty()等价于it-&gt;empty()</li>
</ul>
</li>
<li>
<p>某些对vector的操作会使迭代器失效</p>
<ul>
<li>任何一种可能改变vector对象容量的操作，都会使该vector对象的迭代器失效</li>
</ul>
</li>
<li>
<p>迭代器运算</p>
</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iter + n</span><br><span class="line">iter - n</span><br><span class="line">iter += n</span><br><span class="line">iter -= n</span><br><span class="line">iter1 - iter2</span><br><span class="line">&gt;、&gt;=、&lt;、&lt;=</span><br></pre></td></tr></table></figure>
<pre><code>  - 迭代器算术运算
      - 迭代器相减返回difference_type的有符号整数
  - 可以用迭代器实现二分查找
</code></pre>
</li>
<li>
<p>数组</p>
<ul>
<li>
<p>定义和初始化</p>
<ul>
<li>定义时必须显示指定数组类型，数组元素应该为对象</li>
<li>字符数组可以用字符串字面值初始化，大小为字符串字符数加上一个空字符</li>
<li>理解数组声明的含义，最好办法是从数组名字开始按照由内向外的顺序阅读</li>
</ul>
</li>
<li>
<p>访问数组</p>
<ul>
<li>下标为size_t类型，机器相关的无符号类型，在cstddef头文件中定义</li>
<li>数组的下标运算符是C++语言直接定义，而vector的下标运算符是库模板vector定义的，只能用于vector类型的运算对象</li>
</ul>
</li>
<li>
<p>指针和数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int ia[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;</span><br><span class="line">auto ia2(ia);//ia2是一个整型指针</span><br><span class="line">decltype(ia) ia3;//ia3是一个含有10个整数的数组</span><br></pre></td></tr></table></figure>
<ul>
<li>指针也是迭代器
<ul>
<li>尾后指针需要通过<code>int *e = &amp;arr[10];</code>来获取</li>
</ul>
</li>
<li>标准库函数begin，end
<ul>
<li>int *pbeg = begin(arr), int *pend = end(arr);</li>
<li>尾后指针不能解引用和递增</li>
</ul>
</li>
<li>指针运算
<ul>
<li>指针相减结果类型是ptrdiff_t，定义在cstddef头文件，带符号</li>
</ul>
</li>
<li>解引用和指针运算交互</li>
<li>下标和指针
<ul>
<li>内置的下标运算符可以处理负值，比如<code>int *p = &amp;ia[2];int k = p[-2]</code>，p[-2]代表的是数组首元素</li>
</ul>
</li>
</ul>
</li>
<li>
<p>C风格字符串</p>
</li>
<li>
<p>和旧代码的接口</p>
<ul>
<li>混用string和C风格字符串
<ul>
<li>用字符数组代替string
<ul>
<li>允许用字符数组初始化或者赋值string对象</li>
<li>string对象的加法运算允许使用字符数组作为其中一个运算对象，在string对象复合赋值运算中允许使用空字符结束的字符数组作为右侧运算对象</li>
</ul>
</li>
<li>用string不能直接代替字符数组，需要通过string的c_str()方法获得对应的字符数组
<ul>
<li>c_str获得的字符数组可能因为原string的改变失去效用</li>
</ul>
</li>
</ul>
</li>
<li>用数组初始化vector对象</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int int_arr[] = &#123;0,1,2,3,4,5&#125;;</span><br><span class="line">vector&lt;int&gt; ivec(begin(int_arr), end(int_arr));</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>多维数组</p>
<ul>
<li>多维数组初始化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[3][4] = &#123;&#123;0,1,2,3&#125;,&#123;4,5,6,7&#125;,&#123;8,9,10,11&#125;&#125;;</span><br><span class="line">int ia[3][4] = &#123;0,1,2,3,4,5,6,7,8,9,10,11&#125;;//按顺序初始化</span><br><span class="line">int ia[3][4] = &#123;&#123;0&#125;,&#123;4&#125;,&#123;8&#125;&#125;;//初始化每行第一个元素</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>范围for处理多维数组</p>
<ul>
<li>除了最内层，其他所有循环控制变量都要用引用类型。因为数组形式的元素会自动转换成指向数组首元素的指针，从而失去了数组大小信息。</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(auto &amp;row : ia)</span><br><span class="line">	for(auto col : row)</span><br><span class="line">		cout &lt;&lt; col &lt;&lt; endl</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>指针和多维数组</p>
</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">using int_array = int[4];</span><br><span class="line">typedef int int_array[4];</span><br><span class="line">for(int_array *p = begin(ia); p != end(ia); ++p)</span><br><span class="line">	for(int *q = begin(*p); q != end(*p); ++q)</span><br><span class="line">		cout &lt;&lt; *q &lt;&lt; &apos; &apos;;</span><br><span class="line">	cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/11/C-Primer学习-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/11/C-Primer学习-1/" itemprop="url">C++ Primer学习笔记：第2章 变量和基本类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-11T13:56:00+08:00">2019-07-11</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>复合类型
<ul>
<li>声明语句=基本数据类型+（类型修饰符）声明符</li>
<li>类型修饰符是声明符的一部分，所以要声明多个指针变量要在每个变量名前面加*符号</li>
</ul>
</li>
<li>关于引用和指针
<ul>
<li>引用必须被初始化，绑定到初始值，之后一直不能改变</li>
<li><strong>引用并非对象</strong>，所以不能定义引用的引用</li>
<li>引用只能绑定在左值上，即可以取地址的值（非字面值或者表达式计算结果）</li>
<li>引用不是对象，没有实际地址，所以不能定义指向引用的指针</li>
<li><a href="https://blog.csdn.net/williamgavin/article/details/78825170" target="_blank" rel="noopener">关于“指针指向紧邻对象所占空间的下一个位置”的理解</a></li>
<li><code>int &amp;*p</code>与<code>int *&amp; p</code>
<ul>
<li>假设p是一个指向int的指针，则指向指针的引用<code>int *&amp;r = p</code>。而<code>int &amp;*p；</code>是不正确的，它创建的是引用的指针。阅读复合类型声明时，要从右到左解读修饰符。</li>
</ul>
</li>
</ul>
</li>
<li>const限定符
<ul>
<li>const对象默认情况下只在文件内有效，多个文件中可以同时定义同名的const变量（一般此时const对象值是常量表达式，编译过程中替换值）</li>
<li>想在文件间共享const对象，必须定义和声明前都加上extern（一般此时const对象值不是常量表达式，可能要运行时才知道其值）</li>
<li>初始化const的引用可以用任意表达式作为初始值，只要改值能转化为引用的类型，比如字面量，非常量对象，甚至是一个一般表达式（const引用可以用任意值初始化是指针类型必须和所指对象类型一致的例外情况之一，另外一种好像是面对对象的多态）</li>
<li>顶层const和底层const
<ul>
<li>顶层const：指针本身是个常量</li>
<li>底层const：指针所指对象是一个常量</li>
<li>对象拷贝，顶层const不受什么影响，底层const需要拷入拷出对象都是底层const或者可以转换（非常量可以转换成常量，反之不行）</li>
</ul>
</li>
<li>一个对象（或表达式）是不是常量表达式是由它的数据类型和初始值共同决定的，比如<code>const int sz = get_size()、int staff = 27</code>都不是常量表达式</li>
<li>constexpr类型
<ul>
<li>将变量声明为constexpr以便由编译器验证变量是否是常量表达式</li>
<li>constexpr函数，是编译时即可计算结果的函数，constexpr函数可以给constexpr变量赋初始值</li>
<li>声明constexpr时用到的类型必须有所限制。这些类型统称为字面值类型（literal type）
<ul>
<li>算数类型、引用、指针是字面值类型。constexpr int a = 0；//算数类型int是字面值类型；</li>
<li>某些类也是字面值类型，这些类叫做字面值常量类假设类Debug是字面值常量类。那么：constexpr Debug debug(args)；//生成一个constexpr对象-debug；</li>
</ul>
</li>
<li>constexpr指针初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象</li>
<li><code>constexpr int *q = nullptr</code>是顶层const，<code>const int *p = nullptr</code>是底层const</li>
</ul>
</li>
</ul>
</li>
<li>类型处理
<ul>
<li>类型别名
<ul>
<li>由两种方法定义类型别名
<ul>
<li><code>typedef double wages;</code></li>
<li><code>using SI = Sales_item;</code></li>
</ul>
</li>
<li>指针，常量和类型别名
<ul>
<li>如果<code>typedef char *pstring;</code>，则<code>const pstring cstr = 0</code>中cstr是指向字符的常量指针，而不是指向常量字符的指针。<code>const char *cstr</code>这种理解是错的，它的基本数据类型是const char，而<code>const pstring cstr = 0</code>中的基本数据类型是const pstring</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>auto说明符
<ul>
<li>
<p>auto说明符声明多个变量时，这些变量的基本数据类型必须相同。如<code>auto i = 0, *p = &amp;i</code>合法，而<code>auto sz = 0, pi = 3.14</code>不合法</p>
</li>
<li>
<p>auto定义的变量<strong>必须有初始值</strong></p>
</li>
<li>
<p>auto不能识别顶层const，能识别底层const，要让auto推断出顶层const，需要在auto前加上const，如<code>const auto f = ci</code></p>
</li>
<li>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto &amp;h = 42;//非常量引用不能绑定字面值</span><br><span class="line">auto &amp;g = ci;//g是整型常量引用，绑定到ci</span><br><span class="line">const auto &amp;j = 42;//可以为常量引用绑定字面值</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留</p>
</li>
<li>
<p><a href="https://segmentfault.com/q/1010000002568358" target="_blank" rel="noopener">如果给初始值绑定一个引用，则此时的常量就不是顶层常量了</a></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">top-level const : const 修饰的是自身。</span><br><span class="line">low-level const : const 修饰的是别人。</span><br><span class="line">            </span><br><span class="line">            POD(Plain Old Data)，类对象都只能是&quot;自身&quot;</span><br><span class="line">            指针可以是自身(指针本身)，可以是别人(指向别人)。</span><br><span class="line">            引用没有自身，只能是别人。(引用是别名)</span><br><span class="line">       </span><br><span class="line">const int ci = 0;</span><br><span class="line">auto &amp;r1 = ci; 发生了什么？</span><br><span class="line">                从 top-level const 降成 low-level const.</span><br><span class="line">                top-level const 的特质(自身无法修改)依然保留。</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>decltype类型指示符</p>
<ul>
<li>decltype处理顶层const和引用的方式与auto有些许不同。</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const int ci = 0, &amp;cj = ci;</span><br><span class="line">decltype(ci) x = 0;//x的类型是const int</span><br><span class="line">decltype(cj) y = x;//y的类型是const int &amp;，绑定到x上</span><br><span class="line">decltype(cj) z;//错误，引用必须初始化</span><br></pre></td></tr></table></figure>
<ul>
<li>引用在decltype中使用时，此时并不是其所指对象的同义词。如<code>decltype(ci)</code>和<code>decltype(cj)</code>代表的类型不同</li>
<li>decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i = 42, *p = &amp;i, &amp;r = i;</span><br><span class="line">decltype(r+0) b; // b是未初始化的int类型</span><br><span class="line">decltype(*p) c; // 错误，c是int&amp;类型，必须初始化</span><br><span class="line">decltype(r) d; // 错误，d是int的引用类型，引用必须初始化</span><br></pre></td></tr></table></figure>
<ul>
<li>decltype与auto的另一个重要区别是，decltype和表达式形式密切相关</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decltype((i)) d;//错误，d是int&amp;类型，必须初始化</span><br><span class="line">decltype(i) e;//正确，e是未初始化的int类型</span><br></pre></td></tr></table></figure>
<ul>
<li><code>decltype((variable))</code>的结果永远是引用，而<code>decltype(variable)</code>的结果只有当variable本身就是引用时才是一个引用。</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/11/python面向对象学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/11/python面向对象学习/" itemprop="url">python学习20190711</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-11T09:56:00+08:00">2019-07-11</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><a href="https://www.cnblogs.com/weihengblog/p/8528967.html" target="_blank" rel="noopener">python抽象类和接口类</a></li>
<li><a href="https://www.cnblogs.com/yutongzhu/p/5615764.html" target="_blank" rel="noopener">python装饰器</a></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myDecorator</span><span class="params">(...)</span>:</span>　　　　<span class="comment">#定义装饰器，可能带参数</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span>    <span class="comment">#装饰器核心，以被装饰的函数对象为参数，返回装饰后的函数对象</span></span><br><span class="line">         <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kvargs)</span>:</span>    <span class="comment">#装饰的过程，参数列表适应不同参数的函数</span></span><br><span class="line">             ...    <span class="comment">#修改函数调用前的行为</span></span><br><span class="line">             func(*args, **kvargs)    <span class="comment">#调用函数</span></span><br><span class="line">             ...    <span class="comment">#修改函数调用后的行为</span></span><br><span class="line">         <span class="keyword">return</span> wrapper</span><br><span class="line">     <span class="keyword">return</span> decorator</span><br><span class="line"> </span><br><span class="line"><span class="meta">@myDecorator(...):　　　　#给函数加上装饰器</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">myFunc</span><span class="params">(...)</span>:</span>　　　　  <span class="comment">#自己定义的功能函数</span></span><br><span class="line">    	...</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><a href="https://blog.csdn.net/orangleliu/article/details/45843813" target="_blank" rel="noopener">装饰器传参数</a></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*- encoding=utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task_logging</span><span class="params">(taskname)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func_wrapper</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">        @wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">return_wrapper</span><span class="params">(*args, **wkargs)</span>:</span></span><br><span class="line">            <span class="comment"># 函数通过装饰起参数给装饰器传送参数</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">'before task'</span>,taskname</span><br><span class="line">            <span class="comment"># 装饰器传变量给函数</span></span><br><span class="line">            taskid = <span class="number">1</span></span><br><span class="line">            summer, funcres = func(taskid, *args, **wkargs)</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'after task'</span>, taskid, summer </span><br><span class="line">            <span class="keyword">return</span> funcres</span><br><span class="line">        <span class="keyword">return</span> return_wrapper</span><br><span class="line">    <span class="keyword">return</span> func_wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@task_logging("test")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testd</span><span class="params">(taskid)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"testd runing"</span>,taskid</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"task summer success eg"</span>, []</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> testd()</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><a href="https://www.cnblogs.com/zhangzhuozheng/p/8053045.html" target="_blank" rel="noopener">*arg和**kwargs的含义</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/09/树状数组/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/09/树状数组/" itemprop="url">树状数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-09T16:18:00+08:00">2019-07-09</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/data-structure/" itemprop="url" rel="index">
                    <span itemprop="name">data structure</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-基本用法"><a class="header-anchor" href="#1-基本用法">¶</a>1. 基本用法</h3>
<ol>
<li>单点修改，区间查询</li>
<li>区间修改，单点查询</li>
<li>区间修改，区间查询</li>
</ol>
<h3 id="2-扩展"><a class="header-anchor" href="#2-扩展">¶</a>2. 扩展</h3>
<ol>
<li>二维树状数组</li>
<li>求逆序对</li>
<li>树形树状数组</li>
<li>求指定长度单调子序列</li>
<li>树状数组求区间最值</li>
</ol>
<h3 id="3-参考"><a class="header-anchor" href="#3-参考">¶</a>3. 参考</h3>
<ol>
<li><a href="https://blog.csdn.net/qq_39553725/article/details/76696168" target="_blank" rel="noopener">https://blog.csdn.net/qq_39553725/article/details/76696168</a></li>
<li><a href="https://blog.csdn.net/u010598215/article/details/48206959" target="_blank" rel="noopener">https://blog.csdn.net/u010598215/article/details/48206959</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/07/OI知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/07/OI知识/" itemprop="url">OI知识总结（来自洛谷）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-07T22:17:40+08:00">2019-07-07</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="线性结构"><a class="header-anchor" href="#线性结构">¶</a>线性结构</h2>
<h3 id="莫队算法"><a class="header-anchor" href="#莫队算法">¶</a>莫队算法</h3>
<h3 id="前缀和"><a class="header-anchor" href="#前缀和">¶</a>前缀和</h3>
<h3 id="基本数组"><a class="header-anchor" href="#基本数组">¶</a>基本数组</h3>
<h3 id="向量"><a class="header-anchor" href="#向量">¶</a>向量</h3>
<h3 id="栈"><a class="header-anchor" href="#栈">¶</a>栈</h3>
<h3 id="队列"><a class="header-anchor" href="#队列">¶</a>队列</h3>
<h3 id="块状链表-块状数组-分块"><a class="header-anchor" href="#块状链表-块状数组-分块">¶</a>块状链表，块状数组，分块</h3>
<h3 id="st表-稀疏表"><a class="header-anchor" href="#st表-稀疏表">¶</a>st表，稀疏表</h3>
<h3 id="差分"><a class="header-anchor" href="#差分">¶</a>差分</h3>
<h2 id="字符串"><a class="header-anchor" href="#字符串">¶</a>字符串</h2>
<h3 id="后缀自动机-sam"><a class="header-anchor" href="#后缀自动机-sam">¶</a>后缀自动机，SAM</h3>
<h3 id="字典树-trie树"><a class="header-anchor" href="#字典树-trie树">¶</a>字典树，Trie树</h3>
<h3 id="ac自动机"><a class="header-anchor" href="#ac自动机">¶</a>AC自动机</h3>
<h3 id="kmp"><a class="header-anchor" href="#kmp">¶</a>KMP</h3>
<h3 id="后缀数组-sa"><a class="header-anchor" href="#后缀数组-sa">¶</a>后缀数组，SA</h3>
<h3 id="后缀树"><a class="header-anchor" href="#后缀树">¶</a>后缀树</h3>
<h3 id="有限状态自动机"><a class="header-anchor" href="#有限状态自动机">¶</a>有限状态自动机</h3>
<h3 id="哈夫曼-huffman"><a class="header-anchor" href="#哈夫曼-huffman">¶</a>哈夫曼，Huffman</h3>
<h3 id="简单密码学"><a class="header-anchor" href="#简单密码学">¶</a>简单密码学</h3>
<h3 id="回文自动机pam"><a class="header-anchor" href="#回文自动机pam">¶</a>回文自动机PAM</h3>
<h3 id="manacher算法"><a class="header-anchor" href="#manacher算法">¶</a>Manacher算法</h3>
<h2 id="动态规划"><a class="header-anchor" href="#动态规划">¶</a>动态规划</h2>
<h3 id="动态规划初步"><a class="header-anchor" href="#动态规划初步">¶</a>动态规划初步</h3>
<h3 id="背包"><a class="header-anchor" href="#背包">¶</a>背包</h3>
<h3 id="环型动态规划"><a class="header-anchor" href="#环型动态规划">¶</a>环型动态规划</h3>
<h3 id="数位动态规划"><a class="header-anchor" href="#数位动态规划">¶</a>数位动态规划</h3>
<h3 id="多维状态"><a class="header-anchor" href="#多维状态">¶</a>多维状态</h3>
<h3 id="区间动态规划"><a class="header-anchor" href="#区间动态规划">¶</a>区间动态规划</h3>
<h3 id="子母树"><a class="header-anchor" href="#子母树">¶</a>子母树</h3>
<h3 id="动态规划优化"><a class="header-anchor" href="#动态规划优化">¶</a>动态规划优化</h3>
<h3 id="树形动态规划"><a class="header-anchor" href="#树形动态规划">¶</a>树形动态规划</h3>
<h3 id="插头动态规划"><a class="header-anchor" href="#插头动态规划">¶</a>插头动态规划</h3>
<h2 id="搜索"><a class="header-anchor" href="#搜索">¶</a>搜索</h2>
<h3 id="bfs"><a class="header-anchor" href="#bfs">¶</a>BFS</h3>
<h3 id="dfs"><a class="header-anchor" href="#dfs">¶</a>DFS</h3>
<h3 id="剪枝"><a class="header-anchor" href="#剪枝">¶</a>剪枝</h3>
<h3 id="记忆化搜索"><a class="header-anchor" href="#记忆化搜索">¶</a>记忆化搜索</h3>
<h3 id="启发式搜索"><a class="header-anchor" href="#启发式搜索">¶</a>启发式搜索</h3>
<h4 id="启发式迭代加深-ida"><a class="header-anchor" href="#启发式迭代加深-ida">¶</a>启发式迭代加深，IDA*</h4>
<h4 id="dancing-links"><a class="header-anchor" href="#dancing-links">¶</a>Dancing links</h4>
<h4 id="爬山法"><a class="header-anchor" href="#爬山法">¶</a>爬山法</h4>
<h4 id="模拟退火"><a class="header-anchor" href="#模拟退火">¶</a>模拟退火</h4>
<h4 id="遗传"><a class="header-anchor" href="#遗传">¶</a>遗传</h4>
<h4 id="a-算法"><a class="header-anchor" href="#a-算法">¶</a>A*算法</h4>
<h3 id="迭代加深"><a class="header-anchor" href="#迭代加深">¶</a>迭代加深</h3>
<h3 id="随机调整"><a class="header-anchor" href="#随机调整">¶</a>随机调整</h3>
<h2 id="数学-数论"><a class="header-anchor" href="#数学-数论">¶</a>数学，数论</h2>
<h3 id="整数研究"><a class="header-anchor" href="#整数研究">¶</a>整数研究</h3>
<h4 id="素数判断-质数-筛法"><a class="header-anchor" href="#素数判断-质数-筛法">¶</a>素数判断，质数，筛法</h4>
<h4 id="最大公约数-gcd"><a class="header-anchor" href="#最大公约数-gcd">¶</a>最大公约数，gcd</h4>
<h4 id="扩展欧几里得-扩欧"><a class="header-anchor" href="#扩展欧几里得-扩欧">¶</a>扩展欧几里得，扩欧</h4>
<h4 id="不定方程"><a class="header-anchor" href="#不定方程">¶</a>不定方程</h4>
<h4 id="进制"><a class="header-anchor" href="#进制">¶</a>进制</h4>
<h4 id="同余-中国剩余定理"><a class="header-anchor" href="#同余-中国剩余定理">¶</a>同余，中国剩余定理</h4>
<h4 id="莫比乌斯反演"><a class="header-anchor" href="#莫比乌斯反演">¶</a>莫比乌斯反演</h4>
<h4 id="逆元"><a class="header-anchor" href="#逆元">¶</a>逆元</h4>
<h3 id="集合论"><a class="header-anchor" href="#集合论">¶</a>集合论</h3>
<h3 id="群论"><a class="header-anchor" href="#群论">¶</a>群论</h3>
<h4 id="置换"><a class="header-anchor" href="#置换">¶</a>置换</h4>
<h4 id="polya原理"><a class="header-anchor" href="#polya原理">¶</a>Polya原理</h4>
<h3 id="组合数学"><a class="header-anchor" href="#组合数学">¶</a>组合数学</h3>
<h4 id="排列组合"><a class="header-anchor" href="#排列组合">¶</a>排列组合</h4>
<h4 id="二项式定理"><a class="header-anchor" href="#二项式定理">¶</a>二项式定理</h4>
<h4 id="康托展开"><a class="header-anchor" href="#康托展开">¶</a>康托展开</h4>
<h4 id="袋与球问题"><a class="header-anchor" href="#袋与球问题">¶</a>袋与球问题</h4>
<h4 id="鸽笼"><a class="header-anchor" href="#鸽笼">¶</a>鸽笼</h4>
<h4 id="容斥"><a class="header-anchor" href="#容斥">¶</a>容斥</h4>
<h4 id="fibonacci"><a class="header-anchor" href="#fibonacci">¶</a>Fibonacci</h4>
<h4 id="catalan"><a class="header-anchor" href="#catalan">¶</a>Catalan</h4>
<h4 id="stirling"><a class="header-anchor" href="#stirling">¶</a>Stirling</h4>
<h4 id="生成函数"><a class="header-anchor" href="#生成函数">¶</a>生成函数</h4>
<h4 id="lucas"><a class="header-anchor" href="#lucas">¶</a>Lucas</h4>
<h3 id="线性规划"><a class="header-anchor" href="#线性规划">¶</a>线性规划</h3>
<h3 id="概率论-统计"><a class="header-anchor" href="#概率论-统计">¶</a>概率论，统计</h3>
<h4 id="众数"><a class="header-anchor" href="#众数">¶</a>众数</h4>
<h4 id="简单概率"><a class="header-anchor" href="#简单概率">¶</a>简单概率</h4>
<h4 id="条件概率"><a class="header-anchor" href="#条件概率">¶</a>条件概率</h4>
<h4 id="bayes"><a class="header-anchor" href="#bayes">¶</a>Bayes</h4>
<h4 id="期望"><a class="header-anchor" href="#期望">¶</a>期望</h4>
<h3 id="线性代数"><a class="header-anchor" href="#线性代数">¶</a>线性代数</h3>
<h4 id="矩阵运算"><a class="header-anchor" href="#矩阵运算">¶</a>矩阵运算</h4>
<h4 id="矩阵乘法"><a class="header-anchor" href="#矩阵乘法">¶</a>矩阵乘法</h4>
<h4 id="线性递推-递推式"><a class="header-anchor" href="#线性递推-递推式">¶</a>线性递推，递推式</h4>
<h4 id="高斯消元"><a class="header-anchor" href="#高斯消元">¶</a>高斯消元</h4>
<h4 id="异或方程组"><a class="header-anchor" href="#异或方程组">¶</a>异或方程组</h4>
<h4 id="线性基"><a class="header-anchor" href="#线性基">¶</a>线性基</h4>
<h3 id="微积分初步"><a class="header-anchor" href="#微积分初步">¶</a>微积分初步</h3>
<h4 id="极限"><a class="header-anchor" href="#极限">¶</a>极限</h4>
<h4 id="导数"><a class="header-anchor" href="#导数">¶</a>导数</h4>
<h4 id="积分"><a class="header-anchor" href="#积分">¶</a>积分</h4>
<h4 id="定积分"><a class="header-anchor" href="#定积分">¶</a>定积分</h4>
<h4 id="立体解析几何"><a class="header-anchor" href="#立体解析几何">¶</a>立体解析几何</h4>
<h4 id="级数"><a class="header-anchor" href="#级数">¶</a>级数</h4>
<h2 id="图论"><a class="header-anchor" href="#图论">¶</a>图论</h2>
<h3 id="图的建立-建图"><a class="header-anchor" href="#图的建立-建图">¶</a>图的建立，建图</h3>
<h4 id="邻接矩阵"><a class="header-anchor" href="#邻接矩阵">¶</a>邻接矩阵</h4>
<h4 id="邻接表"><a class="header-anchor" href="#邻接表">¶</a>邻接表</h4>
<h3 id="图的遍历"><a class="header-anchor" href="#图的遍历">¶</a>图的遍历</h3>
<h3 id="拓扑排序"><a class="header-anchor" href="#拓扑排序">¶</a>拓扑排序</h3>
<h4 id="aov"><a class="header-anchor" href="#aov">¶</a>AOV</h4>
<h4 id="aoe"><a class="header-anchor" href="#aoe">¶</a>AOE</h4>
<h3 id="最短路"><a class="header-anchor" href="#最短路">¶</a>最短路</h3>
<h4 id="floyd"><a class="header-anchor" href="#floyd">¶</a>Floyd</h4>
<h4 id="dijkstra"><a class="header-anchor" href="#dijkstra">¶</a>Dijkstra</h4>
<h4 id="bellman-ford"><a class="header-anchor" href="#bellman-ford">¶</a>Bellman-Ford</h4>
<h4 id="spfa"><a class="header-anchor" href="#spfa">¶</a>SPFA</h4>
<h4 id="k短路"><a class="header-anchor" href="#k短路">¶</a>K短路</h4>
<h4 id="差分约束"><a class="header-anchor" href="#差分约束">¶</a>差分约束</h4>
<h3 id="生成树"><a class="header-anchor" href="#生成树">¶</a>生成树</h3>
<h4 id="prim"><a class="header-anchor" href="#prim">¶</a>Prim</h4>
<h4 id="kruskal"><a class="header-anchor" href="#kruskal">¶</a>Kruskal</h4>
<h4 id="生成树另类算法"><a class="header-anchor" href="#生成树另类算法">¶</a>生成树另类算法</h4>
<h4 id="次小生成树"><a class="header-anchor" href="#次小生成树">¶</a>次小生成树</h4>
<h4 id="特殊生成树"><a class="header-anchor" href="#特殊生成树">¶</a>特殊生成树</h4>
<h3 id="圈和块"><a class="header-anchor" href="#圈和块">¶</a>圈和块</h3>
<h4 id="最小环"><a class="header-anchor" href="#最小环">¶</a>最小环</h4>
<h4 id="负权环"><a class="header-anchor" href="#负权环">¶</a>负权环</h4>
<h4 id="连通块"><a class="header-anchor" href="#连通块">¶</a>连通块</h4>
<h4 id="2-sat"><a class="header-anchor" href="#2-sat">¶</a>2-SAT</h4>
<h4 id="欧拉公式"><a class="header-anchor" href="#欧拉公式">¶</a>欧拉公式</h4>
<h4 id="四色定理"><a class="header-anchor" href="#四色定理">¶</a>四色定理</h4>
<h4 id="欧拉回路"><a class="header-anchor" href="#欧拉回路">¶</a>欧拉回路</h4>
<h3 id="强连通分量-缩点"><a class="header-anchor" href="#强连通分量-缩点">¶</a>强连通分量，缩点</h3>
<h4 id="tarjan"><a class="header-anchor" href="#tarjan">¶</a>Tarjan</h4>
<h4 id="割点"><a class="header-anchor" href="#割点">¶</a>割点</h4>
<h3 id="仙人掌"><a class="header-anchor" href="#仙人掌">¶</a>仙人掌</h3>
<h2 id="计算几何"><a class="header-anchor" href="#计算几何">¶</a>计算几何</h2>
<h3 id="凸包"><a class="header-anchor" href="#凸包">¶</a>凸包</h3>
<h3 id="叉积"><a class="header-anchor" href="#叉积">¶</a>叉积</h3>
<h3 id="线段相交"><a class="header-anchor" href="#线段相交">¶</a>线段相交</h3>
<h3 id="点积"><a class="header-anchor" href="#点积">¶</a>点积</h3>
<h3 id="半平面相交-半平面交"><a class="header-anchor" href="#半平面相交-半平面交">¶</a>半平面相交，半平面交</h3>
<h3 id="最近点对"><a class="header-anchor" href="#最近点对">¶</a>最近点对</h3>
<h3 id="凸多边形的交"><a class="header-anchor" href="#凸多边形的交">¶</a>凸多边形的交</h3>
<h3 id="离散化扫描"><a class="header-anchor" href="#离散化扫描">¶</a>离散化扫描</h3>
<h3 id="旋转卡壳"><a class="header-anchor" href="#旋转卡壳">¶</a>旋转卡壳</h3>
<h2 id="树形结构"><a class="header-anchor" href="#树形结构">¶</a>树形结构</h2>
<h3 id="线段树"><a class="header-anchor" href="#线段树">¶</a>线段树</h3>
<h4 id="二维线段树"><a class="header-anchor" href="#二维线段树">¶</a>二维线段树</h4>
<h4 id="矩形树"><a class="header-anchor" href="#矩形树">¶</a>矩形树</h4>
<h4 id="zkw线段树"><a class="header-anchor" href="#zkw线段树">¶</a>zkw线段树</h4>
<h4 id="主席树"><a class="header-anchor" href="#主席树">¶</a>主席树</h4>
<h3 id="点分治"><a class="header-anchor" href="#点分治">¶</a>点分治</h3>
<h3 id="平衡树"><a class="header-anchor" href="#平衡树">¶</a>平衡树</h3>
<h4 id="avl"><a class="header-anchor" href="#avl">¶</a>AVL</h4>
<h4 id="treap"><a class="header-anchor" href="#treap">¶</a>Treap</h4>
<h4 id="sbt"><a class="header-anchor" href="#sbt">¶</a>SBT</h4>
<h4 id="splay"><a class="header-anchor" href="#splay">¶</a>Splay</h4>
<h4 id="静态排序树"><a class="header-anchor" href="#静态排序树">¶</a>静态排序树</h4>
<h4 id="替罪羊树"><a class="header-anchor" href="#替罪羊树">¶</a>替罪羊树</h4>
<h3 id="二叉堆"><a class="header-anchor" href="#二叉堆">¶</a>二叉堆</h3>
<h4 id="左偏树"><a class="header-anchor" href="#左偏树">¶</a>左偏树</h4>
<h4 id="斜堆"><a class="header-anchor" href="#斜堆">¶</a>斜堆</h4>
<h4 id="二项堆"><a class="header-anchor" href="#二项堆">¶</a>二项堆</h4>
<h3 id="树状数组"><a class="header-anchor" href="#树状数组">¶</a>树状数组</h3>
<h3 id="cdq分治"><a class="header-anchor" href="#cdq分治">¶</a>cdq分治</h3>
<h3 id="树上距离"><a class="header-anchor" href="#树上距离">¶</a>树上距离</h3>
<h4 id="节点到根的距离"><a class="header-anchor" href="#节点到根的距离">¶</a>节点到根的距离</h4>
<h4 id="最近公共祖先-lca"><a class="header-anchor" href="#最近公共祖先-lca">¶</a>最近公共祖先，LCA</h4>
<h4 id="节点间的距离"><a class="header-anchor" href="#节点间的距离">¶</a>节点间的距离</h4>
<h4 id="树的直径"><a class="header-anchor" href="#树的直径">¶</a>树的直径</h4>
<h3 id="动态树"><a class="header-anchor" href="#动态树">¶</a>动态树</h3>
<h4 id="树链剖分-树剖"><a class="header-anchor" href="#树链剖分-树剖">¶</a>树链剖分，树剖</h4>
<h4 id="link-cut-tree-lct"><a class="header-anchor" href="#link-cut-tree-lct">¶</a>Link-Cut Tree，LCT</h4>
<h3 id="树的应用"><a class="header-anchor" href="#树的应用">¶</a>树的应用</h3>
<h4 id="并查集"><a class="header-anchor" href="#并查集">¶</a>并查集</h4>
<h4 id="树的遍历"><a class="header-anchor" href="#树的遍历">¶</a>树的遍历</h4>
<h4 id="哈夫曼树"><a class="header-anchor" href="#哈夫曼树">¶</a>哈夫曼树</h4>
<h4 id="rmq"><a class="header-anchor" href="#rmq">¶</a>RMQ</h4>
<h4 id="树套树"><a class="header-anchor" href="#树套树">¶</a>树套树</h4>
<h4 id="可持久化"><a class="header-anchor" href="#可持久化">¶</a>可持久化</h4>
<h4 id="虚树"><a class="header-anchor" href="#虚树">¶</a>虚树</h4>
<h3 id="整体二分"><a class="header-anchor" href="#整体二分">¶</a>整体二分</h3>
<h3 id="环套树"><a class="header-anchor" href="#环套树">¶</a>环套树</h3>
<h3 id="k-d-tree"><a class="header-anchor" href="#k-d-tree">¶</a>K-D Tree</h3>
<h2 id="网络流"><a class="header-anchor" href="#网络流">¶</a>网络流</h2>
<h3 id="最大流"><a class="header-anchor" href="#最大流">¶</a>最大流</h3>
<h4 id="dicnic"><a class="header-anchor" href="#dicnic">¶</a>Dicnic</h4>
<h4 id="sap"><a class="header-anchor" href="#sap">¶</a>Sap</h4>
<h4 id="有上下界的最大流"><a class="header-anchor" href="#有上下界的最大流">¶</a>有上下界的最大流</h4>
<h3 id="最小割"><a class="header-anchor" href="#最小割">¶</a>最小割</h3>
<h4 id="闭合图"><a class="header-anchor" href="#闭合图">¶</a>闭合图</h4>
<h4 id="最小点权覆盖集"><a class="header-anchor" href="#最小点权覆盖集">¶</a>最小点权覆盖集</h4>
<h4 id="最大点权独立集"><a class="header-anchor" href="#最大点权独立集">¶</a>最大点权独立集</h4>
<h4 id="分数规划"><a class="header-anchor" href="#分数规划">¶</a>分数规划</h4>
<h4 id="最大密度子图"><a class="header-anchor" href="#最大密度子图">¶</a>最大密度子图</h4>
<h3 id="费用流"><a class="header-anchor" href="#费用流">¶</a>费用流</h3>
<h4 id="最短路增广费用流"><a class="header-anchor" href="#最短路增广费用流">¶</a>最短路增广费用流</h4>
<h4 id="zkw费用流"><a class="header-anchor" href="#zkw费用流">¶</a>zkw费用流</h4>
<h4 id="最小费用可行流"><a class="header-anchor" href="#最小费用可行流">¶</a>最小费用可行流</h4>
<h2 id="基础算法"><a class="header-anchor" href="#基础算法">¶</a>基础算法</h2>
<h3 id="模拟"><a class="header-anchor" href="#模拟">¶</a>模拟</h3>
<h3 id="贪心"><a class="header-anchor" href="#贪心">¶</a>贪心</h3>
<h3 id="递推"><a class="header-anchor" href="#递推">¶</a>递推</h3>
<h3 id="递归"><a class="header-anchor" href="#递归">¶</a>递归</h3>
<h3 id="枚举-暴力"><a class="header-anchor" href="#枚举-暴力">¶</a>枚举，暴力</h3>
<h3 id="分治"><a class="header-anchor" href="#分治">¶</a>分治</h3>
<h2 id="排序"><a class="header-anchor" href="#排序">¶</a>排序</h2>
<h3 id="冒泡排序"><a class="header-anchor" href="#冒泡排序">¶</a>冒泡排序</h3>
<h3 id="选择排序"><a class="header-anchor" href="#选择排序">¶</a>选择排序</h3>
<h3 id="桶排序"><a class="header-anchor" href="#桶排序">¶</a>桶排序</h3>
<h3 id="插入排序"><a class="header-anchor" href="#插入排序">¶</a>插入排序</h3>
<h3 id="归并排序"><a class="header-anchor" href="#归并排序">¶</a>归并排序</h3>
<h3 id="快速排序-快排"><a class="header-anchor" href="#快速排序-快排">¶</a>快速排序，快排</h3>
<h3 id="堆排序"><a class="header-anchor" href="#堆排序">¶</a>堆排序</h3>
<h3 id="希尔排序"><a class="header-anchor" href="#希尔排序">¶</a>希尔排序</h3>
<h3 id="外部排序"><a class="header-anchor" href="#外部排序">¶</a>外部排序</h3>
<h2 id="查找"><a class="header-anchor" href="#查找">¶</a>查找</h2>
<h3 id="二分答案"><a class="header-anchor" href="#二分答案">¶</a>二分答案</h3>
<h3 id="顺序查找"><a class="header-anchor" href="#顺序查找">¶</a>顺序查找</h3>
<h3 id="二分查找"><a class="header-anchor" href="#二分查找">¶</a>二分查找</h3>
<h2 id="二分图"><a class="header-anchor" href="#二分图">¶</a>二分图</h2>
<h3 id="最大匹配"><a class="header-anchor" href="#最大匹配">¶</a>最大匹配</h3>
<h4 id="匈牙利算法"><a class="header-anchor" href="#匈牙利算法">¶</a>匈牙利算法</h4>
<h4 id="一般图的最大匹配"><a class="header-anchor" href="#一般图的最大匹配">¶</a>一般图的最大匹配</h4>
<h4 id="konig定理"><a class="header-anchor" href="#konig定理">¶</a>Konig定理</h4>
<h3 id="带权二分图匹配"><a class="header-anchor" href="#带权二分图匹配">¶</a>带权二分图匹配</h3>
<h3 id="稳定婚姻系统"><a class="header-anchor" href="#稳定婚姻系统">¶</a>稳定婚姻系统</h3>
<h2 id="其他技巧"><a class="header-anchor" href="#其他技巧">¶</a>其他技巧</h2>
<h3 id="暴力数据结构"><a class="header-anchor" href="#暴力数据结构">¶</a>暴力数据结构</h3>
<h3 id="高精"><a class="header-anchor" href="#高精">¶</a>高精</h3>
<h3 id="博弈论"><a class="header-anchor" href="#博弈论">¶</a>博弈论</h3>
<h4 id="nim游戏"><a class="header-anchor" href="#nim游戏">¶</a>Nim游戏</h4>
<h4 id="博弈树"><a class="header-anchor" href="#博弈树">¶</a>博弈树</h4>
<h4 id="shannon开关游戏"><a class="header-anchor" href="#shannon开关游戏">¶</a>Shannon开关游戏</h4>
<h3 id="倍增"><a class="header-anchor" href="#倍增">¶</a>倍增</h3>
<h3 id="离散化"><a class="header-anchor" href="#离散化">¶</a>离散化</h3>
<h3 id="哈希-hash"><a class="header-anchor" href="#哈希-hash">¶</a>哈希，HASH</h3>
<h4 id="elfhash"><a class="header-anchor" href="#elfhash">¶</a>ELFhash</h4>
<h4 id="sdbm"><a class="header-anchor" href="#sdbm">¶</a>SDBM</h4>
<h4 id="bkdr"><a class="header-anchor" href="#bkdr">¶</a>BKDR</h4>
<h3 id="随机贪心-随机化"><a class="header-anchor" href="#随机贪心-随机化">¶</a>随机贪心，随机化</h3>
<h3 id="快速傅里叶变换-dft-fft"><a class="header-anchor" href="#快速傅里叶变换-dft-fft">¶</a>快速傅里叶变换，DFT，FFT</h3>
<h3 id="位运算-按位"><a class="header-anchor" href="#位运算-按位">¶</a>位运算，按位</h3>
<h3 id="骗分"><a class="header-anchor" href="#骗分">¶</a>骗分</h3>
<h3 id="np问题"><a class="header-anchor" href="#np问题">¶</a>NP问题</h3>
<h3 id="构造"><a class="header-anchor" href="#构造">¶</a>构造</h3>
<h3 id="快速数论变换ntt"><a class="header-anchor" href="#快速数论变换ntt">¶</a>快速数论变换NTT</h3>
<h3 id="快速沃尔什变换fwt"><a class="header-anchor" href="#快速沃尔什变换fwt">¶</a>快速沃尔什变换FWT</h3>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/03/214-Shortest-Palindrome/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/03/214-Shortest-Palindrome/" itemprop="url">214. Shortest Palindrome</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-03T20:03:00+08:00">2019-07-03</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>题目描述</h1>
<p><a href="https://leetcode.com/problems/shortest-palindrome/" target="_blank" rel="noopener">214. Shortest Palindrome</a></p>
<p>Difficulty: <strong>Hard</strong></p>
<p>Given a string <em><strong>s</strong></em>, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;aacecaaa&quot;</span><br><span class="line">Output: &quot;aaacecaaa&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abcd&quot;</span><br><span class="line">Output: &quot;dcbabcd&quot;</span><br></pre></td></tr></table></figure>
<h1>解法</h1>
<p>  这道题可以转化成求字符串以左侧边界为起点的“最大回文子串”。</p>
<h2 id="法一"><a class="header-anchor" href="#法一">¶</a>法一</h2>
<p>  暴力解法，先将整个字符串倒转成rev，比较<code>s[0:n-i]</code>和<code>rev[i:]</code>（i从0到n），第一次使<code>s[0:n-i]==rev[i:]</code>的<code>s[0:n-i]</code>就是题目所要求的“最大回文子串”。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">shortestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">rev</span><span class="params">(s)</span></span>;</span><br><span class="line">    reverse(rev.begin(), rev.end());</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.substr(<span class="number">0</span>, n - i) == rev.substr(i))</span><br><span class="line">            <span class="keyword">return</span> rev.substr(<span class="number">0</span>, i) + s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="法二"><a class="header-anchor" href="#法二">¶</a>法二</h2>
<p>  这个解法利用双指针，两个指针分别从头和从尾遍历，尾指针每次左移一位，同时比较头指针和尾指针，如果指向相同的字符，则头指针加一；如果指向不同的字符，则头指针不动。如果头指针在过程的结尾刚好移动到尾部，说明整个字符串是回文串。**这个过程结束后能保证s[0:i]一定包含从字符串头开始的最长回文串。**利用这个结论不断缩小搜索范围，直到整个子串都是回文串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shortestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == n)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="built_in">string</span> remain_rev = s.substr(i);</span><br><span class="line">        reverse(remain_rev.begin(), remain_rev.end());</span><br><span class="line">        <span class="keyword">return</span> remain_rev + shortestPalindrome(s.substr(<span class="number">0</span>, i)) + s.substr(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="法三"><a class="header-anchor" href="#法三">¶</a>法三</h2>
<p>  背景知识:Knuth–Morris–Pratt算法。KMP算法的核心是求出失败索引查找表，也就是前缀数组next。假设<code>f(s)</code>代表在待匹配字符串的第s个字符失配时，下一个查找的起点，亦即下一次就从待匹配字符串的第<code>f(s)</code>个字符开始继续往后比较，也<strong>即是<code>b0b1b2b3b4...bs</code>的前缀也是其后缀的最长子串的长度</strong>。</p>
<p>  KMP求前缀数组的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="number">0</span>) = <span class="number">0</span></span><br><span class="line"><span class="comment">//下面代码中的t要看成前缀长度，别看成坐标，因为坐标是从0开始的</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//假设b0~bi-1匹配，而bi失配，则取f(i-1)（b0~bi-1的最长前后缀长度）的下一个位置和bi继续匹配，如果此时b0~bf(i-1)-1匹配而bf(i-1)失配，则继续上述过程。</span></span><br><span class="line">    t = f(i<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">while</span>(t &gt; <span class="number">0</span> &amp;&amp; b[i] != b[t])</span><br><span class="line">        t = f(t<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">if</span>(b[i] == b[t])&#123;</span><br><span class="line">        ++t</span><br><span class="line">    f(i) = t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  求最长前缀回文串等价于求s+&quot;#&quot;+reverse(s)的最后一个字符的KMP的f值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        S = <span class="string">''</span>.join([s, <span class="string">"#"</span>, s[::<span class="number">-1</span>]])</span><br><span class="line">        f = [<span class="number">0</span>]*len(S)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(S)):</span><br><span class="line">            t = f[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">while</span> t &gt; <span class="number">0</span> <span class="keyword">and</span> S[i] != S[t]:</span><br><span class="line">                t = f[t - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> S[i] == S[t]:</span><br><span class="line">                t += <span class="number">1</span></span><br><span class="line">            f[i] = t</span><br><span class="line">        <span class="keyword">return</span> s[f[len(S) - <span class="number">1</span>]:][::<span class="number">-1</span>]+s</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/01/212-Word-Search-II/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/01/212-Word-Search-II/" itemprop="url">212. Word Search II</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-01T20:13:00+08:00">2019-07-01</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>题目描述</h1>
<p><a href="https://leetcode.com/problems/word-search-ii/" target="_blank" rel="noopener">212. Word Search II</a></p>
<p>Difficulty: <strong>Hard</strong></p>
<p>Given a 2D board and a list of words from the dictionary, find all words in the board.</p>
<p>Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">board = [</span><br><span class="line">  [&apos;o&apos;,&apos;a&apos;,&apos;a&apos;,&apos;n&apos;],</span><br><span class="line">  [&apos;e&apos;,&apos;t&apos;,&apos;a&apos;,&apos;e&apos;],</span><br><span class="line">  [&apos;i&apos;,&apos;h&apos;,&apos;k&apos;,&apos;r&apos;],</span><br><span class="line">  [&apos;i&apos;,&apos;f&apos;,&apos;l&apos;,&apos;v&apos;]</span><br><span class="line">]</span><br><span class="line">words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]</span><br><span class="line"></span><br><span class="line">Output: [&quot;eat&quot;,&quot;oath&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li>All inputs are consist of lowercase letters <code>a-z</code>.</li>
<li>The values of <code>words</code> are distinct.</li>
</ol>
<h1>解法</h1>
<p>  这道题用DFS搜索，用字典树剪枝。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class TrieNode:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.dic = &#123;&#125;</span><br><span class="line">        self.word = &apos;&apos;</span><br><span class="line">​</span><br><span class="line">class Solution:</span><br><span class="line">    def findWords(self, board: List[List[str]], words: List[str]) -&gt; List[str]:</span><br><span class="line">        root = self.buildTrieTree(words)</span><br><span class="line">                </span><br><span class="line">        res = []</span><br><span class="line">        R = len(board)</span><br><span class="line">        C = len(board[0])</span><br><span class="line">        </span><br><span class="line">        cur_visited = [[False] * C for _ in range(R)]</span><br><span class="line">        </span><br><span class="line">        def dfs(i, j, node):</span><br><span class="line">            if i &lt; 0 or i &gt; R - 1 or j &lt; 0 or j &gt; C - 1 or cur_visited[i][j]:</span><br><span class="line">                return</span><br><span class="line">            </span><br><span class="line">            if board[i][j] not in node.dic:</span><br><span class="line">                return</span><br><span class="line">        </span><br><span class="line">            node = node.dic[board[i][j]]</span><br><span class="line">            </span><br><span class="line">            if node.word:</span><br><span class="line">                res.append(node.word)</span><br><span class="line">                node.word = &apos;&apos;</span><br><span class="line">            </span><br><span class="line">            for row, col in (i - 1, j),(i + 1, j),(i, j - 1),(i, j + 1):</span><br><span class="line">                cur_visited[i][j] = True</span><br><span class="line">                dfs(row, col, node)</span><br><span class="line">                cur_visited[i][j] = False</span><br><span class="line">            </span><br><span class="line">        for i in range(R):</span><br><span class="line">            for j in range(C):</span><br><span class="line">                dfs(i, j, root)</span><br><span class="line">                </span><br><span class="line">        return res   </span><br><span class="line">    </span><br><span class="line">    def buildTrieTree(self, words):</span><br><span class="line">        root = TrieNode()</span><br><span class="line">        for word in words:</span><br><span class="line">            p = root</span><br><span class="line">            for ch in word:</span><br><span class="line">                if ch not in p.dic:</span><br></pre></td></tr></table></figure>
<h1>扩展</h1>
<p>  来自大神StefanPochmann的代码，值得学习，特别是建立字典树的过程只用了短短的6行代码，简直太秀了！</p>
<p>  关键点：</p>
<ol>
<li>用复数表示board每个点，当前字符的四个方向上的相邻位置即<code>z + 1j**k,0 &lt;= k &lt;= 3</code>。</li>
<li>字典树节点用字典表示，并且用（None，True）键值对表示该节点是单词的情况，同时在遍历过一个节点后设置<code>board[i][j]=None</code>，每次递归调用DFS会把字典树节点中的None弹出字典后再判断当前字符是否在字典节点中，所以即使当前字符是None，也不用担心会因为搜到单词节点中有None（因为会在<code>if c in node</code>之前弹出None）而重复搜索之前搜索过的节点，这也是很巧妙的一点！</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findWords</span><span class="params">(self, board, words)</span>:</span></span><br><span class="line"></span><br><span class="line">			<span class="comment"># 字典树建立</span></span><br><span class="line">        root = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            node = root</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">                node = node.setdefault(c, &#123;&#125;)</span><br><span class="line">            node[<span class="literal">None</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 将坐标转化成复数</span></span><br><span class="line">        board = &#123;i + <span class="number">1j</span>*j: c</span><br><span class="line">                 <span class="keyword">for</span> i, row <span class="keyword">in</span> enumerate(board)</span><br><span class="line">                 <span class="keyword">for</span> j, c <span class="keyword">in</span> enumerate(row)&#125;</span><br><span class="line"></span><br><span class="line">        found = []</span><br><span class="line">        <span class="comment"># DFS搜索</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(node, z, word)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> node.pop(<span class="literal">None</span>, <span class="literal">None</span>):</span><br><span class="line">                found.append(word)</span><br><span class="line">            c = board.get(z)</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> node:</span><br><span class="line">                board[z] = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">                    search(node[c], z + <span class="number">1j</span>**k, word + c)</span><br><span class="line">                board[z] = c</span><br><span class="line">        <span class="keyword">for</span> z <span class="keyword">in</span> board:</span><br><span class="line">            search(root, z, <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> found</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/01/158-Read-N-Characters-Given-Read4-II/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/01/158-Read-N-Characters-Given-Read4-II/" itemprop="url">158. Read N Characters Given Read4 II</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-01T11:28:00+08:00">2019-07-01</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>题目描述</h1>
<p>The API: int read4(char *buf) reads 4 characters at a time from a file.</p>
<p>The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.</p>
<p>By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.</p>
<p>The read function may be called multiple times.</p>
<p>Example 1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;filetestbuffer&quot;</span><br><span class="line">read(6)</span><br><span class="line">read(5)</span><br><span class="line">read(4)</span><br><span class="line">read(3)</span><br><span class="line">read(2)</span><br><span class="line">read(1)</span><br><span class="line">read(10)</span><br><span class="line">Output:</span><br><span class="line">6, buf = &quot;filete&quot;</span><br><span class="line">5, buf = &quot;stbuf&quot;</span><br><span class="line">3, buf = &quot;fer&quot;</span><br><span class="line">0, buf = &quot;&quot;</span><br><span class="line">0, buf = &quot;&quot;</span><br><span class="line">0, buf = &quot;&quot;</span><br><span class="line">0, buf = &quot;&quot;</span><br></pre></td></tr></table></figure>
<p>Example 2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;abcdef&quot;</span><br><span class="line">read(1)</span><br><span class="line">read(5)</span><br><span class="line">Output:</span><br><span class="line">1, buf = &quot;a&quot;</span><br><span class="line">5, buf = &quot;bcdef&quot;</span><br></pre></td></tr></table></figure>
<h1>解法：</h1>
<p>  这道题的解法三把我看呆了，为什么别人的解法可以这么简洁明了？！</p>
<h2 id="法一"><a class="header-anchor" href="#法一">¶</a>法一</h2>
<p>  把所有字符都一次性读出来，然后用两个数记录当前读到的位置和剩余的未读的字符数，这是最暴力的解法了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">The read4 API is already defined for you.</span></span><br><span class="line"><span class="string">@param buf a list of characters</span></span><br><span class="line"><span class="string">@return an integer</span></span><br><span class="line"><span class="string">you can call Reader.read4(buf)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.allchar = []</span><br><span class="line">        self.remainchar = <span class="number">0</span></span><br><span class="line">        self.cur = <span class="number">0</span></span><br><span class="line">        temp = [<span class="number">0</span>] * <span class="number">4</span></span><br><span class="line">        readed = <span class="number">4</span></span><br><span class="line">        <span class="keyword">while</span> readed == <span class="number">4</span>:</span><br><span class="line">            readed = Reader.read4(temp)</span><br><span class="line">            self.allchar.extend(temp[:readed])</span><br><span class="line">            self.remainchar += readed</span><br><span class="line">        <span class="comment"># print(self.allchar)</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># @param &#123;char[]&#125; buf destination buffer</span></span><br><span class="line">    <span class="comment"># @param &#123;int&#125; n maximum number of characters to read</span></span><br><span class="line">    <span class="comment"># @return &#123;int&#125; the number of characters read</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self, buf, n)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; self.remainchar:</span><br><span class="line">            buf[:n] = self.allchar[self.cur:self.cur+n]</span><br><span class="line">            self.cur += n</span><br><span class="line">            self.remainchar -= n</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            buf[:self.remainchar] = self.allchar[self.cur:self.cur+self.remainchar]    </span><br><span class="line">            tempv = self.remainchar</span><br><span class="line">            self.cur += self.remainchar</span><br><span class="line">            self.remainchar = <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> tempv</span><br></pre></td></tr></table></figure>
<h2 id="法二"><a class="header-anchor" href="#法二">¶</a>法二</h2>
<p>  用self.remain保存上一次读取的4个字符中剩下来的字符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">The read4 API is already defined for you.</span></span><br><span class="line"><span class="string">@param buf a list of characters</span></span><br><span class="line"><span class="string">@return an integer</span></span><br><span class="line"><span class="string">you can call Reader.read4(buf)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.remain = [] <span class="comment"># record the unreaded characters of previous round of read</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># @param &#123;char[]&#125; buf destination buffer</span></span><br><span class="line">    <span class="comment"># @param &#123;int&#125; n maximum number of characters to read</span></span><br><span class="line">    <span class="comment"># @return &#123;int&#125; the number of characters read</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self, buf, n)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        readed = <span class="number">0</span> <span class="comment"># counter of characters already readed into buf</span></span><br><span class="line">        temp = [<span class="number">0</span>] * <span class="number">4</span> <span class="comment"># buf for read4</span></span><br><span class="line">        <span class="comment"># print(self.remain)</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &gt; len(self.remain):</span><br><span class="line">            <span class="keyword">if</span> len(self.remain):</span><br><span class="line">                n -= len(self.remain)</span><br><span class="line">                buf[:len(self.remain)] = self.remain</span><br><span class="line">                readed += len(self.remain)</span><br><span class="line">                self.remain = []</span><br><span class="line">                <span class="comment"># print(buf)</span></span><br><span class="line">        </span><br><span class="line">            <span class="keyword">while</span> n &gt;= <span class="number">4</span>:</span><br><span class="line">                returnn = Reader.read4(temp)</span><br><span class="line">                buf[readed:readed+returnn] = temp</span><br><span class="line">                readed += returnn</span><br><span class="line">                <span class="keyword">if</span> returnn &lt; <span class="number">4</span>:</span><br><span class="line">                    <span class="keyword">return</span> readed</span><br><span class="line">                n -= <span class="number">4</span></span><br><span class="line">            <span class="keyword">if</span> n:</span><br><span class="line">                returnn = Reader.read4(temp)</span><br><span class="line">                <span class="keyword">if</span> n &gt;= returnn:</span><br><span class="line">                    buf[readed:readed+returnn] = temp</span><br><span class="line">                    readed += returnn</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    buf[readed:readed+n] = temp[:n]</span><br><span class="line">                    readed += n</span><br><span class="line">                    self.remain = temp[n:returnn]</span><br><span class="line">            <span class="keyword">return</span> readed</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            buf[:n] = self.remain[:n]</span><br><span class="line">            self.remain = self.remain[n:]</span><br><span class="line">            <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure>
<h2 id="法三"><a class="header-anchor" href="#法三">¶</a>法三</h2>
<p>  这个解法才是最让我醍醐灌顶的解法。用大小为4的数组（记为buff）存放read4的返回结果，readpos和writepos记录当前读到的字符的位置和最后一个字符的位置。如果readpos和writepos相等，说明读到buff的结束了，就再调用read4，并将reapos放回buff的起点，writepos放在read4返回值对应的位置上（也是buff中来自刚刚这次read4调用的最后一个有效字符的位置）。每次调用read4之后检查writepos，如果为0，说明所有字符都读完了，就直接返回。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.buff = [<span class="number">0</span>] * <span class="number">4</span> <span class="comment"># record the unreaded characters of previous round of read</span></span><br><span class="line">        self.readpos = <span class="number">0</span></span><br><span class="line">        self.writepos = <span class="number">0</span></span><br><span class="line">    <span class="comment"># @param &#123;char[]&#125; buf destination buffer</span></span><br><span class="line">    <span class="comment"># @param &#123;int&#125; n maximum number of characters to read</span></span><br><span class="line">    <span class="comment"># @return &#123;int&#125; the number of characters read</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self, buf, n)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            <span class="keyword">if</span> self.readpos == self.writepos:</span><br><span class="line">                self.writepos = Reader.read4(self.buff)</span><br><span class="line">                self.readpos = <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> self.writepos == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            buf[i] = self.buff[self.readpos]</span><br><span class="line">            i, self.readpos = i + <span class="number">1</span>, self.readpos + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">lidanyang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">60</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">40</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/lidanyang" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1261727840@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lidanyang</span>

  

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.0.0</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.0"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
