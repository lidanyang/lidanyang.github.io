<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.0" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="分类">
<meta property="og:url" content="http://yoursite.com/categories/index.html">
<meta property="og:site_name" content="Just a blog">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-05-28T06:22:34.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="分类">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/categories/">





  <title>Just a blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Just a blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/25/C-Primer学习笔记：第19章-特殊工具与技术/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/25/C-Primer学习笔记：第19章-特殊工具与技术/" itemprop="url">C++ Primer学习笔记：第19章 特殊工具与技术</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-25T15:55:00+08:00">2019-07-25</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>19.1 控制内存分配</h1>
<h2 id="19-1-1-重载new和delete"><a class="header-anchor" href="#19-1-1-重载new和delete">¶</a>19.1.1 重载new和delete</h2>
<ul>
<li>
<p>operator new接口和operator delete接口</p>
<ul>
<li>operator new先调用operator new分配原始内存，然后调用构造函数，最后返回对象指针；operator delete先执行析构函数，然后调用operator delete释放空间；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可能抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span></span>; <span class="comment">//分配一个对象</span></span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span>); <span class="comment">//分配一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *)</span> <span class="keyword">noexcept</span></span>; <span class="comment">//释放一个对象</span></span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span> *) <span class="keyword">noexcept</span>; <span class="comment">//释放一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//承诺不抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span></span>; <span class="comment">//分配一个对象</span></span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span>, <span class="keyword">nothrow_t</span>&amp;) <span class="keyword">noexcept</span>; <span class="comment">//分配一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span></span>; <span class="comment">//释放一个对象</span></span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span> *, <span class="keyword">nothrow_t</span>&amp;) <span class="keyword">noexcept</span>; <span class="comment">//释放一个数组</span></span><br></pre></td></tr></table></figure>
<ul>
<li>应用程序可以自定义上面函数版本任意一个，前提是自定义版本必须位于全局作用域或者类作用域中；定义成类的成员，它们是隐式静态的，并且它们<strong>不能操纵类的任何数据成员</strong>。</li>
<li>对operator new来说，返回类型必须是void *，第一个形参必须是size_t，不能有默认实参。可以提供额外形参，此时用这些自定义函数的new表达式必须使用new的定位形式将实参传递给新增的形参。<code>void *operator new(size_t, void *)</code>不能被用户重载；</li>
<li>对operator delete来说，返回类型必须是void，第一个形参类型必须是void*；当定义成类的成员时，可以包含另一个size_t形参，此时是第一个形参所指对象的字节数，可以用于删除继承体系中的对象</li>
</ul>
<blockquote>
<p>operator new和delete并没有重载new和delete表达式</p>
</blockquote>
</li>
<li>
<p>malloc函数和free函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">void</span> *mem = <span class="built_in">malloc</span>(size))</span><br><span class="line">        <span class="keyword">return</span> mem;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> bad_alloc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *mem)</span> <span class="keyword">noexcept</span> </span>&#123; <span class="built_in">free</span>(mem); &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="19-1-2-定位new表达式"><a class="header-anchor" href="#19-1-2-定位new表达式">¶</a>19.1.2 定位new表达式</h2>
<blockquote>
<p>C++早期版本，allocator类还不是标准库一部分；</p>
<p>operator new和operator delete与allocator的allocate和deallocate成员类似， 只分配和释放空间，不构造和销毁对象；</p>
<p>对于operator new分配的空间无法使用construct构造对象，应该用new的<strong>定位new</strong>形式构造对象；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">new</span> (place_address) type;</span><br><span class="line">&gt; <span class="keyword">new</span> (place_address) type (initializers);</span><br><span class="line">&gt; <span class="keyword">new</span> (place_address) type [size];</span><br><span class="line">&gt; <span class="keyword">new</span> (place_address) type [size] &#123; braced initializer <span class="built_in">list</span> &#125;;</span><br><span class="line">&gt; <span class="comment">//place_address是一个指针，initializer是初始值列表</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">//当只传入一个指针类型的实参，定位new表达式构造对象但是不分配内存</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">//定位new和allocator的construct的一个区别：传递给construct的指针必须指向同一个allocator对象分配的空间，但是传给定位new的指针无须指向operator new分配的内存，甚至不需要指向动态内存；</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>
<p>显示的析构函数调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *sp = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"a value"</span>);</span><br><span class="line">sp-&gt;~<span class="built_in">string</span>();</span><br></pre></td></tr></table></figure>
<p><strong>调用析构函数会销毁对象，但是不会释放内存</strong></p>
</li>
</ul>
<h1>19.2 运行时类型识别</h1>
<p>RTTI，run-time type identification</p>
<ul>
<li>typeid，返回表达式类型</li>
<li>dynamic_cast，将基类指针或引用安全转换成派生类指针或引用</li>
</ul>
<h2 id="19-2-1-dynamic-cast运算符"><a class="header-anchor" href="#19-2-1-dynamic-cast运算符">¶</a>19.2.1 dynamic_cast运算符</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic_cast</span>&lt;type *&gt;(e);</span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;type&amp;&gt;(e);</span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;type&amp;&amp;&gt;(e);<span class="comment">//e不能是左值</span></span><br><span class="line"><span class="comment">//e必须是目标type的共有派生类、目标type的公有基类或者目标type的类型</span></span><br><span class="line"><span class="comment">//转换目标是指针类型且失败，则结果为0；如果目标是引用类型且失败，则抛出bad_cast异常</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>指针类型的dynamic_cast</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Derived *dp = <span class="keyword">dynamic_cast</span>&lt;Derived *&gt;(bp))&#123;</span><br><span class="line">    <span class="comment">//使用dp指向的Derived对象</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//使用bp指向的Base对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以对一个空指针执行dynamic_cast，结果是所需类型的空指针</span></span><br><span class="line"><span class="comment">//在条件部分执行dynamic_cast可以确保类型转换和结果检查在同一表达式中完成</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>引用类型的dynamic_cast</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> Base &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> Derived &amp;d = <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> Derived&amp;&gt;(b);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (bad_cast) &#123;<span class="comment">//bad_cast异常定义在typeinfo标准库头文件中</span></span><br><span class="line">        <span class="comment">//处理失败</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="19-2-2-typeid运算符"><a class="header-anchor" href="#19-2-2-typeid运算符">¶</a>19.2.2 typeid运算符</h2>
<blockquote>
<p><code>typeid(e)</code>的结果是一个常量对象的引用，该对象的类型是标准库类型<code>type_info</code>或者<code>type_info</code>的公有派生类型；</p>
<p><code>typeid</code>可以作用于任意类型的表达式；</p>
<p>顶层const被忽略；</p>
<p>typeid作用于数组或函数时，不执行向指针的标准转换；</p>
<p>当运算对象不属于类类型或者是一个不包含任何虚函数的类，typeid运算符指示的是运算对象的静态类型；</p>
<p>当运算对象定义了至少一个虚函数的类的左值时，typeid的结果直到运行时才会求得；</p>
</blockquote>
<ul>
<li>
<p>使用typeid运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeid</span>(bp) == <span class="keyword">typeid</span>(Derived)) &#123;</span><br><span class="line">    <span class="comment">//此处永远不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当<code>typeid</code>作用于指针而非指针所指的对象时，返回的结果是该指针的静态编译时类型</p>
</blockquote>
<p>typeid是否需要运行时检查决定了表达式是否会被求值</p>
</li>
</ul>
<h2 id="19-2-3-使用rtti"><a class="header-anchor" href="#19-2-3-使用rtti">¶</a>19.2.3 使用RTTI</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Base&amp;, <span class="keyword">const</span> Base&amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//Base接口成员</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">const</span> Base&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//Base的数据成员和其他用于实现的成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//Derived的其他接口成员</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">const</span> Base&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//Derived的数据成员和其他用于实现的成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Base &amp;lhs, <span class="keyword">const</span> Base &amp;rhs)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeid</span>(lhs) == <span class="keyword">typeid</span>(rhs) &amp;&amp; lhs.equal(rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Derived::equal(<span class="keyword">const</span> Base &amp;rhs) <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> r = <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> Derived&amp;&gt;(rhs);</span><br><span class="line">    <span class="comment">//比较两个Derived对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Base::equal(<span class="keyword">const</span> Base &amp;rhs) <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">//执行比较Base对象的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="19-2-4-type-info类"><a class="header-anchor" href="#19-2-4-type-info类">¶</a>19.2.4 type_info类</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t1 == t2;</span><br><span class="line">t1 != t2</span><br><span class="line">t.name(); <span class="comment">//返回C风格字符串</span></span><br><span class="line">t1.before(t2);</span><br><span class="line"><span class="comment">//type_info类一般作为基类出现，还应该提供一个公有的虚析构函数</span></span><br><span class="line"><span class="comment">//type_info没有默认构造函数，拷贝移动构造以及赋值运算符都被定义成删除的，所以无法定义或拷贝type_info对象，也不能为type_info对象赋值，只能通过typeid来创建</span></span><br><span class="line"><span class="comment">//type_info类在不同编译器上有所区别，有的提供了额外的成员函数以提供额外类型信息</span></span><br></pre></td></tr></table></figure>
<h1>19.3 枚举类型</h1>
<p>限定作用域和不限定作用域的枚举类型</p>
<ul>
<li>
<p>枚举成员</p>
<ul>
<li>作用域</li>
<li>枚举成员是const</li>
</ul>
</li>
<li>
<p>和类一样，枚举也定义新的类型</p>
<ul>
<li>必须使用对应类型的枚举成员或另一个对象为enum对象初始化或赋值；</li>
<li>限定作用域的枚举类型不会隐式转化为int，而不限定作用域的枚举类型的成员可以；</li>
</ul>
</li>
<li>
<p>指定enum的大小</p>
<ul>
<li>
<p><strong>不限定作用域</strong>的枚举类型，成员不存在默认类型，只知道成员的潜在类型足够大；</p>
</li>
<li>
<p>如果没有指定enum的潜在类型，默认情况下，<strong>限定作用域</strong>的enum成员类型是int；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> intValues : <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>枚举类型的前置声明</p>
<p>可以提前声明enum，但是必须（显示或隐式）指定成员大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不限定作用域的枚举类型intValues的前置声明</span></span><br><span class="line"><span class="keyword">enum</span> intValues : <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;<span class="comment">//不限定作用域的，必须指定成员类型</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">open_modes</span>;</span> <span class="comment">//限定作用域的枚举类型可以使用默认成员类型int</span></span><br></pre></td></tr></table></figure>
<p>声明和定义必须匹配，成员大小必须一致</p>
</li>
<li>
<p>形参匹配与枚举类型</p>
<p>不能直接将整型值传给enum形参，但是可以将一个<strong>不限定作用域的枚举类型的对象或枚举成员传给整型形参</strong>，此时enum的值提升成int或更大整型，实际提升结果由枚举类型潜在类型决定（潜在类型如果是unsigned char，则枚举成员永远不会提升成unsigned char，而是提升成int）</p>
</li>
</ul>
<h1>19.4 类成员指针</h1>
<blockquote>
<p>成员指针是指可以指向类的非静态成员的指针；</p>
<p>类的静态成员不属于任何对象，因此无须特殊的指向静态成员的指针，指向静态成员的指针和普通指针没什么区别；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line">&gt; <span class="keyword">public</span>:</span><br><span class="line">&gt;     <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span>::size_type pos;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">char</span> <span class="title">get_cursor</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> contents[cursor]; &#125;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">char</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">char</span> <span class="title">get</span><span class="params">(pos ht, pos wd)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&gt; <span class="keyword">private</span>:</span><br><span class="line">&gt;     <span class="built_in">std</span>::<span class="built_in">string</span> contents;</span><br><span class="line">&gt;     pos cursor;</span><br><span class="line">&gt;     pos height, width;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; <span class="comment">//当初始化一个成员指针，我们令其指向类的某个类的成员，但是不指定该成员所属的对象；直到使用成员指针时，才提供成员所属的对象</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="19-4-1-数据成员指针"><a class="header-anchor" href="#19-4-1-数据成员指针">¶</a>19.4.1 数据成员指针</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Screen::*pdata;</span><br><span class="line">pdata = &amp;Screen::contents; <span class="comment">//作用于类的成员而非内存中的该类的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//更简单的声明成员指针的方法</span></span><br><span class="line"><span class="keyword">auto</span> pdata = &amp;Screen::contents;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>使用数据成员指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有当解引用成员指针时才提供对象的信息</span></span><br><span class="line">Screen myScreen, *pScreen = &amp;myScreen;</span><br><span class="line"><span class="keyword">auto</span> s = myScreen.*pdata;</span><br><span class="line">s = pScreen-&gt;*pdata;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>返回数据成员指针的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解决数据成员一般情况下是私有的的问题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> Screen::*data()</span><br><span class="line">    &#123; <span class="keyword">return</span> &amp;Screen::contents; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//data()返回一个指向Screen类的contents成员的指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Screen::*pdata = Screen::data();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得myScreen对象的contents成员</span></span><br><span class="line"><span class="keyword">auto</span> s = myScreen.*pdata;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="19-4-2-成员函数指针"><a class="header-anchor" href="#19-4-2-成员函数指针">¶</a>19.4.2 成员函数指针</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pmf = &amp;Screen::get_cursor; <span class="comment">//pmf是一个指针，可以指向Screen的某个常量成员函数</span></span><br><span class="line"><span class="comment">//前提是该函数不接受任何实参，并返回一个char</span></span><br><span class="line"><span class="keyword">char</span> (Screen::*pmf2)(Screen::pos, Screen::pos) <span class="keyword">const</span>; <span class="comment">//Screen::*两端的括号不可少，普通函数不能使用const限定符</span></span><br><span class="line">pmf2 = &amp;Screen::get;</span><br><span class="line"></span><br><span class="line">pmf = &amp;Screen::get; <span class="comment">//&amp;不可少</span></span><br><span class="line">pmf = Screen::get; <span class="comment">//错误：在成员函数和指针之间不存在自动转换规则</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>使用成员函数指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Screen myScreen, *pScreen = &amp;myScreen;</span><br><span class="line"><span class="keyword">char</span> c1 = (pScreen-&gt;*pmf)();</span><br><span class="line"><span class="keyword">char</span> c2 = (myScreen.*pmf2)(<span class="number">0</span>, <span class="number">0</span>);<span class="comment">//调用优先级高于指针指向成员运算符的优先级</span></span><br><span class="line"><span class="comment">//（C::*p)(parms)和(obj.*p)(args)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用成员指针的类型别名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Action = <span class="keyword">char</span> (Screen::*)(Screen::pos, Screen::pos) <span class="keyword">const</span>;</span><br><span class="line">Action get = &amp;Screen::get;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作为某个函数的返回类型或形参类型</span></span><br><span class="line"><span class="function">Screen&amp; <span class="title">action</span><span class="params">(Screen&amp;, Action = &amp;Screen::get)</span></span>;</span><br><span class="line"></span><br><span class="line">Screen myScreen;</span><br><span class="line">action(myScreen);</span><br><span class="line">action(myScreen, get);</span><br><span class="line">action(myScreen, &amp;Screen::get);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>成员指针函数表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Screen&amp; <span class="title">home</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Screen&amp; <span class="title">forward</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Screen&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Screen&amp; <span class="title">up</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Screen&amp; <span class="title">down</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">using</span> Action = Screen&amp; (Screen::*)();</span><br><span class="line">    <span class="keyword">enum</span> Directions &#123; HOME, FORWARD, BACK, UP, DOWN &#125;;</span><br><span class="line">    <span class="function">Screen&amp; <span class="title">move</span><span class="params">(Directions)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Action Menu[];<span class="comment">//函数表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Screen&amp; Screen::move(Directions cm)&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;*Menu[cm])(); <span class="comment">//Menu[cm]指向一个成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Screen::Action Screen::Menu[] = &#123;&amp;Screen::home,</span><br><span class="line">                                &amp;Screen::forward,</span><br><span class="line">                                &amp;Screen::back,</span><br><span class="line">                                &amp;Screen::up,</span><br><span class="line">                                &amp;Screen::down,</span><br><span class="line">                                &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="19-4-3-将成员函数用作可调用对象"><a class="header-anchor" href="#19-4-3-将成员函数用作可调用对象">¶</a>19.4.3 将成员函数用作可调用对象</h2>
<blockquote>
<p>要想通过一个指向成员函数的指针进行函数调用，必须首先用.*或-&gt;*将该指针绑定到特定对象上；</p>
<p>成员指针不是可调用对象；</p>
</blockquote>
<ul>
<li>
<p>使用function生成一个可调用对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="keyword">bool</span> (<span class="keyword">const</span> <span class="built_in">string</span>&amp;)&gt; fcn = &amp;<span class="built_in">string</span>::empty;</span><br><span class="line">find_if(svec.begin(), svec.end(), fcn);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>*&gt; pvec;</span><br><span class="line">function&lt;<span class="keyword">bool</span> (<span class="keyword">const</span> <span class="built_in">string</span>*)&gt; fp = &amp;<span class="built_in">string</span>::empty;</span><br><span class="line">find_if(pvec.begin(), pvec.end(), fcn);</span><br><span class="line"><span class="comment">//定义一个function对象时，必须指定该对象所能表示的函数类型，即可调用对象的形式。如果可调用对象是一个成员函数，则第一个形参必须表示该成员是在哪个对象上执行的。必须在function指出对象是否是以指针或引用形式传入的</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用mem_fn生成一个可调用对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据成员指针的类型推断可调用对象的类型，而无须用户显示地指定</span></span><br><span class="line">find_if(svec.begin(), svec.end(), mem_fn(&amp;<span class="built_in">string</span>::empty));</span><br><span class="line"></span><br><span class="line"><span class="comment">//mem_fn生成的可调用对象可以通过对象调用，也可以通过指针调用</span></span><br><span class="line"><span class="keyword">auto</span> f = mem_fn(&amp;<span class="built_in">string</span>::empty);</span><br><span class="line">f(*svec.begin()); <span class="comment">//f使用.*调用empty</span></span><br><span class="line">f(&amp;svec[<span class="number">0</span>]); <span class="comment">//f使用-&gt;*调用empty</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用bind生成一个可调用对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = find_if(svec.begin(), svec.end(),</span><br><span class="line">                 bind(&amp;<span class="built_in">string</span>::empty, _1));<span class="comment">//必须将函数中用于表示执行对象的隐式形参转换成显示的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f = bind(&amp;<span class="built_in">string</span>::empty, _1);</span><br><span class="line">f(*svec.begin());</span><br><span class="line">f(&amp;svec[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>19.5 嵌套类</h1>
<blockquote>
<p>是一个独立的类，与外层类基本没什么关系；</p>
<p>嵌套类的名字在外层类作用域中是可见的，在外层类作用域之外不可见；</p>
<p>嵌套类中成员的种类和非嵌套类是一样的；</p>
<p>嵌套类在其外层类中定义了一个类型成员；</p>
</blockquote>
<ul>
<li>
<p>声明一个嵌套类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextQuery</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">QueryResult</span>;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在外层类之外定义一个嵌套类</p>
<p>嵌套类必须声明在类的内部，但是可以定义在类的内部或外部</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextQuery</span>:</span>:QueryResult&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp;</span><br><span class="line">        print(<span class="built_in">std</span>::ostream&amp;, <span class="keyword">const</span> QueryResult&amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    QueryResult(<span class="built_in">std</span>::<span class="built_in">string</span>, </span><br><span class="line">               <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;line_no&gt;&gt;,</span><br><span class="line">               <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt;);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在嵌套类在其外层类之外完成真正的定义前，它都是一个不完全类型</p>
</blockquote>
</li>
<li>
<p>定义嵌套类的成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TextQuery::QueryResult::QueryResult(<span class="built_in">string</span> s,</span><br><span class="line">                <span class="built_in">shared_ptr</span>&lt;<span class="built_in">set</span>&lt;line_no&gt;&gt; p,</span><br><span class="line">                <span class="built_in">shared_ptr</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; f) :</span><br><span class="line">		sought(s), lines(p), file(f) &#123; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>嵌套类的静态成员定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> TextQuery::QueryResult::static_mem = <span class="number">1024</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>嵌套类作用域中的名字查找</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TextQuery::QueryResult</span><br><span class="line">TextQuery::query(<span class="keyword">const</span> <span class="built_in">string</span> &amp;sought) <span class="keyword">const</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">shared_ptr</span>&lt;<span class="built_in">set</span>&lt;line_no&gt;&gt; nodata(<span class="keyword">new</span> <span class="built_in">set</span>&lt;line_no&gt;);</span><br><span class="line">	<span class="keyword">auto</span> loc = wm.find(sought);</span><br><span class="line">	<span class="keyword">if</span> (loc == wm.end())</span><br><span class="line">		<span class="keyword">return</span> QueryResult(sought, nodata, file);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> QueryResult(sought, loc-&gt;second, file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>嵌套类和外层类是互相独立的</p>
</li>
</ul>
<h1>19.6 union：一种节省空间的类</h1>
<blockquote>
<p>union不能含有引用类型成员；</p>
<p>union可以为其成员指定public、protected和private等保护标记；</p>
<p>union可以定义包括构造函数和析构函数在内的成员函数；</p>
<p>union不能作为基类，也不能作为派生类使用，所以不能含有虚函数；</p>
</blockquote>
<ul>
<li>
<p>定义union</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> Token &#123;</span><br><span class="line">    <span class="comment">//默认情况下成员是公有的</span></span><br><span class="line">    <span class="keyword">char</span> cval;</span><br><span class="line">    <span class="keyword">int</span> ival;</span><br><span class="line">    <span class="keyword">double</span> dval;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用union类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Token first_token = &#123;<span class="string">'a'</span>&#125;;</span><br><span class="line">Token last_token;</span><br><span class="line">Token *pt = <span class="keyword">new</span> Token;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>匿名union</p>
<blockquote>
<p>匿名union不能包含受保护的成员或私有成员，也不能定义成员函数；</p>
<p>在匿名union的定义所在的作用域内该union成员都是可以直接访问的；</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">char</span> cval;</span><br><span class="line">    <span class="keyword">int</span> ival;</span><br><span class="line">    <span class="keyword">double</span> dval;</span><br><span class="line">&#125;; <span class="comment">//定义一个未命名的对象，我们可以直接访问它的成员</span></span><br><span class="line">cval = <span class="string">'c'</span>;</span><br><span class="line">ival = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>含有类类型成员的union</p>
<p>string类定义了五个拷贝控制成员和一个默认构造函数。如果union含有string类型的成员，并没有自定义默认构造函数或某个拷贝控制成员，则编译器将合成缺少的成员并将其声明为删除的；</p>
<p>如果在某个类中含有一个union成员，而且该union含有删除的拷贝控制成员，则该类与之对应的拷贝控制操作也将是删除的；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  base()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"base()"</span> &lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">  ~base()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~base()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">union</span> tu&#123;</span><br><span class="line">base b;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tu t;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上述代码编译会出错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  base()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"base()"</span> &lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">  ~base()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~base()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">union</span> tu&#123;</span><br><span class="line">base b;</span><br><span class="line">tu() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"tu()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">~tu()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~tu()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> tu t;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译正确，但是对于b不会运行其构造和析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  base()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"base()"</span> &lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">  ~base()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~base()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">union</span> tu&#123;</span><br><span class="line">base b;</span><br><span class="line">tu() ：b() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"tu()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">~tu()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~tu()"</span> &lt;&lt; <span class="built_in">endl</span>;b.~base();&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> tu t;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若要完成b的构造及析构，需要显示指定</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用类管理union成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Token():tok(INT),ival(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">	Token(<span class="keyword">const</span> Token&amp; t) :tok(t.tok)</span><br><span class="line">	&#123;</span><br><span class="line">		copyUnion(t);</span><br><span class="line">	&#125;</span><br><span class="line">	Token &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Token&amp;);</span><br><span class="line"> </span><br><span class="line">	~Token() &#123;</span><br><span class="line">		<span class="keyword">if</span> (tok == STR)</span><br><span class="line">			sval.~<span class="built_in">string</span>();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	Token&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">string</span>&amp;);</span><br><span class="line">	Token&amp; <span class="keyword">operator</span>=(<span class="keyword">char</span>);</span><br><span class="line">	Token&amp; <span class="keyword">operator</span>=(<span class="keyword">int</span>);</span><br><span class="line">	Token&amp; <span class="keyword">operator</span>=(<span class="keyword">double</span>);</span><br><span class="line">	</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">enum</span>&#123; INT,CHAR,DBL,STR&#125;tok;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">char</span> cval;</span><br><span class="line">		<span class="keyword">int</span> ival;</span><br><span class="line">		<span class="keyword">double</span> dval;</span><br><span class="line">		<span class="built_in">string</span> sval;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">copyUnion</span><span class="params">(<span class="keyword">const</span> Token&amp;)</span></span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>管理判别式并销毁string</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Token&amp; Token::<span class="keyword">operator</span>=(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (tok == STR)</span><br><span class="line">		sval.~<span class="built_in">string</span>();</span><br><span class="line">	ival = i;</span><br><span class="line">	tok = INT;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Token&amp; Token::<span class="keyword">operator</span>=(<span class="keyword">char</span> c)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (tok == STR)</span><br><span class="line">		sval.~<span class="built_in">string</span>();</span><br><span class="line">	cval = c;</span><br><span class="line">	tok = CHAR;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Token&amp; Token::<span class="keyword">operator</span>=(<span class="keyword">double</span> d)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (tok == STR)</span><br><span class="line">		sval.~<span class="built_in">string</span>();</span><br><span class="line">	dval = d;</span><br><span class="line">	tok = DBL;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Token&amp; Token::<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (tok == STR)</span><br><span class="line">		sval = s;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">new</span>(&amp;sval) <span class="built_in">string</span>(s);</span><br><span class="line">	tok = STR;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>管理需要拷贝控制的联合成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Token::copyUnion(<span class="keyword">const</span> Token&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (t.tok)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> Token::INT: ival = t.ival; <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> Token::CHAR: cval = t.cval; <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> Token::DBL: dval = t.dval; <span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//因为默认是直接初始化的ival ,所union中不存在string,因为直接placement new </span></span><br><span class="line">	<span class="keyword">case</span> Token::STR: <span class="keyword">new</span> (&amp;sval) <span class="built_in">string</span>(t.sval); <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">Token&amp; Token::<span class="keyword">operator</span>=(<span class="keyword">const</span> Token&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (tok == STR &amp;&amp; t.tok != STR)</span><br><span class="line">		sval.~<span class="built_in">string</span>();</span><br><span class="line">	<span class="keyword">if</span> (tok == STR &amp;&amp; t.tok == STR)</span><br><span class="line">		sval = t.sval;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		copyUnion(t);  <span class="comment">//左侧没有string </span></span><br><span class="line">	tok = t.tok;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>19.7 局部类</h1>
<blockquote>
<p>局部类成员受到严格限制；</p>
<p>局部类所有成员必须完整定义在类内部；</p>
<p>局部类中不允许声明静态数据成员；</p>
</blockquote>
<ul>
<li>
<p>局部类不能使用函数作用域中的变量</p>
<p>局部类只能访问外层作用域中定义的类型名、静态变量以及枚举成员；</p>
<p>如果局部类定义在函数内部，则该函数的普通局部变量不能被该局部类使用；</p>
</li>
<li>
<p>常规的访问保护规则对局部类同样适用</p>
<p>局部类可以将外层函数声明为友元；</p>
<p>更常见的，局部类将其成员声明为公有的；</p>
</li>
<li>
<p>局部类中的名字查找</p>
<p>声明类的成员时，必须先确保用到的名字位于作用域中，然后再使用该名字；</p>
<p>定义成员用到的名字可以出现在类的任意位置；</p>
<p>查找顺序：局部类内部-&gt;外层函数作用域-&gt;外层函数所在的作用域；</p>
</li>
<li>
<p>嵌套的局部类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Nested</span>;</span><span class="comment">//局部类内的嵌套类也是一个局部类，嵌套类所有成员必须定义在嵌套类内部</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Bar</span>:</span>:Nested &#123;<span class="comment">//嵌套类的定义可以在局部类之外</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;;<span class="comment">//嵌套类必须定义在局部类相同的作用域中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>19.8 固有的不可移植的特性</h1>
<h2 id="19-8-1-位域"><a class="header-anchor" href="#19-8-1-位域">¶</a>19.8.1 位域</h2>
<p>位域在内存中的布局是机器相关的；</p>
<p>通常最好将位域设为unsigned类型.存储在signed类型中的位域的行为由实现定义；</p>
<p>地址操作符（&amp;）不能应用于位域，所以不可能有引用类位域的指针，位域也不能是类的静态成员；</p>
<ul>
<li>使用位域</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> File::write()&#123;</span><br><span class="line">    modified = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> File::close()&#123;</span><br><span class="line">    <span class="keyword">if</span>(modified)</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">File &amp;File::open(File::modes m)</span><br><span class="line">&#123;</span><br><span class="line">    mode |= READ;</span><br><span class="line">    <span class="keyword">if</span> (m &amp; WRITE)&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> File::isRead() <span class="keyword">const</span> &#123; <span class="keyword">return</span> mode &amp; READ; &#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> File::setWrite() &#123; mode |= WRITE; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="19-8-2-volatile限定符"><a class="header-anchor" href="#19-8-2-volatile限定符">¶</a>19.8.2 volatile限定符</h2>
<p>直接处理硬件的程序常具有这样的数据成员，它们的值由程序本身直接控制之外的过程所控制。例如，程序可以包含由系统时钟更新的变量。当可以用编译器的控制或检测之外的方式改变对象值的时候，应该将对象声明为 volatile。关键字 volatile 是给编译器的指示，指出对这样的对象不应该执行优化；</p>
<p>const和volatile互相没有影响，可以同时具有二者的属性；</p>
<p>只有volatile的成员函数才能被volatile对象调用；</p>
<p>只能将一个volatile对象的地址赋给一个指向volatile的指针；</p>
<p>只有当某个引用是volatile的时，才能使用一个volatile对象初始化该引用；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;v;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>合成拷贝对volatile对象无效</p>
<p>如果一个类希望拷贝、移动或赋值它的volatile对象，该类必须自定义；</p>
<p>将形参类型指定为const volatile引用，这样就能利用任意类型的Foo进行拷贝或赋值操作；</p>
</li>
</ul>
<h2 id="19-8-3-链接指示：extern-c"><a class="header-anchor" href="#19-8-3-链接指示：extern-c">¶</a>19.8.3 链接指示：extern “C”</h2>
<ul>
<li>
<p>声明一个非C++函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">size_t</span> <span class="built_in">strlen</span>(<span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//链接指示不能出现在类定义或函数定义的内部</span></span><br><span class="line"><span class="comment">//同样的链接指示必须在每个函数的每个声明中都出现</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>链接指示与头文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//链接指示可以嵌套</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>指向extern &quot;C&quot;函数的指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*pf1)(<span class="keyword">int</span>); <span class="comment">//指向C++函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">void</span> (*pf2)(<span class="keyword">int</span>); <span class="comment">//指向C函数</span></span><br><span class="line">pf1 = pf2; <span class="comment">//错误，二者类型不同</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>链接指示对整个声明都有效</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">void</span>(*)(<span class="keyword">int</span>))</span></span>; <span class="comment">//它的形参是C函数指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果希望给C++函数传入C函数的指针，必须使用类型别名</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">FC</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//f2是一个C++函数，该函数是指向C函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(FC *)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>导出C++函数到其他语言</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">double</span> <span class="title">calc</span><span class="params">(<span class="keyword">double</span> dparm)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="comment">//calc函数可以被C程序调用</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>重载函数与链接指示</p>
<p>链接指示与重载函数的相互作用依赖于目标语言</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误，两个extern "C"函数名相同</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果一组重载函数有一个是C函数，则其余的必定都是C++函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigNum</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="comment">//C函数可以在C或C++程序中调用</span></span><br><span class="line"><span class="comment">//C++函数重载了该函数，可以在C++中调用</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">double</span> <span class="title">calc</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> SmallInt <span class="title">calc</span><span class="params">(<span class="keyword">const</span> SmallInt&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> BigNum <span class="title">calc</span><span class="params">(<span class="keyword">const</span> BigNum&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/24/-Primer学习笔记：第18章-用于大型程序的工具/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/24/-Primer学习笔记：第18章-用于大型程序的工具/" itemprop="url">C++ Primer学习笔记：第18章 用于大型程序的工具</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-24T18:44:00+08:00">2019-07-24</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>18.1 异常处理</h1>
<blockquote>
<p>控制权转移：</p>
<p>​		沿着调用链的函数可能会提早退出；一旦程序开始执行异常处理代码，则沿着调用链创建的对象将被销毁；</p>
<p>栈展开：</p>
<p>​		沿着调用链查找匹配的catch子句；如果没找到，程序调用terminate退出；</p>
<p>栈展开过程中对象被自动销毁：</p>
<p>​		构造函数和数组或标准容器的元素初始化过程中都可能发生异常，应该保证构造的成员被正确销毁；</p>
<p>析构函数与异常：</p>
<p>​		析构函数在栈展开时自动调用，如果析构函数抛出不能被自己处理的异常，会导致上一个异常还没被处理，又有一个异常被抛出，从而终止程序；析构函数需要执行某个可能抛出异常的操作，则该操作应该被放在一个try语句块中；</p>
<p>异常对象：</p>
<p>​		异常对象是一种特殊对象，编译器<strong>使用异常抛出表达式</strong>来对异常对象进行<strong>拷贝初始化</strong>。throw语句中表达式必须拥有<strong>完全类型</strong>。不抛出局部对象的指针，也不要从函数返回局部对象的指针；如果一条throw表达式解引用一个基类指针，而该指针实际指向的是派生类对象，则抛出的对象将切掉一部分，只有基类部分被抛出；</p>
<p><strong>抛出指针要求在任何对应处理代码存在的地方，指针所指对象都必须存在</strong></p>
</blockquote>
<h2 id="18-1-1-抛出异常"><a class="header-anchor" href="#18-1-1-抛出异常">¶</a>18.1.1 抛出异常</h2>
<h2 id="18-1-2-捕获异常"><a class="header-anchor" href="#18-1-2-捕获异常">¶</a>18.1.2 捕获异常</h2>
<blockquote>
<p>通常情况下，如果catch接受的异常与某个继承体系有关，则最好将catch参数定义成引用类型</p>
</blockquote>
<ul>
<li>
<p>查找匹配的处理代码</p>
<ul>
<li>除了一些极细小的差别之外，要求异常的类型和catch声明的类型是精确匹配：
<ul>
<li>允许从非常量向常量的类型转换</li>
<li>允许从派生类向基类的类型转换</li>
<li>数组和函数被转换成指针</li>
</ul>
</li>
<li>除此之外，包括<strong>标准算术类型转换和类类型</strong>转换在内，其他所有转换规则都不能在匹配catch的过程中使用</li>
<li>如果在多个catch语句之间存在继承关系，则我们应该把继承链最底端的类放在前面，而将最顶端的放在后面</li>
</ul>
</li>
<li>
<p>重新抛出</p>
<p>catch改变参数内容后，重新抛出异常，则只有当catch异常声明是引用类型时我们对参数所做的改变才会被保留并继续传播</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (my_error &amp;eObj)&#123;</span><br><span class="line">    eObj.status = errCodes::severeErr;<span class="comment">//修改了异常对象</span></span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (other_error eObj) &#123;</span><br><span class="line">    eObj.status = errCodes::badErr;<span class="comment">//只改变了局部版本</span></span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>捕获所有异常的处理代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//这里操作将引发并抛出一个异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        <span class="comment">//处理异常的某些特殊操作</span></span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="18-1-3-函数try语句块与构造函数"><a class="header-anchor" href="#18-1-3-函数try语句块与构造函数">¶</a>18.1.3 函数try语句块与构造函数</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//怎么处理构造函数成员初始化列表抛出的异常</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::Blob(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; il) <span class="keyword">try</span> :</span><br><span class="line">						data(<span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt;(il)) &#123;</span><br><span class="line">                            <span class="comment">/* 空函数体 */</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(<span class="keyword">const</span> <span class="built_in">std</span>::bad_alloc &amp;e) &#123; handle_out_of_memory(e); &#125;</span><br><span class="line"><span class="comment">//注意try的位置</span></span><br><span class="line"><span class="comment">//初始化构造函数的参数时也可能发生异常，这样的异常不属于函数try语句块的一部分</span></span><br><span class="line"><span class="comment">//在参数初始化过程中发生异常，则该异常属于调用表达式的一部分，要在调用者所在的上下文中处理</span></span><br></pre></td></tr></table></figure>
<h2 id="18-1-4-noexcept异常说明"><a class="header-anchor" href="#18-1-4-noexcept异常说明">¶</a>18.1.4 noexcept异常说明</h2>
<blockquote>
<p>noexcept要么出现在该函数的所有声明语句和定义语句中，要么一次也不出现；</p>
<p>应该在尾置返回类型之前；</p>
<p>也可以在函数指针的声明和定义中指定noexcept；</p>
<p>在typedef或类型别名中不能出现noexcept；</p>
<p>成员函数中，noexcept需要在const及引用限定符之后，在final、override或虚函数的=0之前；</p>
</blockquote>
<ul>
<li>
<p>违反异常说明</p>
<ul>
<li>编译器不验证noexcept异常说明</li>
<li>如果一个noexcept函数抛出异常，程序会调用terminate确保不在运行时抛出异常的承诺</li>
</ul>
</li>
<li>
<p>异常说明的实参</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recoup</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span></span>; <span class="comment">//recoup不会抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">alloc</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span></span>; <span class="comment">//alloc可能抛出异常</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>noexcept运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//noexcept类似sizeof不会对运算对象求值</span></span><br><span class="line"><span class="keyword">noexcept</span>(recoup(i)); <span class="comment">//如果recoup不抛异常，则结果为true；否则结果为false</span></span><br><span class="line"><span class="keyword">noexcept</span>(e); <span class="comment">//当e调用的所有函数都做了不抛出说明且e本身不含throw语句时，上述表达式为true；否则noexcept(e)返回false</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(g()))</span></span>; <span class="comment">//f和g的异常说明一致</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>异常说明与指针、虚函数和拷贝控制</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//recoup和pf1都承诺不会抛出异常</span></span><br><span class="line"><span class="keyword">void</span> (*pf1)(<span class="keyword">int</span>) <span class="keyword">noexcept</span> = recoup;</span><br><span class="line"><span class="comment">//正确，不抛出异常声明的指针可以指向抛出异常的函数</span></span><br><span class="line"><span class="keyword">void</span> (*pf2)(<span class="keyword">int</span>) = recoup;</span><br><span class="line"></span><br><span class="line">pf1 = alloc; <span class="comment">//错误：alloc可能抛出异常，但是pf1说明了它不会抛出异常</span></span><br><span class="line">pf2 = alloc; <span class="comment">//正确：pf2和alloc都可能抛出异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//虚函数如果承诺不抛出异常，则派生出的虚函数也必须做出同样的承诺</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">f1</span><span class="params">(<span class="keyword">double</span>)</span> <span class="keyword">noexcept</span></span>; <span class="comment">//不会抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">f2</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span></span>; <span class="comment">//可能抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>; <span class="comment">//可能抛出异常</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">f1</span><span class="params">(<span class="keyword">double</span>)</span></span>; <span class="comment">//错误，Base::f1承诺不会抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> <span class="keyword">noexcept</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果对所有成员和基类的所有操作都承诺了不会抛出异常，则合成的拷贝控制成员是noexcept</span></span><br><span class="line"><span class="comment">//如果合成成员调用的任一个函数可能抛出异常，则合成的成员是noexcept(false)</span></span><br><span class="line"><span class="comment">//如果定义了析构函数但没有提供异常说明，则编译器将合成一个与假设由编译器为类合成析构函数时所得的异常说明一致</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="18-1-5-异常类层次"><a class="header-anchor" href="#18-1-5-异常类层次">¶</a>18.1.5 异常类层次</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">out_of_stock</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::runtime_error &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    explicit out_of_stock(const std::string &amp;s) :</span><br><span class="line">    					<span class="built_in">std</span>::runtime_error(s) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">isbn_mismatch</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::logic_error &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    explicit isbn_mismatch(const std::string &amp;s) :</span><br><span class="line">    					<span class="built_in">std</span>::logic_error(s) &#123; &#125;</span><br><span class="line">    isbn_mismatch(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s,</span><br><span class="line">                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;lhs, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;rhs) :</span><br><span class="line">    			<span class="built_in">std</span>::logic_error(s), left(lhs), right(rhs) &#123; &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> left, right;</span><br><span class="line">&#125;;</span><br><span class="line">Sales_data &amp;Sales_data::<span class="keyword">operator</span>+=(<span class="keyword">const</span> Sales_data&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">if</span> (isbn() != rhs.isbn())</span><br><span class="line">        <span class="keyword">throw</span> isbn_mismatch(<span class="string">"wrong isbns"</span>, isbn(), rhs.isbn());</span><br><span class="line">    units_sold += rhs.units_sold;</span><br><span class="line">    revenue += rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sales_data item1, item2, sum;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; item1 &gt;&gt; item2) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sum = item1 + item2;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">const</span> isbn_mismatch &amp;e) &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; e.what() &lt;&lt; <span class="string">": left isbn("</span> &lt;&lt; e.left</span><br><span class="line">            &lt;&lt; <span class="string">") right isbn("</span> &lt;&lt; e.right &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>18.2 命名空间</h1>
<h2 id="18-2-1-命名空间定义"><a class="header-anchor" href="#18-2-1-命名空间定义">¶</a>18.2.1 命名空间定义</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cpluscplus_primer &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;<span class="comment">//无分号</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>每个命名空间都是一个作用域</p>
</li>
<li>
<p>命名空间可以不连续</p>
<blockquote>
<p>定义多个类型不相关的命名空间应该使用单独的文件分别表示每个类型（或关联类型构成的集合）</p>
</blockquote>
</li>
<li>
<p>定义命名空间成员</p>
<p>不能在不相关的作用域中定义，可以在所属命名空间的外层空间定义</p>
</li>
<li>
<p>模板特例化</p>
<p>只要在命名空间中声明了特例化，就能在命名空间外部定义它了</p>
</li>
<li>
<p>全局命名空间</p>
<p><code>::member_name</code></p>
</li>
<li>
<p>嵌套的命名空间</p>
<p>内层命名空间隐藏外层命名空间声明的同名成员；</p>
<p>嵌套的命名空间中定义的名字只在内层命名空间中有效，外层命名空间中的代码要想访问它必须在名字前加限定符；</p>
</li>
<li>
<p>内联命名空间</p>
<p>内联命名空间的名字可以被外层命名空间直接使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">namespace</span> FifthEd &#123; <span class="comment">//inline必须出现在第一次定义的地方</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> FifthEd &#123; <span class="comment">//隐式内联</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Query_base</span> &#123;</span> <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>未命名命名空间</p>
<p>未命名的命名空间中定义的变量具有静态声明期：第一次使用前创建，到程序结束销毁；</p>
<p>一个未命名的命名空间可以在某个给定文件内不连续，但是不能跨越多个文件。如果一个头文件定义了未命名的命名空间，则该命名空间中的定义的名字将在每个包含该头文件的文件中对应不同实体；</p>
<p>未命名的命名空间中的名字可以直接使用，不能使用作用域运算符；</p>
<p>未命名的命名空间中定义的名字的作用域与该命名空间所在作用域相同；</p>
<p>未命名命名空间中的成员可以通过外层命名空间的名字来访问；</p>
<p>在文件中进行静态声明的做法已经被C++标准取消了，现在的做法是使用未命名的命名空间</p>
</li>
</ul>
<h2 id="18-2-2-使用命名空间成员"><a class="header-anchor" href="#18-2-2-使用命名空间成员">¶</a>18.2.2 使用命名空间成员</h2>
<ul>
<li>
<p>命名空间别名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cplusplus_primer &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="keyword">namespace</span> primer = cplusplus_primer;</span><br><span class="line"><span class="comment">//不能在没定义前就声明别名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//别名也可以</span></span><br><span class="line"><span class="keyword">namespace</span> Qlib = cplusplus_primer::QueryLib;</span><br><span class="line">Qlib::Query q;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>using声明：扼要概述</p>
<p>using声明可以出现在全局、局部、命名空间以及类的作用域中。在类的作用域中，这样的声明语句只能指向基类成员</p>
</li>
<li>
<p>using指示</p>
<p>using指示使得命名空间作用域中所有名字都可见。using指示可以出现在全局、局部和命名空间作用域中，但是不能出现在类的作用域中；</p>
</li>
<li>
<p>using指示与作用域</p>
<p>using指示一般被看作是出现在<strong>最近的外层作用域</strong>中；</p>
</li>
<li>
<p>using指示示例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> blip &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">16</span>, j = <span class="number">15</span>, k = <span class="number">23</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> blip;</span><br><span class="line">    ++i;</span><br><span class="line">    ++j;<span class="comment">//错误</span></span><br><span class="line">    ++::j;</span><br><span class="line">    ++blip::j;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">97</span>;</span><br><span class="line">    ++k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>头文件与using声明或指示</p>
<p>头文件最多只能在它的函数或命名空间内使用using指示或using声明</p>
<p>在命名空间本身的实现文件中可以使用using指示</p>
</li>
</ul>
<h2 id="18-2-3-类-命名空间与作用域"><a class="header-anchor" href="#18-2-3-类-命名空间与作用域">¶</a>18.2.3 类、命名空间与作用域</h2>
<ul>
<li>
<p>实参相关的查找与类类型形参</p>
<p>当传递给函数一个类类型的对象、引用或指针时，除了在常规的作用域查找外还会查找实参类所属的命名空间；</p>
</li>
<li>
<p>查找与std::move和std::forward</p>
<p>move和forward接受右值引用的形参，可以匹配任意类型，如果我们也定义了一个接受单一形参的move函数，不管形参是什么类型，应用程序的move都将与标准库版本冲突，所以最好使用它们的带限定语的完整版本；</p>
</li>
<li>
<p>友元声明与实参相关的查找</p>
<p>一个另外的未声明的类或函数如果第一次出现在友元声明中，则我们认为它是最近的外层命名空间的成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">        <span class="comment">//两个友元，在友元声明之外没有其他的声明</span></span><br><span class="line">        <span class="comment">//这些函数隐式地成为命名空间A的成员</span></span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>; <span class="comment">//除非另有声明，否则不会被找到</span></span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> C&amp;)</span></span>; <span class="comment">//根据实参查找可以被找到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A::C cobj;</span><br><span class="line">    f(cobj);</span><br><span class="line">    f2();<span class="comment">//错误，A::f2没有被声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="18-2-4-重载与命名空间"><a class="header-anchor" href="#18-2-4-重载与命名空间">¶</a>18.2.4 重载与命名空间</h2>
<blockquote>
<p>在每个实参类（以及实参的基类）所属的命名空间中搜寻候选函数</p>
</blockquote>
<ul>
<li>
<p>实参相关的查找与重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> NS &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">const</span> Quote&amp;)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Bulk_item的基类声明在命名空间NS中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_item</span> :</span> <span class="keyword">public</span> NS::Quote &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Bulk_item book1;</span><br><span class="line">    display(book1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>重载与using声明</p>
<ul>
<li>一个using声明囊括了重载函数的所有版本以确保不违反命名空间的接口</li>
<li>一个using声明引入的函数将重载该声明语句所属作用域中已有的其他同名函数
<ul>
<li>如果using声明出现在局部作用域中，则引入的名字将隐藏外层作用域的相关声明</li>
<li>如果using声明所在作用域中已经有一个函数与新引入的函数同名且形参列表相同，则该using声明将引发错误</li>
<li>using声明将为引入的名字添加额外的重载实例，最终扩充候选函数集的规模</li>
</ul>
</li>
</ul>
</li>
<li>
<p>重载与using指示</p>
<p>与using声明不同的是，using指示引入一个与已有函数形参列表完全相同的函数并不会产生错误。只要指明调用的是命名空间中的函数版本还是当前作用域的版本即可</p>
</li>
<li>
<p>跨越多个using指示的重载</p>
</li>
</ul>
<h1>18.3 多重继承与虚继承</h1>
<h2 id="18-3-1-多重继承"><a class="header-anchor" href="#18-3-1-多重继承">¶</a>18.3.1 多重继承</h2>
<ul>
<li>
<p>多重继承的派生类从每个基类中继承状态</p>
</li>
<li>
<p>派生类构造函数初始化所有基类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bear</span> :</span> <span class="keyword">public</span> ZooAnimal &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Panda</span> :</span> <span class="keyword">public</span> Bear, <span class="keyword">public</span> Endangered &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line">Panda::Panda(<span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="keyword">bool</span> onExhibit):</span><br><span class="line">			Bear(name, ohExhibit, <span class="string">"Panda"</span>),</span><br><span class="line">			Endangered(Endangered::critical) &#123; &#125;</span><br><span class="line">Panda::Panda()</span><br><span class="line">    	: Endangered(Endangered::critical) &#123; &#125;</span><br><span class="line"><span class="comment">//基类的构造顺序与派生类列表中基类的出现顺序保持一致，而与派生类构造函数初始值列表中基类的顺序无关</span></span><br></pre></td></tr></table></figure>
<p>Panda对象的初始化次序：</p>
<ul>
<li>首先初始化ZooAnimal</li>
<li>接下来初始化Panda的第一个直接基类Bear</li>
<li>然后初始化Panda的第二个直接基类Endangered</li>
<li>最后初始化Panda</li>
</ul>
</li>
<li>
<p>继承的构造函数与多重继承</p>
<ul>
<li>
<p>关于构造函数继承，详见15.7.4</p>
</li>
<li>
<p>如果从多个基类中继承相同的构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line">    Base1() = <span class="keyword">default</span>;</span><br><span class="line">    Base1(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;);</span><br><span class="line">    Base1(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line">    Base2() = <span class="keyword">default</span>;</span><br><span class="line">    Base2(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;);</span><br><span class="line">    Base2(<span class="keyword">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误，D1试图从两个基类中都继承D1::D1(const string&amp;)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line">    <span class="keyword">using</span> Base1::Base1;</span><br><span class="line">    <span class="keyword">using</span> Base2::Base2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line">    <span class="keyword">using</span> Base1::Base1;</span><br><span class="line">    <span class="keyword">using</span> Base2::Base2;</span><br><span class="line">    D2(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s) : Base1(s), Base2(s) &#123; &#125;</span><br><span class="line">    D2() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>析构函数与多重继承</p>
<p>派生类的析构函数只负责清除派生类本身分配的资源</p>
<p>析构函数的调用顺序与构造函数相反</p>
</li>
<li>
<p>多重继承的派生类的拷贝与移动操作</p>
<p>如果定义了自己的拷贝/赋值构造函数和赋值运算符，则必须在完整对象上执行拷贝、移动或赋值操作</p>
<p>只有当派生类使用的是合成版本的拷贝、移动或赋值成员时，才会自动对其基类部分执行这些操作；</p>
<p>在合成的拷贝控制成员中，每个基类分别使用自己对应成员隐式地完成构造、赋值或销毁等工作；</p>
</li>
</ul>
<h2 id="18-3-2-类型转换与多个基类"><a class="header-anchor" href="#18-3-2-类型转换与多个基类">¶</a>18.3.2 类型转换与多个基类</h2>
<p>编译器不会在派生类向基类的几种转换进行比较和选择</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Bear&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Endangered&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Panda <span class="title">ying_yang</span><span class="params">(<span class="string">"ying_yang"</span>)</span></span>;</span><br><span class="line">print(ying_yang); <span class="comment">//二义性错误</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>基于指针类型或引用类型的查找</p>
<p>对象、指针和引用的静态类型决定了我们能够使用哪些成员</p>
</li>
</ul>
<h2 id="18-3-3-多重继承下的类作用域"><a class="header-anchor" href="#18-3-3-多重继承下的类作用域">¶</a>18.3.3 多重继承下的类作用域</h2>
<p>当一个类拥有多个基类时，有可能出现派生类从两个或更多基类中继承了同名成员的情况。此时，不加前缀限定符使用该名字将引发二义性</p>
<h2 id="18-3-4-虚继承"><a class="header-anchor" href="#18-3-4-虚继承">¶</a>18.3.4 虚继承</h2>
<p><strong>默认情况下</strong>，派生类中含有继承链上每个类对应的子部分。如果某个类在派生过程中出现了多次，则派生类中将包含该类的多个子对象</p>
<p>C++语言中通过虚继承令某个类做出声明，承诺愿意共享它的基类。共享的基类子对象称为虚基类</p>
<ul>
<li>
<p>另一个Panda类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">	A(ZooAnimal)</span><br><span class="line">	B(Bear)</span><br><span class="line">	C(Raccoon)</span><br><span class="line">	D(Endangered)</span><br><span class="line">	E(Panda)</span><br><span class="line">	A--虚继承---B</span><br><span class="line">	A--虚继承---C</span><br><span class="line">	B---E</span><br><span class="line">	C---E</span><br><span class="line">	D---E</span><br></pre></td></tr></table></figure>
<p>必须在虚派生的真实需求出现前就已经完成虚派生的操作；</p>
<p>虚派生只影响从指定了虚基类的派生类中进一步派生出的类，不会影响派生类本身；</p>
</li>
<li>
<p>使用虚基类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Raccoon</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> ZooAnimal &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bear</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> ZooAnimal &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="comment">//将zooAnimal定义为Raccoon和Bear的虚基类</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>支持向基类的常规类型转换</p>
</li>
<li>
<p>虚基类成员的可见性</p>
<p>假定B定义了一个x成员，D1和D2虚继承B，D继承D1和D2，则在D中，x通过D的两个基类都是可见的。如果通过D的对象使用x，有三种可能性：</p>
<ul>
<li>如果D1和D2中都没有x的定义，则x被解析成B的成员，不存在二义性，一个D中只含x的一个实例</li>
<li>如果x是B的成员，同时是D1和D2中某一个的成员，则同样没有二义性，派生类的x比共享虚基类B的x优先级高</li>
<li>如果在D1和D2中都有x的定义，则直接访问x将产生二义性问题</li>
</ul>
<p>解决二义性的最好办法是在派生类中为成员自定义新的实例；</p>
</li>
</ul>
<h2 id="18-3-5-构造函数与虚继承"><a class="header-anchor" href="#18-3-5-构造函数与虚继承">¶</a>18.3.5 构造函数与虚继承</h2>
<blockquote>
<p>虚派生中，虚基类是由最底层的派生类初始化的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; Bear::Bear(<span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="keyword">bool</span> onExhibit):</span><br><span class="line">&gt; 		ZooAnimal(name, onExhibit, <span class="string">"Bear"</span>) &#123; &#125;</span><br><span class="line">&gt; Raccoon::Raccoon(<span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="keyword">bool</span> onExhibit):</span><br><span class="line">&gt; 		ZooAnimal(name, onExhibit, <span class="string">"Raccoon"</span>) &#123; &#125;</span><br><span class="line">&gt; Panda::Panda(<span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="keyword">bool</span> onExhibit)</span><br><span class="line">&gt;     	: ZooAnimal(name, onExhibit, <span class="string">"Panda"</span>),</span><br><span class="line">&gt; 		Bear(name, onExhibit),</span><br><span class="line">&gt; 		Raccoon(name, onExhibit),</span><br><span class="line">&gt; 		Endangered(Endangered::critical),</span><br><span class="line">&gt; 		sleeping_flag(<span class="literal">false</span>) &#123; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>
<p>虚继承的对象的构造方式</p>
<p>当我们创建一个Panda对象时：</p>
<ul>
<li>首先使用Panda的构造函数初始值列表提供的值构造虚基类ZooAnimal部分</li>
<li>接下来构造Bear部分</li>
<li>然后构造Raccoon部分</li>
<li>然后构造第三个直接基类Endangered</li>
<li>最后构造Panda部分</li>
</ul>
<p>如果Panda没有显示初始化ZooAnimal基类，则ZooAnimal默认构造函数被调用；如果ZooAnimal没有默认构造函数，则代码发生错误</p>
<blockquote>
<p>虚基类总是先于非虚基类构造，与它们在继承体系中的次序和位置无关。</p>
</blockquote>
</li>
<li>
<p>构造函数与析构函数的次序</p>
<p>先构造虚基类，然后按照声明顺序逐一构造其他非虚基类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Character</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookCharacter</span> :</span> <span class="keyword">public</span> Character &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToyAnimal</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TeddyBear</span> :</span> <span class="keyword">public</span> BookCharacter,</span><br><span class="line">					<span class="keyword">public</span> Bear, <span class="keyword">public</span> <span class="keyword">virtual</span> ToyAnimal</span><br><span class="line">					&#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="comment">//构造顺序</span></span><br><span class="line">ZooAnimal();</span><br><span class="line">ToyAnimal();</span><br><span class="line">Character();</span><br><span class="line">BookCharacter();</span><br><span class="line">Bear();</span><br><span class="line">TeddyBear();</span><br><span class="line"><span class="comment">//合成的拷贝和移动构造函数，合成的赋值运算符的成员顺序和上面一致。析构顺序和上面相反</span></span><br></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/23/C-Primer学习笔记：第17章-标准库特殊设施/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/23/C-Primer学习笔记：第17章-标准库特殊设施/" itemprop="url">C++ Primer学习笔记：第17章 标准库特殊设施</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-23T22:54:00+08:00">2019-07-23</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>17.1 tuple类型</h1>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;T1, T2, ..., Tn&gt; t; <span class="comment">//值初始化</span></span><br><span class="line"></span><br><span class="line">tuple&lt;T1, T2, ..., Tn&gt; t(v1, v2, ..., vn); <span class="comment">//explicit构造函数，对应成员用vi初始化</span></span><br><span class="line"></span><br><span class="line">make_tuple(v1, v2, ..., vn); <span class="comment">//用给定初始值初始化，推断类型</span></span><br><span class="line"></span><br><span class="line">t1 == t2;</span><br><span class="line">t1 != t2;</span><br><span class="line"></span><br><span class="line">t1 relop t2;</span><br><span class="line"></span><br><span class="line">get&lt;i&gt;(t); <span class="comment">//获取t的第i个成员的引用</span></span><br><span class="line"></span><br><span class="line">tuple_size&lt;tupleType&gt;::value; <span class="comment">//类模板，用一个tuple类型初始化，有一个名为value的public constexpr static的成员，类型为size_t，表示给定tuple类型成员数量</span></span><br><span class="line"></span><br><span class="line">tuple_element&lt;i, tupleType&gt;::type; <span class="comment">//public成员type表示给定tuple类型中指定成员的类型</span></span><br></pre></td></tr></table></figure>
<h2 id="17-1-1-定义和初始化tuple"><a class="header-anchor" href="#17-1-1-定义和初始化tuple">¶</a>17.1.1 定义和初始化tuple</h2>
<p>提供初始值的构造函数必须使用直接初始化语法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="keyword">size_t</span>, <span class="keyword">size_t</span>, <span class="keyword">size_t</span>&gt; threeD = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//错误</span></span><br><span class="line">tuple&lt;<span class="keyword">size_t</span>, <span class="keyword">size_t</span>, <span class="keyword">size_t</span>&gt; threeD&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<p>用make_tuple生成tuple对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> item = make_tuple(<span class="string">"0-999-78345-X"</span>, <span class="number">3</span>, <span class="number">20.00</span>); <span class="comment">//类型推断</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>访问tuple的成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(item)</span> trans</span></span><br><span class="line"><span class="function">size_t sz </span>= tuple_size&lt;trans&gt;::value;</span><br><span class="line">tuple_element&lt;<span class="number">1</span>, trans&gt;::type cnt = get&lt;<span class="number">1</span>&gt;(item);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>关系和相等运算符</p>
<p>只有两个tuple有相同数量成员时才可以比较它们；</p>
<p>由于tuple定义了&lt;和==运算符，可以将tuple序列传递给算法，并且可以在无序容器中将tuple作为关键字类型；</p>
</li>
</ul>
<h2 id="17-1-2-使用tuple返回多个值"><a class="header-anchor" href="#17-1-2-使用tuple返回多个值">¶</a>17.1.2 使用tuple返回多个值</h2>
<ul>
<li>
<p>返回tuple的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> tuple&lt;<span class="built_in">vector</span>&lt;Sales_data&gt;::size_type,</span><br><span class="line">				<span class="built_in">vector</span>&lt;Sales_data&gt;::const_iterator,</span><br><span class="line">				<span class="built_in">vector</span>&lt;Sales_data&gt;::const_iterator&gt; matches;</span><br><span class="line"><span class="built_in">vector</span>&lt;matches&gt; findBook(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Sales_data&gt;&gt; &amp;files,</span><br><span class="line">                        <span class="keyword">const</span> <span class="built_in">string</span> &amp;book)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">for</span>(...)&#123;</span><br><span class="line">        <span class="comment">//equal_range</span></span><br><span class="line">        <span class="keyword">if</span>(found.first != found.second)</span><br><span class="line">            ret.push_back(make_tuple(it - files.cbegin(),</span><br><span class="line">                                    found.first, found.second));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用函数返回的tuple</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reportResults</span><span class="params">(istream &amp;in, ostream &amp;os,</span></span></span><br><span class="line"><span class="function"><span class="params">                  	<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Sales_data&gt;&gt; &amp;files)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span> (in &gt;&gt; s)&#123;</span><br><span class="line">        <span class="keyword">auto</span> trans = findBook(files, s);</span><br><span class="line">        <span class="keyword">if</span> (trans.empty())&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(...)</span><br><span class="line">            os &lt;&lt; ... &lt;&lt; get&lt;<span class="number">0</span>&gt;(store) &lt;&lt; ...</span><br><span class="line">            	&lt;&lt; accumulate(get&lt;<span class="number">1</span>&gt;(store), get&lt;<span class="number">2</span>&gt;(store), Sales_data(s))</span><br><span class="line">            	&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>17.2 BITSET类型</h1>
<h2 id="17-2-1-定义和初始化bitset"><a class="header-anchor" href="#17-2-1-定义和初始化bitset">¶</a>17.2.1 定义和初始化bitset</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大小固定</span></span><br><span class="line"><span class="built_in">bitset</span>&lt;n&gt; b; <span class="comment">//constexpr构造函数</span></span><br><span class="line"><span class="built_in">bitset</span>&lt;n&gt; b(u); <span class="comment">//constexpr构造函数，b是unsigned long long的值u的低n位的拷贝</span></span><br><span class="line"><span class="built_in">bitset</span>&lt;n&gt; b(s, pos, m, zero, one); <span class="comment">//explicit，b是string s从pos开始m个字符的拷贝，s只能包含字符zero或one</span></span><br><span class="line"><span class="built_in">bitset</span>&lt;n&gt; b(cp, pos, m, zero, one); <span class="comment">//explicit，从cp指向的字符数组中拷贝，如果未提供m，则cp必须指向C风格字符串；提供了m，则从cp开始必须至少有m个zero或one字符</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用unsigned值初始化bitset</li>
<li>从一个string初始化bitset
<ul>
<li>字符串中下标最小的字符对应高位</li>
<li>可以只用一个子串作为初始值</li>
</ul>
</li>
</ul>
<h2 id="17-2-2-bitset操作"><a class="header-anchor" href="#17-2-2-bitset操作">¶</a>17.2.2 bitset操作</h2>
<ul>
<li>
<p>提取bitset的值</p>
<p>可能抛出overflow_error异常</p>
</li>
<li>
<p>bitset的IO运算符</p>
</li>
<li>
<p>使用bitset</p>
</li>
</ul>
<h1>17.3 正则表达式</h1>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">regex</span><br><span class="line">regex_match</span><br><span class="line">regex_search</span><br><span class="line">regex_replace</span><br><span class="line">sregex_iterator</span><br><span class="line">smatch <span class="comment">//容器类，保存string中搜索的结果</span></span><br><span class="line">ssub_match <span class="comment">//string中匹配的子表达式的结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//regex_search和regex_match的参数</span></span><br><span class="line">(seq, m, r, mft)</span><br><span class="line">(seq, r, mft)</span><br><span class="line"><span class="comment">//seq可以是string、一对迭代器以及指向空字符结尾的字符数组的指针，r是regex对象，m是match对象，mft是可选的regex_constants::match_flag_type值</span></span><br></pre></td></tr></table></figure>
<h2 id="17-3-1-使用正则表达式库"><a class="header-anchor" href="#17-3-1-使用正则表达式库">¶</a>17.3.1 使用正则表达式库</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">pattern</span><span class="params">(<span class="string">"[^c]ei"</span>)</span></span>;</span><br><span class="line">pattern = <span class="string">"[[:alpha:]]*"</span> + pattern + <span class="string">"[[::alpha:]]*"</span>;</span><br><span class="line"><span class="function">regex <span class="title">r</span><span class="params">(pattern)</span></span>;</span><br><span class="line">smatch results;</span><br><span class="line"><span class="built_in">string</span> test_str = <span class="string">"receipt friend theif receive"</span>;</span><br><span class="line"><span class="keyword">if</span> ( regex_search(test_str, results, r))</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; results.str() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>指定regex对象的选项</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">regex <span class="title">r</span><span class="params">(re)</span></span></span><br><span class="line"><span class="function">regex <span class="title">r</span><span class="params">(re, f)</span></span></span><br><span class="line"><span class="function">r1 </span>= re</span><br><span class="line">r1.assign(re, f)</span><br><span class="line">r.mark_count()</span><br><span class="line">r.flags()</span><br><span class="line">    </span><br><span class="line"><span class="comment">//选项f</span></span><br><span class="line">icase </span><br><span class="line">nosubs</span><br><span class="line">optimize</span><br><span class="line">ECMAScript</span><br><span class="line">basic</span><br><span class="line">extended</span><br><span class="line">awk</span><br><span class="line">grep</span><br><span class="line">egrep</span><br><span class="line"></span><br><span class="line"><span class="comment">//icase使用示例</span></span><br><span class="line"><span class="function">regex <span class="title">r</span><span class="params">(<span class="string">"[[:alnum:]]+\\.(cpp|cxx|cc)$"</span>, regex::icase)</span></span>;</span><br><span class="line">smatch results;</span><br><span class="line"><span class="built_in">string</span> filename;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; filename)</span><br><span class="line">    <span class="keyword">if</span> (regex_search(filename, results, r))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; results.str() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>指定或使用正则表达式时的错误</p>
<ul>
<li>
<p>正则表达式语法是否正确是在运行时解析的</p>
</li>
<li>
<p>如果正则表达式存在编写错误，则运行时标准库会抛出类型为regex_error的异常</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="function">regex <span class="title">r</span><span class="params">(<span class="string">"[[:alnum:]+\\.(cpp|cxx|cc)$"</span>, regex::icase)</span></span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (regex_error e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="string">"\ncode: "</span> &lt;&lt; e.code() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>避免创建不必要的正则表达式，如果在循环中使用正则表达式，应该在循环外创建它，而不是每步迭代时都编译它</p>
</li>
</ul>
</li>
<li>
<p>正则表达式类和输入序列类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果输入序列类型         则使用正则表达式类</span></span><br><span class="line">  <span class="built_in">string</span>                regex、smatch、ssub_match和sregex_iterator</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>*           regex、cmatch、csub_match和cregex_iterator</span><br><span class="line">  wstring               wregex、wsmatch、wssub_match和wsregex_iterator</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">wchar_t</span>*        wregex、wcmatch、wcsub_match和wcregex_iterator</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="17-3-2-匹配与regex迭代器类型"><a class="header-anchor" href="#17-3-2-匹配与regex迭代器类型">¶</a>17.3.2 匹配与Regex迭代器类型</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sregex_iterator操作</span></span><br><span class="line"><span class="function">sregex_iterator <span class="title">it</span><span class="params">(b, e, r)</span></span>;</span><br><span class="line">sregex_iterator end;</span><br><span class="line">*it <span class="comment">//获得最近一次搜索结果的smatch对象</span></span><br><span class="line">it-&gt;</span><br><span class="line">it++</span><br><span class="line">++it</span><br><span class="line">it1 == it2</span><br><span class="line">it1 != it2</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>使用sregex_iterator</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">pattern</span><span class="params">(<span class="string">"[^c]ei"</span>)</span></span>;</span><br><span class="line">pattern = <span class="string">"[[:alpha:]]*"</span> + pattern + <span class="string">"[[::alpha:]]*"</span>;</span><br><span class="line"><span class="function">regex <span class="title">r</span><span class="params">(pattern, regex::icase)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(sregex_iterator it(file.begin(), file.end(), r), end_it;</span><br><span class="line">    it != end_it; ++it)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; it-&gt;str() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用匹配数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(sregex_iterator it(file.begin(), file.end(), r), end_it;</span><br><span class="line">    it != end_it; ++it)&#123;</span><br><span class="line">        <span class="keyword">auto</span> pos = it-&gt;prefix().length();</span><br><span class="line">        pos = pos &gt; <span class="number">40</span> ? pos - <span class="number">40</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;prefix().str().substr(pos)</span><br><span class="line">            &lt;&lt; <span class="string">"\n\t\t&gt;&gt;&gt; "</span> &lt;&lt; it-&gt;str() &lt;&lt; <span class="string">" &lt;&lt;&lt;\n"</span></span><br><span class="line">            &lt;&lt; it-&gt;suffix().str().substr(<span class="number">0</span>, <span class="number">40</span>)</span><br><span class="line">            &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//smatch 操作</span></span><br><span class="line">m.ready()</span><br><span class="line">m.size()</span><br><span class="line">m.empty()</span><br><span class="line">m.prefix()</span><br><span class="line">m.suffix()</span><br><span class="line">m.format(...)</span><br><span class="line">m.length(n)</span><br><span class="line">m.position(n)</span><br><span class="line">m.str(n)</span><br><span class="line">m[n]</span><br><span class="line">m.begin(), m.end()</span><br><span class="line">m.cbegin(), m.cend()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="17-3-3-使用子表达式"><a class="header-anchor" href="#17-3-3-使用子表达式">¶</a>17.3.3 使用子表达式</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ssub_match 子匹配操作</span></span><br><span class="line">matched <span class="comment">//可选子表达式是否匹配</span></span><br><span class="line">first</span><br><span class="line">second</span><br><span class="line">length()</span><br><span class="line">str()</span><br><span class="line">s = ssub <span class="comment">//ssub_match转化为string</span></span><br></pre></td></tr></table></figure>
<h2 id="17-3-4-使用regex-replace"><a class="header-anchor" href="#17-3-4-使用regex-replace">¶</a>17.3.4 使用regex_replace</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">m.format(dest, fmt, mft)</span><br><span class="line">m.format(fmt, mft)</span><br><span class="line">regex_replace(dest, seq, r, fmt, mft)</span><br><span class="line">regex_replace(seq, r, fmt, mft)</span><br><span class="line"><span class="comment">//匹配在m中，fmt是格式字符串，mft是匹配标志，二者用来控制输出</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="built_in">string</span> ftm = <span class="string">"$2.$5.$7"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配标志，定义在regex_constants::match_flag_type中</span></span><br><span class="line">match_default</span><br><span class="line">match_not_bol</span><br><span class="line">match_not_eol</span><br><span class="line">match_not_bow</span><br><span class="line">match_not_eow</span><br><span class="line">match_any</span><br><span class="line">match_not_null</span><br><span class="line">match_continuous</span><br><span class="line">match_prev_avail</span><br><span class="line">match_default</span><br><span class="line">format_default</span><br><span class="line">format_sed</span><br><span class="line">format_no_copy <span class="comment">//不输出未匹配部分</span></span><br><span class="line">format_first_only</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配标志使用</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; regex_replace(s, r, fmt2, format_no_copy) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h1>17.4 随机数</h1>
<h2 id="17-4-1-随机数引擎和分布"><a class="header-anchor" href="#17-4-1-随机数引擎和分布">¶</a>17.4.1 随机数引擎和分布</h2>
<blockquote>
<p>随机数引擎是函数对象类，定义了调用运算符，不接受参数，返回一个随机unsigned整数</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">default_random_engine e;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; e() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机数引擎操作</span></span><br><span class="line">Engine e;</span><br><span class="line"><span class="function">Engine <span class="title">e</span><span class="params">(seed)</span></span>;</span><br><span class="line">e.seed(s);</span><br><span class="line">e.min();</span><br><span class="line">e.max();</span><br><span class="line">Engine::result_type</span><br><span class="line">e.discard(u); <span class="comment">//引擎推进u步</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>分布类型和引擎</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uniform_int_distribution&lt;<span class="keyword">unsigned</span>&gt; u(<span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line">default_random_engine e;</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; u(e) &lt;&lt; <span class="string">" "</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>比较随机数引擎和rand函数</p>
<p>rand和default_random_engine类似，可以调用min和max获得一个引擎类型的范围</p>
</li>
<li>
<p>引擎生成一个数值序列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪随机性</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; bad_randVec()&#123;</span><br><span class="line">    default_random_engine e;</span><br><span class="line">    uniform_int_distribution&lt;<span class="keyword">unsigned</span>&gt; u(<span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; ret;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span> ; i &lt; <span class="number">100</span>; ++i )</span><br><span class="line">        ret.push_back(u(e));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每次调用都会获得相同的vector</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//应该将引擎和关联的分布对象定义为static的</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; good_randVec()&#123;</span><br><span class="line">	<span class="keyword">static</span> default_random_engine e;</span><br><span class="line">    <span class="keyword">static</span> uniform_int_distribution&lt;<span class="keyword">unsigned</span>&gt; u(<span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; ret;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span> ; i &lt; <span class="number">100</span>; ++i )</span><br><span class="line">        ret.push_back(u(e));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>设置随机数发生种子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">default_random_engine <span class="title">e1</span><span class="params">(time(<span class="number">0</span>))</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="17-4-2-其他随机数分布"><a class="header-anchor" href="#17-4-2-其他随机数分布">¶</a>17.4.2 其他随机数分布</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分布类型的操作</span></span><br><span class="line">Dist d; <span class="comment">//explicit构造函数</span></span><br><span class="line">d(e);</span><br><span class="line">d.min();</span><br><span class="line">d.max();</span><br><span class="line">d.reset();</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>生成随机实数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">default_random_engine e;</span><br><span class="line"><span class="comment">//0到1（包含）的均匀分布</span></span><br><span class="line">uniform_real_distribution&lt;<span class="keyword">double</span>&gt; u(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; u(e) &lt;&lt; <span class="string">" "</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用分布的默认结果类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每个分布模板都有一个默认模板实参</span></span><br><span class="line">uniform_real_distribution&lt;&gt; u(<span class="number">0</span>,<span class="number">1</span>); <span class="comment">//默认生成double值</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>生成非均匀分布的随机数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">default_random_engine e;</span><br><span class="line">normal_distribution&lt;&gt; n(<span class="number">4</span>, <span class="number">1.5</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; vals(<span class="number">9</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">200</span>; ++i)&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> v = lround(n(e));</span><br><span class="line">    <span class="keyword">if</span>(v &lt; vals.size())</span><br><span class="line">        ++vals[v];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> j = <span class="number">0</span>; j != vals.size(); ++j)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="string">": "</span> &lt;&lt; <span class="built_in">string</span>(vals[j], <span class="string">'*'</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>bernoulli_distribution类</p>
<blockquote>
<p>该分布不接受模板参数</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> resp;</span><br><span class="line">default_random_engine e;</span><br><span class="line">bernoulli_distribution b; <span class="comment">//50/50</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> first = b(e);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (first ? <span class="string">"We go first"</span></span><br><span class="line">            		: <span class="string">"You get to go first"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ((play(first)) ? <span class="string">"sorry, you lost"</span></span><br><span class="line">            				: <span class="string">"congrats, you won"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"play again? Enter 'yes' or 'no''"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; resp &amp;&amp; resp[<span class="number">0</span>] == <span class="string">'y'</span>);</span><br><span class="line"><span class="comment">//bernoulli_distribution允许调整选择先行一方的概率</span></span><br><span class="line"><span class="function">bernoulli_distribution <span class="title">b</span><span class="params">(<span class="number">.55</span>)</span></span>; <span class="comment">//55/45</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>17.5 IO库再探</h1>
<h2 id="17-5-1-格式化输入与输出"><a class="header-anchor" href="#17-5-1-格式化输入与输出">¶</a>17.5.1 格式化输入与输出</h2>
<ul>
<li>
<p>很多操纵符改变格式状态</p>
<p>操纵符用于两大类输出控制：控制数值的输出形式以及控制补白的数量和位置</p>
<p>大多数改变格式状态的操纵符都是设置、复原成对的</p>
</li>
<li>
<p>控制布尔值的格式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"default bool: "</span> &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="literal">false</span></span><br><span class="line">    &lt;&lt; <span class="string">"\nalpha bool: "</span> &lt;&lt; boolapha</span><br><span class="line">    &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="literal">false</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> bool_val = get_status();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; boolalpha </span><br><span class="line">&lt;&lt; boool_val</span><br><span class="line">&lt;&lt; noboolalpha;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>
<p>指定整型值的进制</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"default: "</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"octal: "</span> &lt;&lt; oct &lt;&lt; <span class="number">20</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hex: "</span> &lt;&lt; hex &lt;&lt; <span class="number">20</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"decimal: "</span> &lt;&lt; dec &lt;&lt; <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>输出中指出进制</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; showbase;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; noshowbase;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认情况，16进制以小写打印，前导字符也是小写x</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; uppercase &lt;&lt; showbase &lt;&lt; hex</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &lt;&lt; nouppercase &lt;&lt; noshowbase &lt;&lt; dec &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>控制浮点数格式</p>
<p>可以控制浮点数输出三种格式：</p>
<ul>
<li>以高精度打印浮点值</li>
<li>数值是打印为十六进制、定点十进制还是科学记数法形式</li>
<li>对于没有小数点部分的浮点值是否打印小数点</li>
</ul>
<p>默认情况下，浮点数按六位数字精度；如果没有小数部分，不打印小数点；根据浮点数的值选择打印成定点十进制或科学记数法形式；</p>
<p>标准库会选择一种可读性更好的格式：非常大和小的值打印为科学记数法，其他打印为定点十进制；</p>
</li>
<li>
<p>指定打印精度</p>
<p>可以调用IO对象的precision成员或使用setprecision操纵符来改变精度；</p>
<p>操纵符setprecision定义在头文件iomanip中</p>
</li>
<li>
<p>指定浮点数记数法</p>
<ul>
<li>scientific改变流的状态来使用科学记数法</li>
<li>fixed改变流的状态来使用定点十进制</li>
<li>hexfloat强制使用十六进制格式</li>
<li>defaultfloat恢复默认状态，根据要打印的值选择记数法</li>
</ul>
<blockquote>
<p>在执行scientific、fixed或hexfloat后，精度值控制的是小数点后面的数字位数，而默认情况下精度值指定的是数字的总位数</p>
</blockquote>
</li>
<li>
<p>打印小数点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; showpoint &lt;&lt; <span class="number">10.0</span></span><br><span class="line">    &lt;&lt; noshowpoint &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>输出补白</p>
<p>按列打印数据时，需要精细控制数据格式：</p>
<ul>
<li>setw指定下一个数字或字符串值的最小空间</li>
<li>left表示左对齐</li>
<li>right表示右对齐，默认对齐格式</li>
<li>internal控制负数的符号的位置，它左对齐符号，右对齐值，用空格填满中间空间</li>
<li>setfill允许指定一个字符代替默认空格补白输出</li>
</ul>
<blockquote>
<p>setw类似endl不改变输出流的内部状态，只决定下一个输出的大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">//定义在iomanip中的操纵符</span></span><br><span class="line">&gt; setfill(ch)</span><br><span class="line">&gt; setprecision(n)</span><br><span class="line">&gt; setw(w)</span><br><span class="line">&gt; setbase(b)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li>
<p>控制输入格式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; noskipws; <span class="comment">//读取空白符</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; ch)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ch;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; skipws; <span class="comment">//恢复cin到默认状态，从而丢弃空白符</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="17-5-2-未格式化的输入-输出操作"><a class="header-anchor" href="#17-5-2-未格式化的输入-输出操作">¶</a>17.5.2 未格式化的输入/输出操作</h2>
<ul>
<li>
<p>单字节操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">is.get(ch);</span><br><span class="line">os.put(ch);</span><br><span class="line">is.get(); <span class="comment">//is的下一个字节作为int返回</span></span><br><span class="line">is.putback(ch); <span class="comment">//ch放回is，返回is</span></span><br><span class="line">is.unget(); <span class="comment">//将is向后移动一个字节。返回is</span></span><br><span class="line">is.peek();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将字符放回输入流</p>
<p><code>peek、unget、putback</code></p>
<p>读取下一个值之前，标准库保证我们最多可以退回最多一个值。即，标准库不保证在中间不进行读取操作的情况下能连续调用<code>putback</code>或<code>unget</code></p>
</li>
<li>
<p>从输入操作返回的int值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line"><span class="keyword">while</span> ((ch = <span class="built_in">cin</span>.get()) != EOF)</span><br><span class="line">    <span class="built_in">cout</span>.put(ch);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>多字节操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">is.get(sink, size, delim); <span class="comment">//delim不读取出来存入sink</span></span><br><span class="line">is.getline(sink, size, delim); <span class="comment">//读取并丢弃delim</span></span><br><span class="line">is.read(sink, size);</span><br><span class="line">is.gcount();</span><br><span class="line">os.write(source, size);</span><br><span class="line">is.ignore(size, delim);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>确定读取了多少个字符</p>
<p>如果在<code>gcount</code>调用之前调用了<code>peek、unget或putback</code>，则<code>gcount</code>的返回值为0</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">char</span> ch;</span><br><span class="line">&gt; <span class="keyword">while</span> ((ch = <span class="built_in">cin</span>.get()) != EOF)</span><br><span class="line">&gt;     <span class="built_in">cout</span>.put(ch);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h2 id="17-5-3-流随机访问"><a class="header-anchor" href="#17-5-3-流随机访问">¶</a>17.5.3 流随机访问</h2>
<blockquote>
<p>istream、ostream通常不支持随机访问</p>
</blockquote>
<ul>
<li>
<p>seek和tell函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tellg();</span><br><span class="line">tellp();</span><br><span class="line"></span><br><span class="line">seekg(pos);</span><br><span class="line">seekp(pos);</span><br><span class="line"></span><br><span class="line">seekp(off, from);</span><br><span class="line">seekg(off, from);</span><br><span class="line"><span class="comment">//g是获得数据，p是放置数据</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>只有一个标记</p>
<p>一个流中只维护单一标记，不存在独立的读标记和写标记</p>
</li>
<li>
<p>重定位标记</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">seekg(new_position);</span><br><span class="line">seekp(new_position);</span><br><span class="line"></span><br><span class="line">seekg(offset, from);</span><br><span class="line">seekp(offset, from);</span><br><span class="line"><span class="comment">//new_position和offset的类型分别是pos_type和off_type</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>访问标记</p>
</li>
<li>
<p>读写同一个文件</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/23/C-Primer学习笔记：第16章-模板与泛型编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/23/C-Primer学习笔记：第16章-模板与泛型编程/" itemprop="url">C++ Primer学习笔记：第16章 模板与泛型编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-23T11:36:00+08:00">2019-07-23</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>16.1 定义模板</h1>
<h2 id="16-1-1-函数模板"><a class="header-anchor" href="#16-1-1-函数模板">¶</a>16.1.1 函数模板</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;v1, <span class="keyword">const</span> T &amp;v2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模板参数列表&lt;typename T&gt;不能为空</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>实例化函数模板</p>
</li>
<li>
<p>模板类型参数</p>
<ul>
<li>类型参数前必须使用关键字class或typename</li>
<li>typename和class含义相同，可以互换使用</li>
</ul>
</li>
<li>
<p>非类型模板参数</p>
<ul>
<li>一个非类型参数表示一个值而非一个类型，通过特定类型名而非关键字class或typename来指定非类型参数</li>
<li>非类型模板参数使用的模板形参必须是常量表达式</li>
<li>一个非类型参数可以是整型，或者是一个指向对象或函数类型的指针或左值引用
<ul>
<li>绑定到非类型整型参数的实参必须是一个常量表达式</li>
<li>绑定到指针或引用非类型参数的实参必须具有静态生存期。不能用普通（非static）局部变量或动态对象作为指针或引用非类型模板参数的实参。指针参数也可以用nullptr或一个值为0的<strong>常量表达式</strong>来实例化</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> N, <span class="keyword">unsigned</span> M&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1)[N], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[M])</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//compare("hi", "mom")会实例化出int compare(const char (&amp;p1)[3], const char (&amp;p2)[4])</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>inline和constexpr模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">min</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">//错误</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">min</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>编写类型无关的代码</p>
<ul>
<li>
<p>模板中的函数参数是const的引用（处理不能拷贝的类型）</p>
</li>
<li>
<p>函数体中的条件判断仅使用&lt;比较运算（不需要同时支持&gt;）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;v1, <span class="keyword">const</span> T &amp;v2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(less&lt;T&gt;()(v1, v2)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(less&lt;T&gt;()(v2, v1)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>模板编译</p>
<ul>
<li>编译器只有在我们使用模板时才会生成代码</li>
<li>函数模板和类模板成员函数的定义通常放在头文件中。与非模板代码不同，模板头文件既包括声明也包括定义。</li>
<li>模板包含两种名字
<ul>
<li>不依赖于模板参数的名字（提供者保证）</li>
<li>依赖于模板参数的名字（用户保证）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>大多数编译错误在实例化期间报告</p>
<p>编译器三个阶段报错</p>
<ul>
<li>编译模板本身时，发现语法错误</li>
<li>编译遇到模板使用时，对于函数模板调用检查实参数目是否正确、参数类型是否匹配、对于类模板可以检查是否提供了正确数目的模板实参</li>
<li>模板实例化时，发现类型相关的错误，这些错误依赖于编译器如何管理实例化，可能在链接时才报告</li>
</ul>
<blockquote>
<p>保证传递给模板的实参支持所要求的的操作，以及这些操作在模板中能正确工作，是调用者的责任</p>
</blockquote>
</li>
</ul>
<h2 id="16-1-2-类模板"><a class="header-anchor" href="#16-1-2-类模板">¶</a>16.1.2 类模板</h2>
<blockquote>
<p>为了使用类模板必须在模板名后的尖括号中提供额外信息，来代替模板参数的模板实参列表</p>
</blockquote>
<ul>
<li>
<p>定义类模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    ...</span><br><span class="line">    Blob(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; il);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>实例化类模板</p>
<p>实例化出的类之间没有关联</p>
</li>
<li>
<p>模板作用域中引用模板类型</p>
<p>类模板的名字不是一个类型名，实例化的类型应该包含模板参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>类模板的成员函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//模板形参</span></span><br><span class="line">ret-type Blob&lt;T&gt;::member-name(parm-<span class="built_in">list</span>) <span class="comment">//模板实参</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>check和元素访问成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Blob&lt;T&gt;::check(size_type i, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;msg) <span class="keyword">const</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i &gt;= data-&gt;size())</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Blob中下标运算符和back函数的定义</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Blob构造函数</p>
</li>
<li>
<p>类模板成员函数的实例化</p>
<p>对于一个实例化了的类模板，成员函数只有用到才会被实例化。<strong>这一特性使得即使某种类型不能完全符合模板操作的要求，仍能用该类型实例化类</strong></p>
</li>
<li>
<p>在类代码内简化模板类名的使用</p>
<p>当处于一个类模板作用域中时，编译器处理模板自身引用时就好像我们已经提供了与模板参数匹配的实参一样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    BlobPtr&amp; <span class="keyword">operator</span>++();<span class="comment">//等价于BlobPtr&lt;T&gt;&amp; operator++();</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在类模板外使用类模板名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;::<span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;</span><br><span class="line">    BlobPtr ret = *<span class="keyword">this</span>; <span class="comment">//等价于BlobPtr&lt;T&gt; ret = *this</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在类模板作用域内，可以直接使用模板名而不必指定模板实参</p>
</blockquote>
</li>
<li>
<p>类模板和友元</p>
<p>类与友元各自是否是模板是相互无关的</p>
</li>
<li>
<p>一对一友好关系</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">			<span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Blob&lt;T&gt;&amp;， <span class="keyword">const</span> Blob&lt;T&gt;&amp;);</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>&lt;T&gt;;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==&lt;T&gt;(<span class="keyword">const</span> Blob&lt;T&gt;&amp;， <span class="keyword">const</span> Blob&lt;T&gt;&amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>通用和特定的模板友好关系</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>;</span><span class="comment">//前置友元，在将模板的一个特定实例声明为友元时用到</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span><span class="comment">//普通类</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&lt;C&gt;;</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal2</span>;</span><span class="comment">//所有实例都是友元，这种情况无需前置声明</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">C2</span> &#123;</span><span class="comment">//类模板</span></span><br><span class="line">  	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&lt;T&gt;;</span><span class="comment">//相同实例化的Pal声明为友元，Pal模板声明必须在作用域之内</span></span><br><span class="line">  	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal2</span>;</span><span class="comment">//Pal2的所有实例都是C2的每个实例的友元</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal3</span>;</span><span class="comment">//Pal3是非模板类，是所有C2实例的友元，不需要Pal3的前置声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>令模板自己的类型参数称为友元</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> &#123;</span></span><br><span class="line"><span class="keyword">friend</span> Type;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//如Sales_data将成为Bar&lt;Sales_data&gt;的友元</span></span><br><span class="line"><span class="comment">//内置类型来实例化Bar也是可以的，允许这种与内置类型的友好关系，以便我们能用内置类型实例化Bar这样的类</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>模板类型别名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Blob&lt;<span class="built_in">string</span>&gt; StrBlob;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新标准允许为类模板定义一个类型别名</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> twin = pair&lt;T, T&gt;;</span><br><span class="line">twin&lt;<span class="built_in">string</span>&gt; authors;<span class="comment">//authors是一个pair&lt;string, string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个类型模板别名是一族类的别名</span></span><br><span class="line">twin&lt;<span class="keyword">int</span>&gt; win_loss;<span class="comment">//pair&lt;int, int&gt;</span></span><br><span class="line">twin&lt;<span class="keyword">double</span>&gt; area;<span class="comment">//pair&lt;double, double&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以固定一个或多个模板参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> partNo = pair&lt;T, <span class="keyword">unsigned</span>&gt;;</span><br><span class="line">partNo&lt;<span class="built_in">string</span>&gt; books; <span class="comment">//pair&lt;string, unsigned&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>类模板的static成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> count() &#123; <span class="keyword">return</span> ctr; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> ctr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化static成员Foo&lt;string&gt;::ctr和Foor&lt;string&gt;::count</span></span><br><span class="line">Foo&lt;<span class="built_in">string</span>&gt; fs;</span><br><span class="line"><span class="comment">//三个成员共享Foo&lt;int&gt;::ctr和Foor&lt;int&gt;::count成员</span></span><br><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi, fi2, fi3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">size_t</span> Foo&lt;T&gt;::ctr = <span class="number">0</span>;<span class="comment">//定义并初始化ctr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为了通过类来直接访问static成员，必须引用一个特定的实例</span></span><br><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi;</span><br><span class="line"><span class="keyword">auto</span> ct = Foo&lt;<span class="keyword">int</span>&gt;::count();</span><br><span class="line">ct = fi.count();</span><br><span class="line">ct = Foo::count();<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="16-1-3-模板参数"><a class="header-anchor" href="#16-1-3-模板参数">¶</a>16.1.3 模板参数</h2>
<ul>
<li>
<p>模板参数与作用域</p>
<ul>
<li>模板参数遵循普通的作用域规则</li>
<li>模板参数会隐藏外层作用域中声明的相同名字</li>
<li>模板内不能重用模板参数名</li>
<li>一个模板参数名在一个特定模板参数列表中只能出现一次</li>
</ul>
</li>
<li>
<p>模板声明</p>
<p>一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前</p>
</li>
<li>
<p>使用类的类型成员</p>
<p>当我们希望通知编译器一个名字表示类型时，必须使用关键字typename，而不能使用class</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">T::size_type * p<span class="comment">//需要知道正在定义一个名字是p的变量，还是一个名为size_type的成员和名为p的成员相乘</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认情况下，C++语言假定通过作用域运算符访问的名字不是类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> T::<span class="function">value_type <span class="title">top</span><span class="params">(<span class="keyword">const</span> T&amp; c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!c.empty())</span><br><span class="line">        <span class="keyword">return</span> c.back();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typename</span> T::value_type();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>默认模板实参</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F = less&lt;T&gt;&gt;<span class="comment">//默认模板实参</span></span><br><span class="line"><span class="keyword">int</span> compare(<span class="keyword">const</span> T &amp;v1, <span class="keyword">const</span> T &amp;v2, F f = F())&#123;<span class="comment">//默认函数实参</span></span><br><span class="line">	<span class="keyword">if</span> (f(v1, v2)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (f(v2, v1)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> i = compare(<span class="number">0</span>, <span class="number">42</span>); <span class="comment">//使用less；i为-1</span></span><br><span class="line">Sales_data item1(cin), item2(cin);</span><br><span class="line"><span class="keyword">bool</span> j = compare(item1, item2, compareIsbn);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>模板默认实参与类模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span> = <span class="title">int</span>&gt; <span class="title">class</span> <span class="title">Numbers</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Numbers(T v = <span class="number">0</span>): val(v) &#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T val;</span><br><span class="line">&#125;;</span><br><span class="line">Numbers&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt; lots_of_precision;</span><br><span class="line">Numbers&lt;&gt; average_precision;<span class="comment">//空&lt;&gt;表示我们希望使用默认类型</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="16-1-4-成员模板"><a class="header-anchor" href="#16-1-4-成员模板">¶</a>16.1.4 成员模板</h2>
<blockquote>
<p>一个类可以包含本身是模板的成员函数，这种成员被称为成员模板。成员模板不能是虚函数。</p>
</blockquote>
<ul>
<li>
<p>普通（非模板）类的成员模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebugDelete</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DebugDelete(<span class="built_in">std</span>::ostream &amp;s = <span class="built_in">std</span>::<span class="built_in">cerr</span>) : os(s) &#123; &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *p)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        os &lt;&lt; <span class="string">"deleting unique_ptr"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::ostream &amp;os;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>, DebugDelete&gt; p(<span class="keyword">new</span> <span class="keyword">int</span>, DebugDelete());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>类模板的成员模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span> &#123;</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt; Blob(It b, It e);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;<span class="comment">//为Blob定义构造函数，接收两个迭代器。此构造函数有自己的模板类型参数It，作为两个函数参数的类型。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">	Blob&lt;T&gt;::Blob(It b, It e):</span><br><span class="line">			data(<span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt;(b, e)) &#123; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>实例化与成员模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; vi = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; w = &#123;<span class="string">"now"</span>, <span class="string">"is"</span>, <span class="string">"the"</span>, <span class="string">"time"</span>&#125;;</span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; a1(begin(ia), end(ia)); <span class="comment">// Blob&lt;int&gt;::Blob(int *, int *);</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; a2(vi.begin(), vi.end());</span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; a3(w.begin(), w.end());</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="16-1-5-控制实例化"><a class="header-anchor" href="#16-1-5-控制实例化">¶</a>16.1.5 控制实例化</h2>
<blockquote>
<p>两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中就都会有该模板的一个实例。多个文件中实例化相同模板额外开销很严重，可以通过显示实例化避免这种开销。</p>
</blockquote>
<p>显示实例化形式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration; <span class="comment">//实例化声明</span></span><br><span class="line"><span class="keyword">template</span> declaration; <span class="comment">//实例化定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//declaration是一个类或函数声明</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;string&gt;;</span> <span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>; <span class="comment">//定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//由于编译器在使用一个模板时自动对其实例化，所以extern声明必须出现在任何使用此实例化版本的代码之前</span></span><br><span class="line"><span class="comment">//对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Application.cc</span></span><br><span class="line"><span class="comment">//这些模板类型必须在程序其他位置进行实例化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;string&gt;;</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>;</span><br><span class="line">Blob&lt;<span class="built_in">string</span>&gt; sa1, sa2;<span class="comment">//在其他位置实例化</span></span><br><span class="line"><span class="comment">//Blob&lt;int&gt;及其构造函数在本文件中实例化</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; a1 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; a2(a1);</span><br><span class="line"><span class="keyword">int</span> i = compare(a1[<span class="number">0</span>], a2[<span class="number">0</span>]);<span class="comment">//其他位置实例化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//templateBuild.cc</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>;</span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;string&gt;;</span><span class="comment">//实例化类模板所有成员</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>实例化定义会实例化所有成员</p>
<p>在一个类模板的实例化定义中，所用类型必须能用于模板的所有成员</p>
</li>
</ul>
<h2 id="16-1-6-效率与灵活性"><a class="header-anchor" href="#16-1-6-效率与灵活性">¶</a>16.1.6 效率与灵活性</h2>
<blockquote>
<p>shared_ptr和unique_ptr之间的不同：</p>
<p>1.前者给予共享指针所有权的能力，后者独占指针；</p>
<p>2.前者在创建时或者reset指针时传递给它一个可调用对象即可，后者必须在定义时以显示模板实参的形式提供删除器类型；前者重载删除器更为方便，后者避免间接调用删除器的运行时开销；</p>
<p>重载删除器策略上的差异可能对性能有重要影响。</p>
</blockquote>
<ul>
<li>运行时绑定删除器
<ul>
<li>shared_ptr删除器必须保存为一个指针或一个封装了指针的类（如function），不是将删除器直接保存为一个成员，因为删除器类型到运行时才会知道；</li>
<li><code>del?del(p):delete p;//del(p)运行时转到del的地址</code>，调用删除器需要一次运行时的跳转操作；</li>
</ul>
</li>
<li>编译时绑定删除器
<ul>
<li>删除器可以直接保存在unique_ptr对象中；</li>
<li><code>del(p);//无运行时额外开销</code>，避免了间接调用删除器的运行时开销；</li>
</ul>
</li>
</ul>
<h1>16.2 模板实参推断</h1>
<h2 id="16-2-1-类型转换与模板类型参数"><a class="header-anchor" href="#16-2-1-类型转换与模板类型参数">¶</a>16.2.1 类型转换与模板类型参数</h2>
<p>  将实参传递给带模板类型的函数的形参时，能够自动应用的类型转换<strong>只有</strong>const转换以及数组或函数到指针的转换：</p>
<ol>
<li>
<p>const转换：将一个<strong>非const对象的引用或指针</strong>传递给一个<strong>const的引用或指针</strong>形参</p>
</li>
<li>
<p>数组或函数指针的转换：如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">fref</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;<span class="comment">//引用</span></span><br><span class="line">fref(a, b);<span class="comment">//错误：数组类型不匹配</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>
<p>使用相同模板参数类型的函数形参</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//compare接受两个const T&amp;参数</span></span><br><span class="line"><span class="keyword">long</span> lng;</span><br><span class="line">compare(lng, <span class="number">1024</span>); <span class="comment">//错误，不能实例化compare(long, int)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>正常类型转换用于普通函数的实参</p>
<p>如果函数参数类型不是模板参数，则对实参进行正常的类型转换</p>
</li>
</ul>
<h2 id="16-2-2-函数模板显式实参"><a class="header-anchor" href="#16-2-2-函数模板显式实参">¶</a>16.2.2 函数模板显式实参</h2>
<blockquote>
<p>某些情况下编译器无法推断出模板实参的类型。其他一些情况下，我们希望允许用户控制模板实例化。当函数返回类型与参数列表中任何类型都不同时，这两种情况最常出现。</p>
</blockquote>
<ul>
<li>
<p>指定显示模板实参</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span>  T3&gt;</span><br><span class="line"><span class="function">T1 <span class="title">sum</span><span class="params">(T2, T3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为T1提供一个显示模板实参</span></span><br><span class="line"><span class="keyword">auto</span> val3 = sum&lt;<span class="keyword">long</span> <span class="keyword">long</span> &gt;(i, lng);<span class="comment">//long long sum(int, long);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示模板实参按从左向右的顺序和对应的模板参数匹配；只有尾部的显示模板实参才可以忽略，前提是它可以从函数参数推断出来</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span>  T3&gt;</span><br><span class="line"><span class="function">T3 <span class="title">alternative_sum</span><span class="params">(T2, T1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> val3 = alternative_sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(i, lng);<span class="comment">//错误</span></span><br><span class="line"><span class="keyword">auto</span> val2 = alternative_sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>, <span class="keyword">long</span>&gt;(i, lng);<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>正常类型转换应用于显示指定的实参</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于模板类型参数已经显示指定了的函数实参，也进行正常的类型转换</span></span><br><span class="line"><span class="keyword">long</span> lng;</span><br><span class="line">compare(lng, <span class="number">1024</span>);</span><br><span class="line">compare&lt;<span class="keyword">long</span>&gt;(lng, <span class="number">1024</span>);</span><br><span class="line">compare&lt;<span class="keyword">int</span>&gt;(lng, <span class="number">1024</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="16-2-3-尾置返回类型与类型转换"><a class="header-anchor" href="#16-2-3-尾置返回类型与类型转换">¶</a>16.2.3 尾置返回类型与类型转换</h2>
<p>有一些情况下，要求指定显示模板实参会增加用户负担</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">??? &amp;fcn(It beg, It end)&#123;</span><br><span class="line">    <span class="keyword">return</span> *beg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以用decltype获取返回类型，但是在遇到函数的参数列表之前，beg都不存在</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//尾置返回允许我们在参数列表之后声明返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn(It beg, It end) -&gt; decltype(*beg)&#123;</span><br><span class="line">    <span class="keyword">return</span> *beg;<span class="comment">//返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>进行类型转换的标准库模板类</p>
<ul>
<li>
<p>标准库的类型转换模板remove_reference、remove_pointer、add_pointer、make_signed、make_unsigned、remove_extent、remove_all_extents、add_const、add_lvalue_reference、add_rvalue_reference</p>
</li>
<li>
<p>组合使用remove_reference、尾置返回以及decltype，可以在函数中返回元素值的拷贝</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn2(It beg, It end) -&gt;</span><br><span class="line">    <span class="keyword">typename</span> remove_reference&lt;<span class="keyword">decltype</span>(*beg)&gt;::type&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> *beg;<span class="comment">//返回元素的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="16-2-4-函数指针和实参推断"><a class="header-anchor" href="#16-2-4-函数指针和实参推断">¶</a>16.2.4 函数指针和实参推断</h2>
<ul>
<li>
<p>用函数模板初始化函数指针或为函数指针赋值，编译器使用指针的类型推断模板实参</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">//pf1指向int compare(const int&amp;, const int&amp;)</span></span><br><span class="line"><span class="keyword">int</span> (*pf1)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;) = compare;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>当参数是一个函数模板实例的地址时，程序上下文必须满足：对每个模板参数，能唯一确定其类型或值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>(*)(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>(*)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;))</span></span>;</span><br><span class="line">func(compare);<span class="comment">//错误，使用compare的哪个实例？</span></span><br><span class="line"></span><br><span class="line">func(compare&lt;<span class="keyword">int</span>&gt;);<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="16-2-5-模板实参推断和引用"><a class="header-anchor" href="#16-2-5-模板实参推断和引用">¶</a>16.2.5 模板实参推断和引用</h2>
<blockquote>
<p>template <typename t> void f(T &amp;p);</typename></p>
<p>编译器会应用正常的引用绑定规则；const是底层的，不是顶层的</p>
</blockquote>
<ul>
<li>
<p>从左值引用函数参数推断类型</p>
<ul>
<li>
<p>模板类型参数是一个普通的（左值）引用时，只能传递一个左值。若实参是const 的， 则T将会被推断为 const类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(T&amp;)</span></span>;   <span class="comment">// 实参必须是一个左值</span></span><br><span class="line"></span><br><span class="line">f1(i);   <span class="comment">// i 是一个 int; T 是 int</span></span><br><span class="line">f1(ci);  <span class="comment">// ci 是一个 const int； T 是 const int</span></span><br><span class="line">f1(<span class="number">43</span>);  <span class="comment">// 错误：传递给一个&amp;参数的实参必须是一个左值</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果类型参数是 const T&amp;， 那么可以传递给他任何类型的实参（一个对象，临时对象或一个字面值常量）。当 const 是函数参数本身时，T不会是一个 const 类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;   <span class="comment">// 任意类型</span></span><br><span class="line"><span class="comment">// f2 中参数是 cosnt &amp;; 实参中的const 是无关的</span></span><br><span class="line">f1(i);   <span class="comment">// i 是一个 int; T 是 int</span></span><br><span class="line">f1(ci);  <span class="comment">// ci 是一个 const int； T 是 int</span></span><br><span class="line">f1(<span class="number">43</span>);  <span class="comment">// 一个const &amp;参数可以绑定到右值; T 是 int</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>从右值引用函数参数推断类型</p>
<p>在实际中，模板参数的右值引用通常用于两种情况：模板转发其实参 或者 模板被重载。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp;)</span></span>;  </span><br><span class="line"></span><br><span class="line">f3(<span class="number">43</span>);  <span class="comment">// 实参是一个 int 类型的右值； 模板参数 T 是 int </span></span><br><span class="line">f3(i); <span class="comment">// 实参是一个 int 类型的左值； 模板参数 T 是 int&amp;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>引用折叠和右值引用参数</p>
<ul>
<li>两个例外规则
<ul>
<li>当我们将一个左值传递给右值引用参数时，且此右值引用指向模板类型参数(T&amp;&amp;)时，编译器推断模板类型参数为左值引用类型而非左值。</li>
<li>当我们间接创建一个引用的引用，如类型别名或模板参数，则这些引用形成了折叠：
<ul>
<li>T&amp; &amp;，T&amp; &amp;&amp;，T&amp;&amp; &amp;折叠为T&amp;</li>
<li>T&amp;&amp; &amp;&amp;折叠为T&amp;&amp;</li>
</ul>
</li>
</ul>
</li>
<li>所以如果一个函数参数是指向模板参数类型的右值引用，则可以传递给它任意类型的实参。如果将一个左值传递给这样的参数，则函数参数被实例化为了一个普通的左值引用。</li>
</ul>
</li>
<li>
<p>编写接受右值引用参数的模板函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp; val)</span></span>&#123;</span><br><span class="line">    T t = val;<span class="comment">//拷贝还是绑定一个引用</span></span><br><span class="line">    t = fcn(t);<span class="comment">//赋值只改变t还是即改变t又改变val</span></span><br><span class="line">    <span class="keyword">if</span>(val == t) &#123; <span class="comment">/* ... */</span> &#125;<span class="comment">//若T是引用类型，则一直为true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际中右值引用常用于：模板转发其实参或模板被重载</span></span><br><span class="line"><span class="comment">//使用右值引用的函数模板通常应该重载</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp;)</span></span>;<span class="comment">//绑定到非const右值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;<span class="comment">//绑定到左值和const右值</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="16-2-6-理解std-move"><a class="header-anchor" href="#16-2-6-理解std-move">¶</a>16.2.6 理解std::move</h2>
<ul>
<li>
<p>std::move如何定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>std::move如何工作</p>
<p>我们考虑如下代码的工作过程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string s1("hi"), s2;</span><br><span class="line">s2 = <span class="built_in">std</span>::move(<span class="built_in">string</span>(<span class="string">"hi"</span>));    <span class="comment">// 正确，从一个右值移动数据</span></span><br><span class="line">s2 = <span class="built_in">std</span>::move(s1);                <span class="comment">// 正确，但是在赋值之后，s1的值是不确定的</span></span><br></pre></td></tr></table></figure>
<p>在第一个赋值中，实参是string类型的右值，因此过程为：</p>
<ul>
<li>推断T的类型为 string</li>
<li>remove_reference<string> 的 type 成员是 string</string></li>
<li>move 返回类型是 string&amp;&amp;</li>
<li>move 的函数参数t的类型为 string&amp;&amp;</li>
</ul>
<p>因此，这个调用实例化 move<string>，即函数</string></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>&amp;&amp; <span class="title">move</span><span class="params">(<span class="built_in">string</span> &amp;&amp;t)</span></span></span><br></pre></td></tr></table></figure>
<p>在第二个赋值中，实参是一个左值，因此：</p>
<ul>
<li>推断T的类型为 string&amp;</li>
<li>remove_reference&lt;string&amp;&gt; 的 type 成员是 string</li>
<li>move 返回类型是 string&amp;&amp;</li>
<li>move 的函数参数t的类型为 string&amp; &amp;&amp;，会折叠成 string&amp;</li>
</ul>
<p>因此，这个调用实例化 move&lt;string&amp;&gt;，即</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>&amp;&amp; <span class="title">move</span><span class="params">(<span class="built_in">string</span> &amp;t)</span></span></span><br></pre></td></tr></table></figure>
<p>通常情况下，static_cast 只能用于其他合法的类型转换。但是有一条针对右值的特许规则：虽然不能隐式的将一个左值转换成右值引用，但我们可以用static_cast显示的将一个左值转换为一个右值</p>
<blockquote>
<p>统一使用std::move使得我们在程序中查找潜在的截断左值的代码变得很容易</p>
</blockquote>
</li>
</ul>
<h2 id="16-2-7-转发"><a class="header-anchor" href="#16-2-7-转发">¶</a>16.2.7 转发</h2>
<blockquote>
<p>某些函数需要将其一个或多个实参连同类型不变的转发给其他函数，这种情况下我们需要保持被转发实参的所有性质，包括实参类型是否是const的以及实参是左值还是右值。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(F f, T1 t1, T2 t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(t2, t1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subfunc</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">func(subfunc, i, <span class="number">2</span>);    <span class="comment">// i并没有增加</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>定义能保持类型信息的函数参数</p>
<ul>
<li>我们可以使用右值引用来解决上述问题：</li>
</ul>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(t2, t1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subfunc</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">func(subfunc, i, <span class="number">2</span>);    <span class="comment">// i增加了,而且也可以传递const</span></span><br></pre></td></tr></table></figure>
<ul>
<li>但是函数func对于接受一个左值引用的函数工作的很好，但不能接受右值引用参数的函数：</li>
</ul>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(t2, t1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subfunc</span><span class="params">(<span class="keyword">int</span> &amp;&amp;v1, <span class="keyword">int</span> &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">func(subfunc, i, <span class="number">2</span>);    <span class="comment">// 错误，不能从一个左值实例化int&amp;&amp;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>在调用中使用std::forward保持类型信息<br>
为了解决上述问题，我们可以使用一个名为forward的新标准库设施来传递参数，它能保持原始实参的类型。forward必须通过显示模板实参来调用。forward返回该显示实参类型的右值引用。</li>
</ul>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     f(<span class="built_in">std</span>::forward&lt;T2&gt;(t2), <span class="built_in">std</span>::forward&lt;T1&gt;(t1));    <span class="comment">// 通过引用折叠，左值还是左值，右值还是右值</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">subfunc</span><span class="params">(<span class="keyword">int</span> &amp;&amp;v1, <span class="keyword">int</span> &amp;v2)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     ++v2;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"> func(subfunc, i, <span class="number">2</span>);    <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<h1>16.3 重载与模板</h1>
<blockquote>
<p>函数模板可以被另一个模板或者一个非模板函数重载，名字相同的函数必须具有不同数量或类型的参数。涉及到函数模板，函数匹配规则满足：</p>
<ul>
<li>对于一个调用，其候选函数包括所有模板实参推断成功的函数模板实例</li>
<li>候选函数总是可行的，因为模板实参推断会排出任何不可行的模板</li>
<li>可行函数按照类型转换来排序</li>
<li>如果恰有一个函数提供比其他函数都更好的匹配，则选择此函数，如果有多个函数提供同样好的匹配，则：
<ul>
<li>如果同样好的函数中只有一个非模板函数，则选择此函数</li>
<li>如果没有非模板函数，有多个函数模板，则选择其中一个比其他模板更特例化的模板</li>
<li>否则此调用有歧义</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>
<p>编写重载模板</p>
<ul>
<li>
<p>下面函数可以生成一个对象对应的string表示，该对象是任何具备输出运算符的类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印任何我们不能处理的类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;tyename T&gt;<span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(<span class="keyword">const</span> T &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ostringstream</span> ret;</span><br><span class="line">    ret &lt;&lt; t;</span><br><span class="line">    <span class="keyword">return</span> ret.str();<span class="comment">//返回ret绑定的string副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>下面是打印指针的debug_rep版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印任何我们不能处理的类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;tyename T&gt;<span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(T *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ostringstream</span> ret;</span><br><span class="line">    ret &lt;&lt; p;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">        ret &lt;&lt; <span class="string">"pointer:"</span> &lt;&lt; p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret &lt;&lt; <span class="string">"null pointer"</span>;</span><br><span class="line">    <span class="keyword">return</span> ret.str();<span class="comment">//返回ret绑定的string副本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line">debug_rep(s);<span class="comment">//调用第一个版本的debug_rep</span></span><br><span class="line"><span class="comment">//只有第一个版本的debug_rep是可行的，第二版本要求一个指针参数</span></span><br><span class="line"></span><br><span class="line">debug_rep(&amp;s);<span class="comment">//调用第二版本的debug_rep</span></span><br><span class="line"><span class="comment">//第一版本能生成实例，其T的类型是string *，需要进行普通指针到const指针的转换</span></span><br><span class="line"><span class="comment">//第二版本T类型为string，此为更精确匹配</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>多个可行版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> *sp = &amp;s;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; debug_rep(sp) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个版本都是可行的，都是精确匹配</span></span><br><span class="line"><span class="comment">//第一个版本实例为：debug_rep&lt;string&amp;&gt;(const string *&amp;),T被绑定为string*</span></span><br><span class="line"><span class="comment">//第二个版本实例为：debug_rep&lt;const string&gt;(const string *)，T被绑定为const string</span></span><br><span class="line"><span class="comment">//由于第二版本比第一版本更加特例化，固解析为第二版本。第一个版本本质上可以用于任何类型，包括指针类型，第二个版本只能用于指针类型</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>非模板和模板重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>'<span class="string">"'+s+'"</span><span class="string">';</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line">debug_rep(s);<span class="comment">//调用第三个非模块版本的debug_rep</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一和第三个版本都能提供同样好的匹配</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一版本实例化为debug_rep&lt;string&gt;(const string &amp;),T被绑定到string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//存在同样好的模板和非模板函数时，编译器会选择非模板函数，当存在多个同样好的非模板函数时，编译器会选择最特例化的版本，一个非模板函数比模板函数更加特例化</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>重载与类型转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; debug_rep(<span class="string">"hello"</span>);<span class="comment">//调用第二版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上述三个版本都可行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//debug_rep(const T&amp;)，T为char[6]</span></span><br><span class="line"><span class="comment">//debug_rep(T*)，T为const char*</span></span><br><span class="line"><span class="comment">//debug_rep(const string&amp;)，要求从const char*到string的类型转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对给定的实参来说，第二个版本需要一次数组到指针的转换，这是精确匹配</span></span><br><span class="line"><span class="comment">//非模板版本需要一次用户定义的类型转换，因此没有精确匹配那么好</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果希望将字符指针按string处理，可以定义另外两个非模板的重载版本</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(<span class="keyword">char</span> *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> debug_rep(<span class="built_in">string</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> debug_rep(<span class="built_in">string</span>(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>缺少声明可能导致程序行为异常</p>
<ul>
<li>
<p>使用一个忘记声明的函数，代码将会编译失败</p>
</li>
<li>
<p>对于重载函数模板的函数，如果编译器可以从模板实例化出与调用匹配的版本，则缺少的声明就不重要了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(<span class="keyword">const</span> T &amp;t)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(T *p)</span></span>;</span><br><span class="line"><span class="comment">//为了使debug_rep(char *)的定义正确工作，下面声明必须在作用域中</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(<span class="keyword">char</span> *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果接受一个const string&amp;的版本的声明不在作用域中，则返回语句将调用debug_rep(const T&amp;)的T实例化为string的版本</span></span><br><span class="line">    <span class="keyword">return</span> debug_rep(<span class="built_in">string</span>(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1>16.4 可变参数模板</h1>
<blockquote>
<p>一个<strong>可变参数模板</strong>是一个接受可变数目参数的模板函数或模板类；</p>
<p>可变数目的参数被称为<strong>参数包</strong>；</p>
<p>存在两种参数包：<strong>模板参数包</strong>和<strong>函数参数包</strong>；</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp; ... rest)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; <span class="keyword">double</span> d = <span class="number">3.14</span>; <span class="built_in">string</span> s = <span class="string">"how now brown cow"</span>;</span><br><span class="line">foo(i, s, <span class="number">42</span>, d); <span class="comment">//void foo(const int&amp;, const string&amp;, const int&amp;, const double&amp;);</span></span><br><span class="line">foo(s, <span class="number">42</span>, <span class="string">"hi"</span>); <span class="comment">//void foo(const string&amp;, const int&amp;, const char[3]&amp;);</span></span><br><span class="line">foo(d, s); <span class="comment">//void foo(const double&amp;, const string&amp;);</span></span><br><span class="line">foo(<span class="string">"hi"</span>); <span class="comment">//void foo(const char[3]&amp;);</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>sizeof...</code>运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... Args&gt; <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(Args ... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//类型参数的数目</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//函数参数的数目、</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="16-4-1-编写可变参数函数模板"><a class="header-anchor" href="#16-4-1-编写可变参数函数模板">¶</a>16.4.1 编写可变参数函数模板</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; t; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp; ... rest)</span></span>&#123;</span><br><span class="line">	os &lt;&lt; t &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">	<span class="keyword">return</span> print(os, rest...); <span class="comment">//递归调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="16-4-2-包扩展"><a class="header-anchor" href="#16-4-2-包扩展">¶</a>16.4.2 包扩展</h2>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">&gt; ostream &amp;</span><br><span class="line">&gt; print(ostream &amp;os, <span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp;... rest) <span class="comment">//扩展Args</span></span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;     os &lt;&lt; t &lt;&lt;<span class="string">", "</span>;</span><br><span class="line">&gt;     <span class="keyword">return</span> print(os, rest...); <span class="comment">//扩展rest</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>两个扩展</p>
<ol>
<li>第一个扩展模板参数包，生成函数参数列表</li>
<li>第二个出现在对print的调用中，为print生成实参列表</li>
</ol>
</blockquote>
<ul>
<li>
<p>理解包扩展</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream <span class="title">error_Msg</span><span class="params">(ostream&amp; os, <span class="keyword">const</span> Args&amp;... rest)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> print(os, debug_rep(rest)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用error_Msg(cerr, fcnName, code.num())相当于编写print(cerr, debug_rep(fcnName), debug_rep(code.num()));</span></span><br><span class="line"><span class="comment">//print(os, debug_rep(rest...));会编译失败</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>扩展中的模式会独立地应用于包中的每个元素</p>
</blockquote>
</li>
</ul>
<h2 id="16-4-3-转发参数包"><a class="header-anchor" href="#16-4-3-转发参数包">¶</a>16.4.3 转发参数包</h2>
<ul>
<li>
<p>首先为了保持实参中的类型信息，必须将函数参数定义为模板类型参数的右值引用</p>
</li>
<li>
<p>其次，当将实参传递给移动构造函数时，必须使用forward来保持实参的原始类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span></span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">StrVec</span>:</span>:emplace_back(Args&amp;&amp;... args)&#123;</span><br><span class="line">	chk_n_alloc();</span><br><span class="line">	alloc.construct(first_free++, <span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//svec.emplace_back(10, 'c');</span></span><br><span class="line"><span class="comment">//construct调用中会扩展出std::forward&lt;int&gt;(10), std::forward&lt;char&gt;(c)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>转发和可变参数模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(Args&amp;&amp;... args)</span> <span class="comment">//Args扩展为右值引用的列表</span></span></span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;     <span class="comment">//既扩展Args又扩展args</span></span><br><span class="line">&gt;     work(<span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>由于fun的参数是右值引用，因此我们可以传递给它任意类型的实参；</p>
<p>由于我们使用std::forward传递这些实参，所以它们的所有类型信息都会得到保持；</p>
</blockquote>
</li>
</ul>
<h1>16.5 模板特例化</h1>
<ul>
<li>
<p>定义函数模板特例化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p1, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对template &lt;typename T&gt; int compare(const T&amp;, const T&amp;);特例化</span></span><br><span class="line"><span class="comment">//其中T为const char *，我们的函数要求指向此类型const版本的引用</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>函数重载与模板特例化</p>
<ul>
<li>特例化的本质是实例化一个模板，而非重载它，因此不影响函数匹配；</li>
<li>模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面，然后是特例化版本；</li>
</ul>
</li>
<li>
<p>类模板特例化</p>
<blockquote>
<p>特例化容器的hash&lt;key_type&gt;</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;<span class="comment">//打开std命名空间</span></span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;Sales_data&gt;</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">size_t</span> result_type;</span><br><span class="line">        <span class="keyword">typedef</span> Sales_data argument_type;<span class="comment">//默认情况下，此类型需要==</span></span><br><span class="line">        <span class="keyword">size_t</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> Sales_data&amp; s) <span class="keyword">const</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">size_t</span> hash&lt;Sales_data&gt;::<span class="keyword">operator</span>()(<span class="keyword">const</span> Sales_data&amp; s) <span class="keyword">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> hash&lt;<span class="built_in">string</span>&gt;()(s.bookNo) ^</span><br><span class="line">                hash&lt;<span class="keyword">unsigned</span>&gt;()(s.units_sold) ^</span><br><span class="line">                hash&lt;<span class="keyword">double</span>&gt;()(s.revenue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//关闭std命名空间，没有分号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用hash&lt;Sales_data&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">std</span>:</span>:hash;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:hash&lt;Sales_data&gt;;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//为了让Sales_data的用户能使用hash的特例化版本，我们应该在Sales_data的头文件中定义该特例化版本</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>类模板部分特例化</p>
<ul>
<li>一个类的部分特例化本身是一个模板，使用时还必须为那些在特例化版本中未指定的模板参数提供实参；</li>
<li>只能部分特例化类模板，而不能部分特例化函数模板；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">remove_reference</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T type;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//部分特例化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&gt; &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T type;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&amp;&gt; &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T type;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">//decltype(42)为int，使用原始模板</span></span><br><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(<span class="number">42</span>)&gt;::type a;</span><br><span class="line"><span class="comment">//decltype(i)为int&amp;，使用(T&amp;)模板</span></span><br><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(i)&gt;::type b;</span><br><span class="line"><span class="comment">//decltype(std::move(i))为int&amp;&amp;，使用(T&amp;&amp;)模板</span></span><br><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(<span class="built_in">std</span>::move(i))&gt;::type c;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>特例化成员而不是类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    Foo(<span class="keyword">const</span> T &amp;t = T()): mem(t) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Bar</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    T mem;</span><br><span class="line">    <span class="comment">//Foo的其他成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="comment">//特例化模板</span></span><br><span class="line"><span class="keyword">void</span> Foo&lt;<span class="keyword">int</span>&gt;::Bar()<span class="comment">//特例化Foo&lt;int&gt;的成员Bar</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 应用于int的特例化处理</span></span><br><span class="line">&#125;</span><br><span class="line">Foo&lt;<span class="built_in">string</span>&gt; fs; <span class="comment">//实例化Foo&lt;string&gt;::Foo()</span></span><br><span class="line">fs.Bar(); <span class="comment">//实例化Foo&lt;string&gt;::Bar()</span></span><br><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi; <span class="comment">//实例化Foo&lt;int&gt;::Foo()</span></span><br><span class="line">fi.Bar(); <span class="comment">//使用特例化的Foo&lt;int&gt;::Bar()</span></span><br></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/21/C-Primer学习笔记：第15章-面向对象程序设计/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/21/C-Primer学习笔记：第15章-面向对象程序设计/" itemprop="url">C++ Primer学习笔记：第15章 面向对象程序设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-21T22:53:00+08:00">2019-07-21</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>15.1 OOP：概述</h1>
<ul>
<li>
<p>继承</p>
<p>基类、派生类、虚函数、类派生列表、virtual、override</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> override</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>动态绑定</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">print_total</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> Quote &amp;item, <span class="keyword">size_t</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ret = item.net_price(n);</span><br><span class="line">    os &lt;&lt; <span class="string">"ISBN: "</span> &lt;&lt; item.isbn() </span><br><span class="line">        &lt;&lt; <span class="string">" # sold: "</span> &lt;&lt; n &lt;&lt; <span class="string">" total due: "</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>15.2 定义基类和派生类</h1>
<h2 id="15-2-1-定义基类"><a class="header-anchor" href="#15-2-1-定义基类">¶</a>15.2.1 定义基类</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Quote() = <span class="keyword">default</span>;</span><br><span class="line">    Quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;book, <span class="keyword">double</span> sales_price):</span><br><span class="line">            bookNo(book), price(sales_price) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>基类通常都应该定义一个虚析构函数</p>
</blockquote>
<ul>
<li>
<p>成员函数与继承</p>
<ul>
<li>virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义；</li>
<li>如果一个函数声明成虚函数，则在派生类中也隐式的是虚函数；</li>
<li>任何构造函数之外的非静态函数都可以是虚函数；</li>
</ul>
</li>
<li>
<p>访问控制</p>
<p>protected用于希望它的派生类有权访问，同时禁止其他用户访问</p>
</li>
</ul>
<h2 id="15-2-2-定义派生类"><a class="header-anchor" href="#15-2-2-定义派生类">¶</a>15.2.2 定义派生类</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Bulk_quote() = <span class="keyword">default</span>;</span><br><span class="line">    Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;, <span class="keyword">double</span>, <span class="built_in">std</span>::<span class="keyword">size_t</span>, <span class="keyword">double</span>);</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> override</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> min_qty = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> discount = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>访问说明符的作用是控制派生类从基类继承而来的成员是否对派生类的用户可见</p>
</blockquote>
<ul>
<li>
<p>派生类中的虚函数</p>
<p>在形参列表后面、或者在const成员函数的const关键字后面、或者在引用成员函数的引用限定符后面添加一个关键字</p>
</li>
<li>
<p>派生类对象及派生类向基类的类型转换</p>
<p>派生类对象中含有基类对应的组成部分，这是继承的关键所在</p>
</li>
<li>
<p>派生类构造函数</p>
<p>除非特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化；</p>
<p>如果想使用其他的基类构造函数，需要以类名加圆括号内的实参列表的形式为构造函数提供初始值；</p>
</li>
<li>
<p>派生类使用基类的成员</p>
<blockquote>
<p>每个类负责定义各自的接口。要想与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类部分</p>
</blockquote>
</li>
<li>
<p>继承与静态成员</p>
<p>静态成员在整个继承体系中只存在该成员的唯一定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">statmem</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> Derived&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Derived::f(<span class="keyword">const</span> Derived &amp;derived_obj)&#123;</span><br><span class="line">    Base::statmem();</span><br><span class="line">    Derived::statmem();</span><br><span class="line">    derived_obj.statmem();</span><br><span class="line">    statmem();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>派生类的声明</p>
<blockquote>
<p>声明语句的目的是令程序知晓某个名字的存在以及该名字表示什么样的实体。</p>
</blockquote>
</li>
<li>
<p>被用作基类的类</p>
<ul>
<li>
<p>想使用类作为基类，则该类必须已经定义而非仅仅声明；</p>
</li>
<li>
<p>直接基类、间接基类；</p>
</li>
</ul>
</li>
<li>
<p>防止继承（类名后的final关键字）</p>
</li>
</ul>
<h2 id="15-2-3-类型转换与继承"><a class="header-anchor" href="#15-2-3-类型转换与继承">¶</a>15.2.3 类型转换与继承</h2>
<blockquote>
<p>可以将一个派生类对象的指针存储在一个基类的智能指针内</p>
</blockquote>
<ul>
<li>
<p>静态类型与动态类型</p>
<ul>
<li>
<p>如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致；</p>
</li>
<li>
<p>基类的指针或引用的静态类型可能与其动态类型不一致；</p>
</li>
</ul>
</li>
<li>
<p>不存在从基类向派生类的隐式类型转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line">Quote *itemP = &amp;bulk;</span><br><span class="line">Bulk_quote *bulkP = itemP;<span class="comment">//错误：不能将基类转换成派生类</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在对象之间不存在类型转换</p>
<blockquote>
<p>当我们用一个派生类型对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动赋值，它的派生类部分将被忽略掉。</p>
</blockquote>
<p>派生类向基类的自动类型转换只对指针或引用有效，在派生类类型和基类类型之间不存在这样的转换</p>
</li>
</ul>
<h1>15.3 虚函数</h1>
<ul>
<li>
<p>对虚函数的调用可能在运行时才被解析</p>
<ul>
<li>
<p>对非虚函数的调用和通过对象进行的函数调用在编译时绑定；</p>
</li>
<li>
<p>只有通过指针或引用调用虚函数，才会在运行时解析该调用，也只有这种情况动态类型才有可能和静态类型不同；</p>
</li>
</ul>
</li>
<li>
<p>派生类中的虚函数</p>
<ul>
<li>派生类的虚函数必须和基类的虚函数形参完全一致；</li>
<li>返回类型也该完全一致；该规则存在例外，当类的虚函数的返回类型是类本身的指针或引用，这样的返回类型要求从派生类到基类的类型转换是可访问的；</li>
</ul>
</li>
<li>
<p>final和override说明符</p>
<ul>
<li>派生类可以定义一个与基类虚函数名字相同但是形参列表不同的函数。这种错误往往难以发现，可以用override声明此函数为虚函数的覆盖来避免这样的错误</li>
<li>通过final声明，任何尝试覆盖该函数的操作都将发生错误</li>
</ul>
</li>
<li>
<p>虚函数与默认实参</p>
<p>通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中函数版本也是如此。</p>
<blockquote>
<p>如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。</p>
</blockquote>
</li>
<li>
<p>回避虚函数的机制</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> undiscounted = baseP-&gt;Quote::net_price(<span class="number">42</span>);</span><br><span class="line"><span class="comment">//强行调用基类中定义的函数版本而不管baseP的动态类型是什么</span></span><br><span class="line"><span class="comment">//只有成员函数（或友元）中的代码才需要使用作用域运算符来回避虚函数机制</span></span><br></pre></td></tr></table></figure>
<p>当一个派生类的虚函数调用它覆盖的基类的虚函数版本时，需要回避虚函数的默认机制。如果一个派生类虚函数调用它的基类版本，但是没有使用作用域运算符，则该调用将在运行时被解析为对派生类版本自身的调用，从而导致无限递归。</p>
</li>
</ul>
<h1>15.4 抽象基类</h1>
<ul>
<li>
<p>纯虚函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Disc_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Disc_quote() = <span class="keyword">default</span>;</span><br><span class="line">    Disc_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> price, <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc):</span><br><span class="line">            Quote(book, price),</span><br><span class="line">            quantity(qty), discount(disc) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> quantity = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> discount = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>纯虚函数无须定义；</p>
<p>= 0 只能出现在类内部的虚函数声明语句处；</p>
<p>也可以为纯虚函数提供定义，函数体必须定义在类外部</p>
</li>
<li>
<p>含有纯虚函数的类是抽象基类</p>
<p>不能直接创建抽象基类的对象</p>
</li>
<li>
<p>派生类构造函数只初始化它的直接基类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Disc_quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Bulk_quote() = <span class="keyword">default</span>;</span><br><span class="line">    Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> price,</span><br><span class="line">               <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc):</span><br><span class="line">        Disc_quote(book, price, qty, disc) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> override</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在Quote的继承体系中增加Disc_quote类是重构的一个典型示例。</p>
</blockquote>
</li>
</ul>
<h1>15.5 访问控制与继承</h1>
<ul>
<li>
<p>受保护的成员</p>
<ul>
<li>
<p>和私有成员类似，受保护的成员对于类的用户来说是不可访问的</p>
</li>
<li>
<p>和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的</p>
</li>
<li>
<p>派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于基类对象中的受保护成员没有任何访问特权</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> prot_mem;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sneaky</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>; <span class="comment">//能访问Sneaky::prot_mem</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base&amp;)</span></span>; <span class="comment">//不能访问Base::prot_mem</span></span><br><span class="line">    <span class="keyword">int</span> j; <span class="comment">//j默认是private</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确：clobber能访问Sneaky对象的private和protected成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span> </span>&#123; s.j = s.prot_mem = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">//错误：clobber不能访问Base的protected成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span> </span>&#123; b.prot_mem = <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员；对于普通基类对象中的成员不具有特殊的访问权限。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>公有、私有和受保护继承</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pub_mem</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> prot_mem;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> priv_mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pub_Derv</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="comment">//正确，派生类能访问protected成员</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123; reurn prot_mem; &#125;</span><br><span class="line">    <span class="comment">//错误，private成员对于派生类不可见</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> priv_mem; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Priv_Derv</span> :</span> <span class="keyword">private</span> Base &#123;</span><br><span class="line">    <span class="comment">//private不影响派生类的访问权限</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; reutrn prot_mem; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pub_Derv d1;<span class="comment">//继承自Base的成员是public</span></span><br><span class="line">Priv_Derv d2;<span class="comment">//继承自Base的成员是private</span></span><br><span class="line">d1.pub_mem();<span class="comment">//正确，pub_mem在派生类中是public的</span></span><br><span class="line">d2.pub_mem();<span class="comment">//错误，pub_mem在派生类中是private的</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived_from_Public</span> :</span> <span class="keyword">public</span> Pub_Derv &#123;</span><br><span class="line">    <span class="comment">//正确，Base::prot_mem在Pub_Derv中仍然是protected的</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">use_base</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> prot_mem; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived_from_Private</span> :</span> <span class="keyword">public</span> Priv_Derv &#123;</span><br><span class="line">    <span class="comment">//错误，Base::prot_mem在Priv_Derv中是private的</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">use_base</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> prot_mem; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生访问说明符对于派生类的成员（及友元）能否访问其直接基类的成员没什么影响</span></span><br><span class="line"><span class="comment">//对基类成员的访问权限只与基类中的访问说明符有关</span></span><br><span class="line"><span class="comment">//派生访问说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>
<p>派生类向基类转换的可访问性</p>
<p>假设Derived继承自Base：</p>
<ul>
<li>
<p>只有当Derived公有继承Base时，用户代码才能使用派生类向基类的转换；如果Derived继承Base是protected或private，则用户代码不能使用该转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// code segment...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// code segment...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">protected</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// code segment...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D3</span> :</span> <span class="keyword">private</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// code segment...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D1 d1 = <span class="keyword">new</span> D1();</span><br><span class="line">    D2 d2 = <span class="keyword">new</span> D2();</span><br><span class="line">    D3 d3 = <span class="keyword">new</span> D3();</span><br><span class="line"></span><br><span class="line">    Base B1 = d1;     <span class="comment">// publiuc继承，正确</span></span><br><span class="line">    Base B2 = d2;     <span class="comment">// protected继承，错误</span></span><br><span class="line">    Base B3 = d3;     <span class="comment">// privat继承，错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>不论Derived以什么方式继承Base，Derived的成员函数和友元都能使用派生类向基类的转换；派生类对于其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    fun();</span><br><span class="line">    <span class="comment">// others...    </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">UseBaseFun</span><span class="params">(Base b)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TestFun</span><span class="params">(Base b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseBaseFun</span><span class="params">(Base b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b.fun();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Derived::TestFun(Base b)</span><br><span class="line">&#123;</span><br><span class="line">    b.fun();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived d1 = <span class="keyword">new</span> Derived();</span><br><span class="line">    Derived d2 = <span class="keyword">new</span> Derived();</span><br><span class="line">    <span class="comment">// 参数是派生类向基类的转换，正确</span></span><br><span class="line">    d2.UseBaseFun(d1);   </span><br><span class="line">    d2.TestBase(d1);     </span><br><span class="line"></span><br><span class="line">    retunr <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果Derived继承Base的方式是public或protected，则Derived的派生类的成员和友元可以使用Derived向Base的类型转换；反之，如果Derived继承Base的方式是private，则不能使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    fun();</span><br><span class="line">    <span class="comment">// others...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span>/<span class="keyword">protected</span>/<span class="keyword">private</span> Base</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">subDerived</span> :</span> <span class="keyword">public</span> Derived</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Test3rdSen</span><span class="params">(Base b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test3rdSen</span><span class="params">(Base b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b.fun();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived d = <span class="keyword">new</span> Derived();</span><br><span class="line">    subDerived sd = <span class="keyword">new</span> subDerived();</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 如果subDerived继承Derived的方式是public或protected下面这句                        </span></span><br><span class="line"><span class="comment">        话正确,如果继承方式是private，则下面这句话是错误的 */</span></span><br><span class="line">     sd.Test3rdSen(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>类有三种用户：</p>
<p>普通用户编写代码使用类的对象，这部分只能访问类的公有成员；</p>
<p>类的实现者负责编写类的成员和友元的代码，成员既能访问类的公有，也能访问类的私有（实现）部分；</p>
<p>派生类，基类把它希望派生类能够使用的部分声明为受保护的。普通用户不能访问受保护成员，而派生类及其友元仍旧不能访问私有成员；</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>友元与继承</p>
<ul>
<li>
<p>友元关系不能继承</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(Base b)</span> </span>&#123; <span class="keyword">return</span> b.prot_mem; &#125; <span class="comment">//正确，Pal是Base的友元</span></span><br><span class="line">  <span class="comment">//class Sneaky : public Base &#123;...&#125;</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">(Sneaky s)</span> </span>&#123; <span class="keyword">return</span> s.j; &#125; <span class="comment">//错误，Pal不是Sneaky的友元</span></span><br><span class="line">  <span class="comment">//对基类的访问权限由基类本身控制，即使对于派生类的基类部分也是如此</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">f3</span><span class="params">(Sneaky s)</span> </span>&#123;<span class="keyword">return</span> s.prot_mem; &#125; <span class="comment">//正确，Pal是Base的友元</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>当一个类将另一个类声明为友元时，这种友元关系只对做出声明的类有效。对原来的那个类来说，其友元的基类或者派生类不具有特殊访问能力</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> Pal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mem</span><span class="params">(Base b)</span> </span>&#123; <span class="keyword">return</span> b.prot_mem; &#125;<span class="comment">//错误，友元关系不能继承</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>改变个别成员的可访问性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> size() <span class="keyword">const</span> &#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::size;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>默认情况下，继承来的size和n是Derived的私有成员。然而，使用using可以改变成员的可访问性，使得Derived的用户可以使用size成员，而Derived的派生类将能使用n</li>
<li>通过在类的内部使用using，可以将直接间接基类的任何可访问成员标记出来。using声明语句中的访问权限由该using语句之前的访问说明符来决定，比如如果using出现在类的private部分，则该名字只能被成员和友元访问</li>
</ul>
<blockquote>
<p>派生类只能为那些它可以访问的名字提供using声明</p>
</blockquote>
</li>
<li>
<p>默认的继承保护级别</p>
<blockquote>
<p>struct关键字和class关键字定义的类之间唯一的差别就是默认成员访问说明符和默认派生说明符。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span> :</span> Base &#123; <span class="comment">/* ... */</span> &#125;; <span class="comment">//默认public继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> Base &#123; <span class="comment">/* ... */</span> &#125;; <span class="comment">//默认private继承</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>15.6 继承中的类作用域</h1>
<p>派生类作用域位于基类作用域之内</p>
<ul>
<li>
<p>编译时进行名字查找</p>
<p>能使用哪些成员仍然是<strong>由静态类型决定</strong>的</p>
</li>
<li>
<p>名字冲突与继承</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    Base() : mem(<span class="number">0</span>) &#123; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> mem;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line">    Derived(<span class="keyword">int</span> i) : mem(i) &#123; &#125; <span class="comment">//用i初始化Derived::mem，Base::mem进行默认初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_mem</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mem; &#125; <span class="comment">//返回Derived::mem</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>派生类的成员将隐藏同名的基类成员</p>
</blockquote>
</li>
<li>
<p>通过作用域运算符来使用隐藏成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_base_mem</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Base::mem; &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字</p>
</blockquote>
<p>类型查找与继承(p-&gt;mem()或obj.mem())</p>
<ul>
<li>首先确定p或obj的静态类型</li>
<li>在p或obj的静态类型对应的类中查找mem。找不到，则依次在基类的继承链中查找，没找到则编译报错</li>
<li>一旦找到mem，进行常规的类型检查以确认对于当前的mem，本次调用是否合法
<ul>
<li>如果mem是虚函数且我们通过指针或引用调用，则动态确定运行哪个虚函数版本</li>
<li>如果mem不是虚函数或者我们是通过对象进行的调用，则产生一个常规的函数调用</li>
</ul>
</li>
</ul>
</li>
<li>
<p>一如往常，名字查找先于类型检查</p>
<ul>
<li>
<p>派生类的函数不会重载基类的成员；</p>
</li>
<li>
<p>如果派生类的成员和基类的成员同名，则派生类将在其作用域隐藏该基类成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">memfcn</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">memfcn</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">//隐藏基类的memfcn</span></span><br><span class="line">&#125;;</span><br><span class="line">Derived d; Base b;</span><br><span class="line">b.memfcn();</span><br><span class="line">d.memfcn(<span class="number">10</span>);</span><br><span class="line">d.memfcn(); <span class="comment">//错误</span></span><br><span class="line">d.Base::memfcn();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>虚函数与作用域</p>
<p>假如基类与派生类的虚函数接受的实参不同，则我们就无法通过基类的引用或指针调用派生类的虚函数了</p>
</li>
<li>
<p>通过基类调用隐藏的虚函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> D1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Base bobj; D1 d1obj; D2 d2obj;</span><br><span class="line"> </span><br><span class="line">Base *bp1 = &amp;bobj; *bp2 = &amp;d1obj; *bp3 = &amp;d2obj;</span><br><span class="line">bp1-&gt;fcn();    <span class="comment">//Base::fcn</span></span><br><span class="line">bp2-&gt;fcn();    <span class="comment">//Base::fcn</span></span><br><span class="line">bp3-&gt;fcn();    <span class="comment">//D2::fcn</span></span><br><span class="line"> </span><br><span class="line">D1 *d1p = &amp;d1obj; D2 *d2p = &amp;d2obj;</span><br><span class="line">bp2-&gt;f2();    <span class="comment">//错误，Base没有f2()</span></span><br><span class="line">d1p-&gt;f2();    <span class="comment">//虚调用，运行时调用D1::f2()</span></span><br><span class="line">d2p-&gt;f2();    <span class="comment">//虚调用，运行时调用D2::f2()</span></span><br><span class="line"> </span><br><span class="line">Base *p1 = &amp;d2obj; D1 *p2 = &amp;d2obj; D2 *p3 = &amp;d2obj;</span><br><span class="line">p1-&gt;fcn(<span class="number">42</span>);    <span class="comment">//错误，Base没有fcn(int)</span></span><br><span class="line">p2-&gt;fcn(<span class="number">42</span>);    <span class="comment">//静态绑定，调用D1::fcn(int)</span></span><br><span class="line">p3-&gt;fcn(<span class="number">42</span>);    <span class="comment">//静态绑定，调用D2::fcn(int)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>覆盖重载的函数</p>
<p>如果派生类希望所有重载版本对于它都是可见的，那么它就需要覆盖所有版本或者一个也不覆盖；</p>
<p>有时仅需要覆盖集合中的一些而非全部函数，此时可以为重载成员提供using声明语句；</p>
<p>类内using声明的规则同样适用于重载函数的名字；</p>
<p>基类函数的每个实例在派生类中都必须是可访问的；</p>
<p>对派生类没有重新定义的重载版本的访问其实是对using声明点的访问；</p>
</li>
</ul>
<h1>15.7 构造函数与拷贝控制</h1>
<h2 id="15-7-1-虚析构函数"><a class="header-anchor" href="#15-7-1-虚析构函数">¶</a>15.7.1 虚析构函数</h2>
<p>如果一个类需要析构函数，那么它也同样需要拷贝和赋值操作；基类的析构函数并不遵循这个规则，它是一个重要的例外。基类总是需要析构函数，且为了成为虚函数而令内容为空，无法推断基类是否还需要赋值或拷贝运算符。</p>
<p>虚析构函数将阻止合成移动操作，如果一个类定义了析构函数，即使它通过=default的形式使用了合成版本，编译器也不会为这个类合成移动操作。（不太理解？？？）</p>
<h2 id="15-7-2-合成拷贝控制与继承"><a class="header-anchor" href="#15-7-2-合成拷贝控制与继承">¶</a>15.7.2 合成拷贝控制与继承</h2>
<p>合成的成员对类本身的成员依次进行初始化、赋值或销毁的操作；</p>
<p>合成的成员还负责使用基类中的对应的操作对一个对象的直接基类部分进行初始化、赋值或者销毁操作；</p>
<p>Quote基类定义了析构函数不能拥有合成的移动操作，移动Quote对象实际上使用的是合成的拷贝操作；</p>
<p>Quote没有移动操作意味着它的派生类也没有；</p>
<ul>
<li>
<p>派生类中删除的拷贝控制与基类的关系</p>
<p>某些定义基类的方式可能导致有的派生类成员成为被删除的对象：</p>
<ol>
<li>
<p>如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或者析构函数是被删除的函数或者是不可访问的，则派生类中<strong>对应的成员</strong>将是被删除的，原因是编译器不能使用基类成员来执行派生类对象中基类部分的构造、赋值或销毁操作；</p>
</li>
<li>
<p>如果在基类中有一个不可访问或删除的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分；</p>
</li>
<li>
<p>和之前一样，编译器不会合成一个删除掉的移动操作。 当使用=default操作请求一个移动操作时，如果基类中对应的操作时被删除的或者是不可访问的，那么派生类中该函数将是被删除的，原因是派生类中基类部分不可移动，同样，如果基类的析构函数是删除的或是不可访问的，则派生类的移动构造函数也将是被删除的。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	B();</span><br><span class="line">	B(<span class="keyword">const</span> B&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="comment">//没有声明任何构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line">D d;			<span class="comment">//正确：D的合成默认构造函数使用B的合成默认构造函数</span></span><br><span class="line"><span class="function">D <span class="title">d2</span><span class="params">(d)</span></span>;		<span class="comment">//错误：D的合成拷贝构造函数是被删除的</span></span><br><span class="line"><span class="function">D <span class="title">d3</span><span class="params">(<span class="built_in">std</span>::move(d))</span></span>;		<span class="comment">//错误，隐式的使用D的被删除的拷贝构造函数</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在实际编程过程中，如果在基类中没有默认、拷贝和移动构造函数，则一般情况下派生类也不会定义相应操作</p>
</blockquote>
</li>
<li>
<p>移动操作与继承</p>
<ul>
<li>
<p>大多数基类都会定义一个虚析构函数，因此在默认情况下，基类通常不含有合成的移动函数，而且它的派生类中也没有合成的移动操作。因为<strong>基类缺少移动操作会阻止派生类拥有自己的合成移动操作</strong>，所以当确实需要执行移动操作时<strong>应当首先在基类中定义</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Quote() = <span class="keyword">default</span>;<span class="comment">//成员依次默认初始化（为什么需要显示default？可以不吗？）</span></span><br><span class="line">    Quote(<span class="keyword">const</span> Quote&amp;) = <span class="keyword">default</span>;<span class="comment">//成员依次拷贝</span></span><br><span class="line">    Quote(Quote&amp;&amp;) = <span class="keyword">default</span>;<span class="comment">//成员依次拷贝</span></span><br><span class="line">    Quote&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Quote&amp;) = <span class="keyword">default</span>;<span class="comment">//拷贝赋值</span></span><br><span class="line">    Quote&amp; <span class="keyword">operator</span>=(Quote&amp;&amp;) = <span class="keyword">default</span>;<span class="comment">//移动赋值</span></span><br><span class="line">    <span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">//其他与之前版本一致</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//除非Quote的派生类有排斥移动的成员，否则它们将自动获得合成的移动操作</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="15-7-3-派生类的拷贝控制成员"><a class="header-anchor" href="#15-7-3-派生类的拷贝控制成员">¶</a>15.7.3 派生类的拷贝控制成员</h2>
<blockquote>
<p>派生类的构造函数要初始化自己和基类部分的成员；</p>
<p>派生类的拷贝和移动构造函数要拷贝和移动自己和基类部分的成员；</p>
</blockquote>
<ul>
<li>
<p>定义派生类的拷贝或移动构造函数</p>
<p>当为派生类定义拷贝或移动构造函数时，通常使用对应的基类的构造函数初始化派生类对象的基类的部分</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span><span class="comment">/*...*/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	D(<span class="keyword">const</span> D&amp; d):Base(d)&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">	D(D&amp;&amp; d):Base(<span class="built_in">std</span>::move(d))&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>派生类赋值运算符</p>
<p>与拷贝和移动构造函数一样，派生类的赋值运算符也必须显示的为派生类对象的基类部分赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D&amp; D::<span class="keyword">operator</span>=(<span class="keyword">const</span> D&amp; rhs)&#123;</span><br><span class="line">	Base::<span class="keyword">operator</span>=(rhs);          <span class="comment">//为基类部分赋值</span></span><br><span class="line">	<span class="comment">/*......*/</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>派生类析构函数</p>
<p>派生类析构函数只负责销毁自己的资源，<code>Base::~Base</code>自动执行</p>
</li>
<li>
<p>在构造和析构函数中调用虚函数</p>
<p>如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本</p>
</li>
</ul>
<h2 id="15-7-4-继承的构造函数"><a class="header-anchor" href="#15-7-4-继承的构造函数">¶</a>15.7.4 继承的构造函数</h2>
<blockquote>
<p>在C++11新标准中，派生类能够重用其直接基类定义的构造函数；</p>
<p>因为<strong>一个类只初始化它的直接基类，所以一个类也只继承其直接基类的构造函数</strong>；</p>
<p>类<strong>不能继承默认、拷贝和移动构造函数</strong>，如果派生类没有直接定义这些构造函数，编译器将为派生类合成它们；</p>
<p>派生类继承基类的构造函数的方式是<strong>提供一条注明了直接基类名的using声明语句</strong>；</p>
<p>通常情况下，using声明语句只是令某个名字在当前作用域可见，但当作用于构造函数的时候，using语句将令编译器产生代码；</p>
<p>对于基类的每一个构造函数，编译器都生成一个与之对应的派生类的构造函数，即对于基类的每个构造函数，在派生类中都有一个<strong>形参列表完全相同</strong>的构造函数；</p>
</blockquote>
<p>继承的构造函数的特点</p>
<ul>
<li>与普通成员的using声明不同，一个构造函数的using声明不会改变该构造函数的访问等级。例如，不管using声明出现在哪里，基类的私有构造函数在派生类中还是一个私有构造函数</li>
<li>一个using声明语句不能指定<strong>explicit</strong>（声明为explicit的构造函数不能在隐式转换中使用）或<strong>consexpr</strong>（constexpr表示一个函数或者表达式可以在编译时就求出值,constexpr构造函数的函数体一般为空，使用初始化列表或者其他的constexpr构造函数初始化所有数据成员。）。如果基类的构造函数是explicit或consexpr的，则在派生类中继承来的构造函数也有同样的属性</li>
<li>当一个基类构造函数含有默认实参时，这些实参并不会被继承，派生类将获得<strong>多个</strong>继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参，例如，当基类的构造函数有两个形参，其中第二个形参含有默认实参，则派生类将获得两个继承的构造函数：其中一个构造函数接受两个参数（没有默认形参）；另一个构造函数只接受一个参数，既基类中没有默认值的那个形参</li>
<li>如果基类中含有多个构造函数，大多数时候派生类会继承所有这些构造函数，但是有两个例外：一个是派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本。如果派生类定义的构造函数与基类中的构造函数具有相同的参数列表，则该构造函数不会被继承。另一个例外是默认、拷贝和移动构造函数不会被继承，这些函数按照正常的规则被合成</li>
<li>继承的构造函数不会被作为用户定义的构造函数使用，因此，如果一个类只含有继承的构造函数，则它也将拥有一个合成的默认构造函数</li>
</ul>
<h1>15.8 容器与继承</h1>
<blockquote>
<p>在容器中存放智能指针而非对象</p>
</blockquote>
<h2 id="15-8-1-编写basket类"><a class="header-anchor" href="#15-8-1-编写basket类">¶</a>15.8.1 编写Basket类</h2>
<ul>
<li>
<p>隐藏指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Basket bsk;</span><br><span class="line">bsk.add_item(make_shared&lt;Quote&gt;(<span class="string">"123"</span>, <span class="number">45</span>));</span><br><span class="line"><span class="comment">//该形式比较麻烦，新版本的add_item将处理内存分配</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_item</span><span class="params">(<span class="keyword">const</span> Quote&amp; sale)</span></span>; <span class="comment">//拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_item</span><span class="params">(Quote&amp;&amp; sale)</span></span>; <span class="comment">//移动</span></span><br><span class="line"><span class="comment">//问题是add_item不知道要分配的类型</span></span><br><span class="line"><span class="comment">//new Quote(sale)会切掉一部分非Quote的部分，所以可能不正确</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>模拟虚拷贝</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//该虚函数返回当前对象的一份动态分配的拷贝</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Quote* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> &amp; </span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> Quote(*<span class="keyword">this</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Quote* <span class="title">clone</span><span class="params">()</span> &amp;&amp; </span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> Quote(<span class="built_in">std</span>::move(*<span class="keyword">this</span>));&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Bulk_quote* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> &amp; </span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> Bulk_quote(*<span class="keyword">this</span>);&#125;</span><br><span class="line">    <span class="function">Bulk_quote* <span class="title">clone</span><span class="params">()</span> &amp;&amp; </span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> Bulk_quote(<span class="built_in">std</span>::move(*<span class="keyword">this</span>));&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Basket</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_item</span><span class="params">(<span class="keyword">const</span> Quote&amp; sale)</span></span>&#123;</span><br><span class="line">        items.insert(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Quote&gt;(sale.clone()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_item</span><span class="params">(Quote&amp;&amp; sale)</span></span>&#123;</span><br><span class="line">        items.insert(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Quote&gt;(<span class="built_in">std</span>::move(sale).clone()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>15.9 文本查询程序再探</h1>
<h2 id="15-9-1-面向对象的解决方案"><a class="header-anchor" href="#15-9-1-面向对象的解决方案">¶</a>15.9.1 面向对象的解决方案</h2>
<ul>
<li>
<p>继承体系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">	A(Query_base)</span><br><span class="line">	B(WordQuery)</span><br><span class="line">	C(NotQuery)</span><br><span class="line">	D(BinaryQuery)</span><br><span class="line">	E(AndQuery)</span><br><span class="line">	F(OrQuery)</span><br><span class="line">	A---B</span><br><span class="line">	A---C</span><br><span class="line">	A---D</span><br><span class="line">	D---E</span><br><span class="line">	D---F</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将层次关系隐藏于接口中</p>
<p>定义一个Query接口类，保存一个Query_base指针，该指针绑定到派生类对象上。用户通过Query对象的操作间接地创建并处理Query_base对象。定义Query的三个重载运算符和一个接受string参数的Query构造函数，这些函数动态分配一个新的Query_base派生类对象</p>
<ul>
<li>&amp;生成绑定到AndQuery对象上的Query对象；</li>
<li>|生成绑定到OrQuery对象上的Query对象；</li>
<li>~生成绑定到NotQuery对象上的Query对象；</li>
<li>接受string的构造函数生成一个新的WordQuery对象</li>
</ul>
</li>
<li>
<p>理解这些类的工作机理</p>
<ul>
<li>
<p>很大一部分工作是构建代表用户查询的对象；理解的关键是理解程序设计思路；</p>
</li>
<li>
<p>Query程序接口类和操作</p>
<ul>
<li>TextQuery</li>
<li>QueryResult</li>
<li>Query</li>
<li>Query q(s)</li>
<li>q1 &amp; q2</li>
<li>q1 | q2</li>
<li>~q</li>
</ul>
</li>
<li>
<p>Query程序实现类</p>
<ul>
<li>Query_base</li>
<li>WordQuery</li>
<li>NotQuery</li>
<li>BinaryQuery</li>
<li>AndQuery</li>
<li>OrQuery</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="15-9-2-query-base类和query类"><a class="header-anchor" href="#15-9-2-query-base类和query类">¶</a>15.9.2 Query_base类和Query类</h2>
<ul>
<li>
<p>Query_base类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Query_base</span> &#123;</span></span><br><span class="line">    <span class="comment">//派生类和用户都不能直接使用Query_base，所以要把友元类给Query</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Query</span>;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">using</span> line_no = TextQuery::lineNo;</span><br><span class="line">    <span class="keyword">virtual</span> ~Query_base() = <span class="keyword">default</span>;<span class="comment">//要隐式的在派生类的析构函数中使用，就最低要求是受保护的</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//返回与当前Query匹配的QueryResult</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> QueryResult <span class="title">eval</span><span class="params">(<span class="keyword">const</span> TextQuery&amp;)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;<span class="comment">//虚函数</span></span><br><span class="line">    <span class="comment">//rep表示查询的是一个string</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">rep</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//抽象基类，不希望直接用户或者派生类直接使用，所以没有public成员</span></span><br><span class="line"><span class="comment">//所有对Query_base的使用都需要通过Query对象，Query需要调用Query_base的虚函数，所以将Query声明为Query_base的友元</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Query类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Query对外提供接口，同时隐藏了Query_base的继承体系</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">	<span class="keyword">friend</span> Query <span class="keyword">operator</span>~(<span class="keyword">const</span> Query &amp;);</span><br><span class="line">	<span class="keyword">friend</span> Query <span class="keyword">operator</span>|(<span class="keyword">const</span> Query &amp;, <span class="keyword">const</span> Query &amp;);</span><br><span class="line">	<span class="keyword">friend</span> Query <span class="keyword">operator</span>&amp;(<span class="keyword">const</span> Query &amp;, <span class="keyword">const</span> Query &amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Query(<span class="keyword">const</span> <span class="built_in">string</span> &amp;);<span class="comment">//构建一个新的WordQuery</span></span><br><span class="line">	<span class="comment">//接口函数：调用对应的Query_base</span></span><br><span class="line">	<span class="function">QueryResult <span class="title">eval</span><span class="params">(<span class="keyword">const</span> TextQuery &amp;t)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> q-&gt;eval(t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">rep</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> q-&gt;rep();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Query(<span class="built_in">shared_ptr</span>&lt;Query_base&gt; query) :q(query) &#123;&#125;<span class="comment">//一个只能内部使用的构造函数，用Query_base构造的指针</span></span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;Query_base&gt; q;<span class="comment">//指向Query_base的智能指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Query的输出运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> Query &amp;query) &#123;</span><br><span class="line">	<span class="comment">//Query::rep通过它的Query_base指针对rep()进行了虚调用</span></span><br><span class="line">	<span class="keyword">return</span> os &lt;&lt; query.rep();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义完WordQuery类才可以定义这个构造函数</span></span><br><span class="line"><span class="keyword">inline</span> Query::Query(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s) :q(<span class="keyword">new</span> WordQuery(s)) &#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="15-9-3-派生类"><a class="header-anchor" href="#15-9-3-派生类">¶</a>15.9.3 派生类</h2>
<ul>
<li>
<p>WordQuery类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现Query_base的派生类，实现真正的查询</span></span><br><span class="line"><span class="comment">//我们所有的查询：基类和派生类的实际操作都是被封装隐藏的，只有通过Query类接口才能被外接访问</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordQuery</span> :</span><span class="keyword">public</span> Query_base&#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Query</span>;</span><span class="comment">//给Query开放接口</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	WordQuery(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s):query_word(s)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//具体的类：WordQuery将覆盖所有继承而来的纯虚函数</span></span><br><span class="line">	<span class="function">QueryResult <span class="title">eval</span><span class="params">(<span class="keyword">const</span> TextQuery &amp;t)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> t.query(query_word);<span class="comment">//</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">rep</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> query_word;<span class="comment">//</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">string</span> query_word;<span class="comment">//要查询的词</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>NotQuery类及~运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//~运算符生成一个NotQuery，其中保存着一个需要对其取反的Query</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotQuery</span> :</span><span class="keyword">public</span> Query_base &#123;</span><br><span class="line">	<span class="keyword">friend</span> Query <span class="keyword">operator</span>~(<span class="keyword">const</span> Query &amp;);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	NotQuery(<span class="keyword">const</span> Query &amp;q):query(q)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">QueryResult <span class="title">eval</span><span class="params">(<span class="keyword">const</span> TextQuery &amp;t)</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">rep</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">string</span>() + <span class="string">"~("</span> + query.rep() + <span class="string">")"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//具体的类：WordQuery将覆盖所有继承而来的纯虚函数</span></span><br><span class="line">	Query query;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Query <span class="keyword">operator</span>~(<span class="keyword">const</span> Query &amp;operand) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;Query_base&gt;(<span class="keyword">new</span> NotQuery(operand));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//复杂的eval在类的外部实现它</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>BinaryQuery类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也是一个抽象基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryQuery</span> :</span><span class="keyword">public</span> Query_base&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	BinaryQuery(<span class="keyword">const</span> Query &amp;l, <span class="keyword">const</span> Query &amp;r, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s):</span><br><span class="line">		lhs(l), rhs(r), opSym(s)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//抽象类，BinaryQuery不定义eval，继承了纯虚函数</span></span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">rep</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"("</span> + lhs.rep() + <span class="string">" "</span></span><br><span class="line">			+ opSym + <span class="string">" "</span></span><br><span class="line">			+ rhs.rep() +  <span class="string">")"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Query lhs, rhs;<span class="comment">//左侧和右侧运算对象</span></span><br><span class="line">	<span class="built_in">string</span> opSym;<span class="comment">//运算符的名字</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>AndQuery类、OrQuery类及相应的运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndQuery</span> :</span><span class="keyword">public</span> BinaryQuery &#123;</span><br><span class="line">	<span class="keyword">friend</span> Query <span class="keyword">operator</span>&amp;(<span class="keyword">const</span> Query&amp;, <span class="keyword">const</span> Query &amp;);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	AndQuery(<span class="keyword">const</span> Query &amp;left, <span class="keyword">const</span> Query &amp;right) :</span><br><span class="line">		BinaryQuery(left, right, <span class="string">"&amp;"</span>) &#123;&#125;</span><br><span class="line">	<span class="comment">//具体的类，继承了rep并且定义其他的虚函数</span></span><br><span class="line">	<span class="function">QueryResult <span class="title">eval</span><span class="params">(<span class="keyword">const</span> TextQuery &amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Query <span class="keyword">operator</span>&amp;(<span class="keyword">const</span> Query &amp;lhs, <span class="keyword">const</span> Query &amp;rhs) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;Query_base&gt;(<span class="keyword">new</span> AndQuery(lhs, rhs));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrQuery</span> :</span><span class="keyword">public</span> BinaryQuery &#123;</span><br><span class="line">	<span class="keyword">friend</span> Query <span class="keyword">operator</span>|(<span class="keyword">const</span> Query&amp;, <span class="keyword">const</span> Query &amp;);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	OrQuery(<span class="keyword">const</span> Query &amp;left, <span class="keyword">const</span> Query &amp;right) :</span><br><span class="line">		BinaryQuery(left, right, <span class="string">"|"</span>) &#123;&#125;</span><br><span class="line">	<span class="comment">//具体的类，继承了rep并且定义其他的虚函数</span></span><br><span class="line">	<span class="function">QueryResult <span class="title">eval</span><span class="params">(<span class="keyword">const</span> TextQuery &amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Query <span class="keyword">operator</span>|(<span class="keyword">const</span> Query &amp;lhs, <span class="keyword">const</span> Query &amp;rhs) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;Query_base&gt;(<span class="keyword">new</span> OrQuery(lhs, rhs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="15-9-4-eval函数"><a class="header-anchor" href="#15-9-4-eval函数">¶</a>15.9.4 eval函数</h2>
<blockquote>
<p>查询系统的核心</p>
</blockquote>
<ul>
<li>
<p>OrQuery::eval</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QueryResult OrQuery::eval(<span class="keyword">const</span> TextQuery &amp;text)<span class="keyword">const</span> &#123;</span><br><span class="line">	<span class="keyword">auto</span> right = rhs.eval(text), left = lhs.eval(text);</span><br><span class="line">	<span class="keyword">auto</span> ret_lines = make_shared&lt;<span class="built_in">set</span>&lt;TextQuery::lineNo&gt;&gt;(left.begin(), left.end());</span><br><span class="line">	ret_lines-&gt;insert(right.begin(), right.end());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> QueryResult(rep(), left.get_files(), ret_lines);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>AndQuery::eval</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QueryResult AndQuery::eval(<span class="keyword">const</span> TextQuery &amp;text) <span class="keyword">const</span> &#123;</span><br><span class="line">	<span class="keyword">auto</span> right = rhs.eval(text), left = lhs.eval(text);<span class="comment">//得到的QueryResult</span></span><br><span class="line">	<span class="keyword">auto</span> ret_lines = make_shared&lt;<span class="built_in">set</span>&lt;TextQuery::lineNo&gt;&gt;();<span class="comment">//空的</span></span><br><span class="line">	set_intersection(left.begin(), left.end(), right.begin(), right.end(), inserter(*ret_lines, ret_lines-&gt;begin()));</span><br><span class="line">	<span class="keyword">return</span> QueryResult(rep(), right.get_files(), ret_lines);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>NotQuery::eval</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">QueryResult NotQuery::eval(<span class="keyword">const</span> TextQuery &amp;text) <span class="keyword">const</span> &#123;</span><br><span class="line">	<span class="comment">//对text进行查询</span></span><br><span class="line">	<span class="keyword">auto</span> result = query.eval(text);<span class="comment">//查询得到QueryResult,,得到名字、set、文本的每一行</span></span><br><span class="line">	<span class="keyword">auto</span> ret_lines = make_shared&lt;<span class="built_in">set</span>&lt;TextQuery::lineNo&gt;&gt;();<span class="comment">//得到空的set指针，用来存返回结果</span></span><br><span class="line">	<span class="keyword">auto</span> beg = result.begin(), end = result.end();</span><br><span class="line">	<span class="keyword">auto</span> sz = result.get_files()-&gt;size();<span class="comment">//得到文本的行数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> n = <span class="number">0</span>; n != sz; ++n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (beg == end || *beg != n) &#123;</span><br><span class="line">			ret_lines-&gt;insert(n);<span class="comment">//如果不在result当中，就添加这一行</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (beg != end) &#123;</span><br><span class="line">			++beg;<span class="comment">//</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> QueryResult(rep(), result.get_files(), ret_lines);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>TextQuery和QueryResult的实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TextQuery.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryResult</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextQuery</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> lineNo = <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::size_type;</span><br><span class="line">	TextQuery() = <span class="keyword">default</span>;</span><br><span class="line">	TextQuery(ifstream &amp;infile);</span><br><span class="line"></span><br><span class="line">	<span class="function">QueryResult <span class="title">query</span><span class="params">(<span class="built_in">string</span> word)</span> <span class="keyword">const</span></span>;<span class="comment">//查询得到的是 QueryResult </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; text;<span class="comment">//装文本的每一行</span></span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">shared_ptr</span>&lt;<span class="built_in">set</span>&lt;lineNo&gt;&gt;&gt; wordMap;<span class="comment">//每个单词对应一个set</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryResult</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> ostream &amp;<span class="title">print</span><span class="params">(ostream&amp;, <span class="keyword">const</span> QueryResult&amp;)</span></span>;</span><br><span class="line">	<span class="comment">//构造函数 </span></span><br><span class="line">	QueryResult() = <span class="keyword">default</span>;</span><br><span class="line">	QueryResult(<span class="built_in">string</span> sword, <span class="built_in">shared_ptr</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; stext, <span class="built_in">shared_ptr</span>&lt;<span class="built_in">set</span>&lt;TextQuery::lineNo&gt;&gt; slines) :</span><br><span class="line">		sought(sword), text(stext), lines(slines) &#123;&#125;</span><br><span class="line">	<span class="built_in">set</span>&lt;TextQuery::lineNo&gt;::<span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> lines-&gt;begin();<span class="comment">//返回指向set的（存在位置）迭代器</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">set</span>&lt;TextQuery::lineNo&gt;::<span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> lines-&gt;end();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; get_files() <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> text;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">string</span> sought;<span class="comment">//查询单词 </span></span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; text;<span class="comment">//指向文本的指针</span></span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;<span class="built_in">set</span>&lt;TextQuery::lineNo&gt;&gt; lines;<span class="comment">//指向set的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runQueries</span><span class="params">(ifstream &amp;infile)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TextQuery.cpp</span></span><br><span class="line">TextQuery::TextQuery(ifstream &amp;infile) :text(<span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;)<span class="comment">//构造的时候动态新建内存 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">string</span> line;</span><br><span class="line">	lineNo lineNum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (getline(infile, line)) &#123;</span><br><span class="line">		text-&gt;push_back(line);</span><br><span class="line">		<span class="function"><span class="built_in">istringstream</span> <span class="title">iss</span><span class="params">(line)</span></span>;</span><br><span class="line">		<span class="built_in">string</span> word;</span><br><span class="line">		<span class="keyword">while</span> (iss &gt;&gt; word) &#123;</span><br><span class="line">			<span class="keyword">auto</span> &amp;lines = wordMap[word];<span class="comment">//得到shared_ptr的引用</span></span><br><span class="line">			<span class="keyword">if</span> (!lines) &#123;</span><br><span class="line">				lines.reset(<span class="keyword">new</span> <span class="built_in">set</span>&lt;lineNo&gt;);<span class="comment">//分配一个新的set </span></span><br><span class="line">			&#125;</span><br><span class="line">			lines-&gt;insert(lineNum);</span><br><span class="line">		&#125;</span><br><span class="line">		lineNum++;<span class="comment">//行号增加 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QueryResult TextQuery::query(<span class="built_in">string</span> word)<span class="keyword">const</span> &#123;</span><br><span class="line">	<span class="comment">//先在map中查是否存在这个单词，如果不存在的话应该返回空的set </span></span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">shared_ptr</span>&lt;<span class="built_in">set</span>&lt;TextQuery::lineNo&gt;&gt; nodata(<span class="keyword">new</span> <span class="built_in">set</span>&lt;TextQuery::lineNo&gt;);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//用find函数来查询，避免向map中插入新的</span></span><br><span class="line">	<span class="keyword">auto</span> loc = wordMap.find(word);</span><br><span class="line">	<span class="keyword">if</span> (loc == wordMap.cend()) &#123;</span><br><span class="line">		<span class="keyword">return</span> QueryResult(word, text, nodata);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> QueryResult(word, text, loc-&gt;second);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> QueryResult &amp;qr)</span> </span>&#123;</span><br><span class="line">	os &lt;&lt; qr.sought &lt;&lt; <span class="string">"occurs "</span> &lt;&lt; qr.lines-&gt;size() &lt;&lt; <span class="string">" times :"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> pos : (*qr.lines)) &#123;</span><br><span class="line">		os &lt;&lt; <span class="string">"line "</span> &lt;&lt; pos + <span class="number">1</span> &lt;&lt; <span class="string">":"</span> &lt;&lt; (*qr.text)[pos] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runQueries</span><span class="params">(ifstream &amp;infile)</span> </span>&#123;</span><br><span class="line">	<span class="function">TextQuery <span class="title">tq</span><span class="params">(infile)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"enter word to look for, q to quit:"</span>;</span><br><span class="line">		<span class="built_in">string</span> s;</span><br><span class="line">		<span class="keyword">if</span> (!(<span class="built_in">cin</span> &gt;&gt; s) || s == <span class="string">"q"</span>)<span class="keyword">break</span>;</span><br><span class="line">		print(<span class="built_in">cout</span>, tq.query(s)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/20/C-Primer学习笔记：第14章-操作重载和类型转换/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/20/C-Primer学习笔记：第14章-操作重载和类型转换/" itemprop="url">C++ Primer学习笔记：第14章 操作重载和类型转换</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-20T22:01:27+08:00">2019-07-20</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>14.1 基本概念</h1>
<p>  当一个重载的运算符是成员函数时，this绑定到左侧运算对象。成员运算符函数的显示参数数量比运算对象数量少一个。</p>
<p>  一个运算符函数，或者是类的成员，或者至少含有一个类类型的参数。无法改变内置类型运算对象的运算符含义</p>
<p>  不可被重载的运算符:<code>:: .* . ?:</code></p>
<ul>
<li>
<p>直接调用一个重载的运算符函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个非成员运算符函数的等价调用</span></span><br><span class="line">data1 + data2;</span><br><span class="line"><span class="keyword">operator</span>+ (data1, data2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员运算符函数</span></span><br><span class="line">data1 += data2;</span><br><span class="line">data1.<span class="keyword">operator</span> += (data2);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>某些运算符不应该被重载</p>
<ul>
<li>逻辑与、逻辑或和逗号运算符的运算对象求值顺序规则无法保留，&amp;&amp;和||的短路特性也无法保留内置运算符的短路求值特性</li>
<li>C++已经定义了逗号运算符和取地址运算符用于类类型对象时的特殊含义，这一点和大多数运算符都不相同</li>
</ul>
</li>
<li>
<p>使用与内置类型一致的含义</p>
</li>
<li>
<p>赋值和复合赋值运算符</p>
<p>  如果类含有算术运算符或者位运算符，则最后也提供对应的复合赋值运算符</p>
</li>
<li>
<p>选择作为成员或者非成员</p>
<ul>
<li>赋值（=）下标（[ ]）调用（( )）和成员访问箭头（-&gt;）运算符必须是类的成员函数</li>
<li>复合赋值运算符一般应该是成员函数，但是这并不是强制的，这与赋值运算符不同</li>
<li>改变对象状态的运算符或者与给定类型密切相关的运算符，比如递增、递减、解引用，通常应该定义为类的成员</li>
<li>具有对称性的运算符可能转换任意一端的运算对象，例如算数、关系和位运算符等，都应该定义为类的非成员函数</li>
</ul>
<p>  运算符定义成成员函数，其左侧运算对象必须是运算符所属类的一个对象；</p>
<p>  定义成非成员函数，唯一要求是至少有一个运算对象是类类型，并且两个运算对象都能准确无误地转换成string</p>
</li>
</ul>
<h1>14.2 输入和输出运算符</h1>
<h2 id="14-2-1-重载输出运算符"><a class="header-anchor" href="#14-2-1-重载输出运算符">¶</a>14.2.1 重载输出运算符&lt;&lt;</h2>
<ul>
<li>
<p>Sales_data的输出运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> Sales_data &amp;item)&#123;</span><br><span class="line">    os &lt;&lt; item.isbn() &lt;&lt; <span class="string">" "</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">" "</span> </span><br><span class="line">        &lt;&lt; item.revenue &lt;&lt; <span class="string">" "</span> &lt;&lt; item.avg_price();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>输出运算符尽量减少格式化操作</p>
<p>  不要打印换行符，输出符主要负责打印内容而非控制格式</p>
</li>
<li>
<p>输入输出运算符必须是非成员函数</p>
<p>  IO运算符通常需要读写类的非公有数据成员，所以IO运算符一般声明为友元</p>
</li>
</ul>
<h2 id="14-2-2-重载输入运算符"><a class="header-anchor" href="#14-2-2-重载输入运算符">¶</a>14.2.2 重载输入运算符&gt;&gt;</h2>
<ul>
<li>
<p>Sales_data的输入运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">istream &amp;<span class="keyword">operator</span> &gt;&gt; (istream &amp;is, Sales_data &amp;item)&#123;</span><br><span class="line">	<span class="keyword">double</span> price;</span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    <span class="keyword">if</span> (is)</span><br><span class="line">        item.revenue = item.units_sold * price;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        item = Sales_data();</span><br><span class="line">    <span class="keyword">return</span> is</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输入运算符必须处理输入可能失败的情况，而输出不需要</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>输入时的错误</p>
<ul>
<li>当流含有错误类型的数据时读取操作可能失败</li>
<li>当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败</li>
</ul>
</li>
</ul>
<blockquote>
<p>当读取操作发生错误时，输入运算符应该负责从错误中恢复</p>
</blockquote>
<ul>
<li>标示错误
<ul>
<li>最好的方式是由IO标准库自己来标示这些错误</li>
<li>通常情况下，输入运算符只设置failbit。除此之外，设置eofbit表示文件耗尽，而设置badbit表示流被破坏</li>
</ul>
</li>
</ul>
<h1>14.3 算术和关系运算符</h1>
<p>  使用复合赋值来定义算术运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sales_data</span><br><span class="line"><span class="keyword">operator</span>+(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)&#123;</span><br><span class="line">	Sales_data sum = lhs;</span><br><span class="line">	sum += rhs;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符。</p>
<h2 id="14-3-1-相等运算符"><a class="header-anchor" href="#14-3-1-相等运算符">¶</a>14.3.1 相等运算符</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)&#123;</span><br><span class="line">	<span class="keyword">return</span> lhs.isbn() == rhs.isbn() &amp;&amp; </span><br><span class="line">        lhs.units_sold == rhs.units_sold &amp;&amp;</span><br><span class="line">        lhs.revenue == rhs.revenue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)&#123;</span><br><span class="line">    <span class="keyword">return</span> !(lhs == rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="14-3-2-关系运算符"><a class="header-anchor" href="#14-3-2-关系运算符">¶</a>14.3.2 关系运算符</h2>
<p>  如果存在唯一一种逻辑可靠的&lt;定义，则应该考虑为这个类定义&lt;运算符。如果类同时包含==，则当且仅当&lt;的定义和==产生的结果一致时才定义&lt;运算符</p>
<h1>14.4 赋值运算符</h1>
<ul>
<li>
<p>花括号列表赋值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	StrVec &amp;<span class="keyword">operator</span>= (<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;);	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>=(<span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; il)&#123;</span><br><span class="line">    <span class="comment">//分配空间并从给定范围拷贝元素</span></span><br><span class="line">    <span class="keyword">auto</span> data = alloc_n_copy(il.begin(), il.end());</span><br><span class="line">    <span class="built_in">free</span>(); <span class="comment">//销毁对象中的元素，并释放空间</span></span><br><span class="line">    elements = data.first; <span class="comment">//更新数据成员使其指向新空间</span></span><br><span class="line">    first_free = cap = data.second;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不论形参的类型是什么，赋值运算符都必须定义为成员函数</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>复合赋值运算符</p>
<p>  不一定非得是类的成员，倾向于定义在类内部</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sales_data &amp;Sales_data::<span class="keyword">operator</span>+=(<span class="keyword">const</span> Sales_data &amp;rhs)&#123;</span><br><span class="line">	units_sold += rhs.units_sold;</span><br><span class="line">	revenue += rhs.revenue;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>14.5 下标运算符</h1>
<blockquote>
<p>必须是成员函数；</p>
<p>下标运算符以访问元素的引用作为返回值；</p>
<p>最好同时定义下标运算的常量和非常量版本；</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n)&#123;</span><br><span class="line">        <span class="keyword">return</span> elements[n];</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elements[n];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *elements;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> StrVec cvec = svec;</span><br><span class="line"><span class="keyword">if</span> (svec.size() &amp;&amp; svec[<span class="number">0</span>].empty())&#123;</span><br><span class="line">    svec[<span class="number">0</span>] = <span class="string">"zero"</span>;</span><br><span class="line">    cvec[<span class="number">0</span>] = <span class="string">"zip"</span>;<span class="comment">//错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>14.6 递增和递减运算符</h1>
<blockquote>
<p>因为改变对象的状态，所以建议设为类的成员；</p>
<p>应该同时定义前置版本和后置版本；</p>
</blockquote>
<ul>
<li>
<p>前置递增递减</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class StrBlobPtr &#123;</span><br><span class="line">public:</span><br><span class="line">	StrBlobPtr&amp; operator++();</span><br><span class="line">	StrBlobPtr&amp; operator--();</span><br><span class="line">	//其他成员和之前一致</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>前置运算符应该返回引用</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>++()&#123;</span><br><span class="line">	check(curr, <span class="string">"increment past end of StrBlobPtr"</span>);</span><br><span class="line">    ++curr;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>++()&#123;</span><br><span class="line">    --curr;</span><br><span class="line">	check(curr, <span class="string">"decrement past begin of StrBlobPtr"</span>);    </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>区分前置和后置运算符</p>
<blockquote>
<p>普通的重载无法区分这两种情况。为了解决这个问题，后置版本接受一个额外的int类型的形参。当我们使用后置运算符，编译器为这个形参提供一个值为0的实参。这个形参的唯一作用是为了区分前置后置版本。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class StrBlobPtr &#123;</span><br><span class="line">public:</span><br><span class="line">	StrBlobPtr operator++(int);</span><br><span class="line">	StrBlobPtr operator--(int);</span><br><span class="line">	//其他成员和之前一致</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了与内置版本保持一致，后置运算符应该返回对象的原值，返回的形式是一个值而非引用。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;</span><br><span class="line">    <span class="comment">//此处无须检查有效性，调用前置递增运算时才需要检查</span></span><br><span class="line">	StrBlobPtr ret = *<span class="keyword">this</span>; <span class="comment">//记录当前值</span></span><br><span class="line">	++*<span class="keyword">this</span>; <span class="comment">//向前移动一个元素，前置++需要检查递增的有效性</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;</span><br><span class="line">	StrBlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">	--*<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>显示调用后置运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数调用的方式调用后置版本</span></span><br><span class="line"><span class="function">StrBlobPtr <span class="title">p</span><span class="params">(al)</span></span>;</span><br><span class="line">p.<span class="keyword">operator</span>++(<span class="number">0</span>);<span class="comment">//后置版本</span></span><br><span class="line">p.<span class="keyword">operator</span>++();<span class="comment">//前置版本</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1>14.7 成员访问运算符</h1>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVecPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> &amp;<span class="keyword">operator</span>*() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//先确认现在状态是否合法，否则无法解引用</span></span><br><span class="line">        <span class="keyword">auto</span> p = check(curr, <span class="string">"dereference past end"</span>);</span><br><span class="line">        <span class="keyword">return</span> (*p)[curr];  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *<span class="keyword">operator</span>-&gt;() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用解引用操作，返回的是指针</span></span><br><span class="line">        <span class="keyword">return</span> &amp;<span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>::<span class="keyword">size_t</span> curr;       <span class="comment">//下标位置</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; *p;  <span class="comment">//指向迭代器所指向的容器</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>箭头运算符必须是类的成员。解引用运算符通常也是，但是并非必须如此</p>
</blockquote>
<ul>
<li>
<p>箭头运算符返回值的限定</p>
<p>能令operator*完成任何我们指定的操作。箭头运算符则必须获取成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//point是指针</span></span><br><span class="line"><span class="comment">//等价于(*point).mem。首先解引用该指针，然后从所得对象中获取指定成员。</span></span><br><span class="line">(*point).mem</span><br><span class="line"><span class="comment">//是类的对象</span></span><br><span class="line"><span class="comment">//使用point.operator-&gt;()的结果获取mem。如果该结果是一个指针，则执行第1步；如果该结果本身含有重载的operator-&gt;()，则重复调用当前步骤。类似一个递归的过程。</span></span><br><span class="line"><span class="comment">//重载的箭头运算符必须返回类的指针或者自定义箭头运算符的某个类的对象。</span></span><br><span class="line">point.<span class="keyword">operator</span>()-&gt;mem;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>14.8 函数调用运算符</h1>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">absInt</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val &lt; <span class="number">0</span> ? -val : val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数调用运算符必须是成员函数；</p>
<p>一个类可以定义多个不同版本的调用运算符，相互之间参数数量或者类型上有所区别</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintString</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    PrintString(ostream &amp;o = <span class="built_in">cout</span>, <span class="keyword">char</span> c = <span class="string">' '</span>):</span><br><span class="line">    	os(o), seq(c) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> <span class="keyword">const</span> </span>&#123; os &lt;&lt; s &lt;&lt; sep; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ostream &amp;os;</span><br><span class="line">    <span class="keyword">char</span> sep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以将函数对象作为泛型算法的实参</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(vs.begin(). vs.end(), PrintString(<span class="built_in">cerr</span>, <span class="string">'\n'</span>));</span><br></pre></td></tr></table></figure>
<h2 id="14-8-1-lambda是函数对象"><a class="header-anchor" href="#14-8-1-lambda是函数对象">¶</a>14.8.1 lambda是函数对象</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShorterString</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.size() &lt; s2.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">stable_sort(words.begin(), words.end(), ShorterString());</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>表示lambda及相应捕获行为的类</p>
<ul>
<li>
<p>引用捕获变量时，必须确保所引用的对象确实存在，所以可以直接使用该引用而无须再lambda产生的类中将其存储为数据成员</p>
</li>
<li>
<p>通过值捕获的变量被拷贝到lambda中，同时创建构造函数，用捕获的变量来值初始化数据成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> wc = find_if(words.begin(), words.end(), </span><br><span class="line">                  [sz](<span class="keyword">const</span> <span class="built_in">string</span> &amp;a)</span><br><span class="line">                  	&#123; <span class="keyword">return</span> a.size() &gt;= sz; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//该lambda等价于下面的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SizeComp</span> &#123;</span></span><br><span class="line">    SizeComp(<span class="keyword">size_t</span> n):sz(n) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">    	</span>&#123; <span class="keyword">return</span> s.size() &gt;= sz; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> sz;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>lambda表达式产生的类不含默认构造函数、赋值运算符及默认析构函数；它是否含有默认的拷贝/移动构造函数则通常要视捕获的数据成员类型而定。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="14-8-2-标准库定义的函数对象"><a class="header-anchor" href="#14-8-2-标准库定义的函数对象">¶</a>14.8.2 标准库定义的函数对象</h2>
<blockquote>
<p>funtional头文件</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plus&lt;<span class="keyword">int</span>&gt; intAdd;</span><br><span class="line">negate&lt;<span class="keyword">int</span>&gt; intNegate;</span><br><span class="line"><span class="keyword">int</span> sum = intAdd(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">sum = intNegate(intAdd(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">sum = intAdd(<span class="number">10</span>, intNegate(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>算法中使用标准库函数对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sort(svec.begin(), svec.end(), greater&lt;<span class="built_in">string</span>&gt;());</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span> *&gt; nameTable;</span><br><span class="line">sort(nameTable.begin(), nameTable.end(), less&lt;<span class="built_in">string</span> *&gt;());</span><br><span class="line"><span class="comment">//关联容器使用less&lt;key_type&gt;对元素排序，所以可以定义一个指针的set或者在map中使用指针作为关键字而无须直接声明less</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="14-8-3-可调用对象与function"><a class="header-anchor" href="#14-8-3-可调用对象与function">¶</a>14.8.3 可调用对象与function</h2>
<ul>
<li>
<p>可调用对象</p>
<ul>
<li>函数</li>
<li>函数指针</li>
<li>lambda表达式</li>
<li>bind创建的对象</li>
<li>重载了函数调用运算符的类</li>
</ul>
</li>
<li>
<p>不同类型可能具有相同的调用形式</p>
</li>
<li>
<p>函数表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> i + j; &#125;</span><br><span class="line"><span class="keyword">auto</span> mod = [](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123; <span class="keyword">return</span> i % j; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>(*)(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; binops;</span><br><span class="line"></span><br><span class="line">binops.insert(&#123;<span class="string">"+"</span>, add&#125;);</span><br><span class="line">binops.insert(&#123;<span class="string">"%"</span>, mod&#125;);<span class="comment">//错误，mod是个lambda，有自己的类类型，与存储在binops中的值的类型不匹配</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>标准库function类型</p>
<blockquote>
<p>function<t> f; //存储可调用对象的空function，T即调用形式</t></p>
<p>function<t> f(nullptr); //显示构造一个空function</t></p>
<p>function<t> f(obj);</t></p>
<p>f //f作为条件：当f含有一个可调用对象时为真；否则为假</p>
<p>f(args)</p>
<p>定义为function<t>的成员的类型</t></p>
<p>result_type</p>
<p>argument_type</p>
<p>first_argument_type</p>
<p>second_argument_type</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f1 = add;</span><br><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f2 = divide();</span><br><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f3 = [](<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span><br><span class="line">								&#123; <span class="keyword">return</span> i * j; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; binops = &#123;</span><br><span class="line">    &#123;<span class="string">"+"</span>, add&#125;,</span><br><span class="line">    &#123;<span class="string">"-"</span>, <span class="built_in">std</span>::minus&lt;<span class="keyword">int</span>&gt;()&#125;,</span><br><span class="line">    &#123;<span class="string">"/"</span>, divide()&#125;,</span><br><span class="line">    &#123;<span class="string">"*"</span>, [](<span class="keyword">int</span> i, <span class="keyword">int</span> j)&#125; &#123; <span class="keyword">return</span> i * j; &#125;&#125;,</span><br><span class="line">	&#123;<span class="string">"%"</span>, mod&#125; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>重载的函数与function</p>
<ul>
<li>
<p>可以用存储函数指针或者lambda避免二义性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> i + j; &#125;</span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">binops.insert(&#123;<span class="string">"+"</span>, add&#125;); <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*fp)(<span class="keyword">int</span>, <span class="keyword">int</span>) = add;</span><br><span class="line">binops.insert( &#123;<span class="string">"+"</span>, fp&#125; );</span><br><span class="line">binops.insert( &#123;<span class="string">"+"</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> add(a, b); &#125; &#125; );</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1>14.9 重载、类型转换与运算符</h1>
<blockquote>
<p>转换构造函数和类型转换运算符共同定义了类类型转换，有时也被称作用户定义的类型转换</p>
</blockquote>
<h2 id="14-9-1-类型转换运算符"><a class="header-anchor" href="#14-9-1-类型转换运算符">¶</a>14.9.1 类型转换运算符</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="comment">//没有显示返回类型，没有形参，必须定义成类的成员函数，且不应该改变待转换对象的内容</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>定义含有类型转换运算符的类</p>
<ul>
<li>
<p>尽管一次只能执行一个用户定义的类型转换，但是隐式的用户定义的类型转换可以置于一个标准（内置）类型转换之前或之后</p>
</li>
<li>
<p>类型转换运算符是隐式执行的，所以无法给这些函数传递实参，也不能在类型转换运算符的定义中使用任何形参</p>
</li>
<li>
<p>虽然不负责指定返回类型，但是实际上每个类型转换函数都会返回一个对应类型的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">(SmallInt &amp;)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//错误，指定了返回类型</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">(<span class="keyword">int</span> = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;<span class="comment">//错误：参数列表不为空</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="keyword">int</span>*() <span class="keyword">const</span> &#123;<span class="keyword">return</span> <span class="number">42</span>;&#125; <span class="comment">//错误：42不是指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>类型转换运算符可能产生意外结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="built_in">cin</span> &lt;&lt; i; </span><br><span class="line"><span class="comment">//如果向bool的类型转换不是显示的，则该代码在编译器看来将是合法的！</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>显示的类型转换运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SmallInt si = <span class="number">3</span>; <span class="comment">//正确：SmallInt的构造函数不是显示的</span></span><br><span class="line">si + <span class="number">3</span>; <span class="comment">//错误：此处需要隐式的类型转换，但类的运算符是显示的</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(si) + <span class="number">3</span>; <span class="comment">//正确：显示地请求类型转换</span></span><br></pre></td></tr></table></figure>
<p>该规定存在例外，如果表达式被用于条件，则编译器会将显示的类型转换自动应用于它。当表达式出现在下列位置，显示的类型转换将被隐式执行：</p>
<ol>
<li>if、while及do语句的条件部分</li>
<li>for语句头的条件表达式</li>
<li>逻辑非运算符(!)、逻辑或运算符(||)、逻辑与运算符(&amp;&amp;)的运算对象</li>
<li>条件运算符(?:)的条件表达式</li>
</ol>
</li>
<li>
<p>转换为bool</p>
<p>向bool类型转换通常用条件部分，因此operator bool一般定义成explicit</p>
</li>
</ul>
<h2 id="14-9-2-避免有二义性的类型转换"><a class="header-anchor" href="#14-9-2-避免有二义性的类型转换">¶</a>14.9.2 避免有二义性的类型转换</h2>
<blockquote>
<p>两种情况下可能产生多重转换路径。第一种是两个类提供相同的类型转换。第二种是定义了多个转换规则，而这些转换涉及的类型本身可以通过其他类型转换联系在一起；</p>
<p>通常，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标是算术类型的转换；</p>
</blockquote>
<ul>
<li>
<p>实参匹配和相同的类型转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    A() = <span class="keyword">default</span>;</span><br><span class="line">    A(<span class="keyword">const</span> B&amp;);<span class="comment">//把一个B转换成A</span></span><br><span class="line">    <span class="comment">//其他成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">A</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">//也是把一个B转换成A</span></span><br><span class="line">    <span class="comment">//其他数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">(<span class="keyword">const</span> A&amp;)</span></span>;</span><br><span class="line">B b;</span><br><span class="line">A a = f(b);<span class="comment">//二义性错误：含义是f(B::operator A())，还是f(A::A(const B&amp;))?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方法</span></span><br><span class="line">A a1 = f(b.<span class="keyword">operator</span> A());</span><br><span class="line">A a2 = f(A(b));</span><br><span class="line"></span><br><span class="line"><span class="comment">//无法使用强制类型转换，因为强制类型转换本身也将面临二义性</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>二义性与转换目标为内置类型的多重类型转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    A(<span class="keyword">int</span> = <span class="number">0</span>);</span><br><span class="line">    A(<span class="keyword">double</span>);</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//其他成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span>)</span></span>;</span><br><span class="line">A a;</span><br><span class="line">f2(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> lg;</span><br><span class="line"><span class="function">A <span class="title">a2</span><span class="params">(lg)</span></span>;</span><br><span class="line"><span class="comment">//产生二义性根本原因是它们所需的标准类型转换级别一致</span></span><br><span class="line"><span class="comment">//当我们使用两个用户定义的类型转换时，如果转换函数之前或之后存在标准类型转换，则标准类型转换将决定最佳匹配到底是哪个</span></span><br></pre></td></tr></table></figure>
<ul>
<li>经验规则
<ul>
<li>如果Foo类有一个接受Bar类对象的构造函数，则不要再Bar类中再定义转换目标是Foo类的类型转换运算符</li>
<li>避免转换目标是内置算术类型的类型转换。特别是当你已经定义了一个转换成算术类型的类型转换时，接下来：
<ul>
<li>不要在定义接受算术类型的重载运算符。如果用户需要使用这样的运算符，则类型转换操作将转换你的类型的对象，然后使用内置的运算符</li>
<li>不要定义转换到多种算术类型的类型转换。让标准类型转换完成向其他算术类型转换的工作。</li>
</ul>
</li>
<li>一言蔽之：除了显示向bool类型转换之外，应该尽量避免定义类型转换函数并尽可能将非显示构造函数用于类型转换显然正确的情况</li>
</ul>
</li>
</ul>
</li>
<li>
<p>重载函数和转换构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> &#123;</span> C(<span class="keyword">int</span>); &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> &#123;</span> D(<span class="keyword">int</span>); &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">(<span class="keyword">const</span> C&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">(<span class="keyword">const</span> D&amp;)</span></span>;</span><br><span class="line">manip(<span class="number">10</span>); <span class="comment">//二义性错误</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果在调用重载函数时需要使用构造函数或强制类型转换来改变实参类型，则通常意味着程序设计存在不足</p>
</blockquote>
</li>
<li>
<p>重载函数与用户定义的类型转换</p>
<p>调用重载函数时，如果两个或多个用户定义的类型转换都提供了可行匹配，则认为这些类型转换一样好。</p>
<p>只有重载函数能通过同一个类型转换函数得到匹配，才会考虑其中出现的标准类型转换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span> &#123;</span></span><br><span class="line">    E(<span class="keyword">double</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip2</span><span class="params">(<span class="keyword">const</span> C&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip2</span><span class="params">(<span class="keyword">const</span> E&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">manip2(<span class="number">10</span>); <span class="comment">//二义性，manip2(C(10))和manip2(E(double(10)))都可以</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在调用重载函数时，如果需要额外的标准类型转换，则该转换的级别只有当所有可行函数都请求同一个用户定义的类型转换才有用。如果所需用户定义的类型转换不止一个，则该调用具有二义性。</p>
</blockquote>
</li>
</ul>
<h2 id="14-9-3-函数匹配与重载运算符"><a class="header-anchor" href="#14-9-3-函数匹配与重载运算符">¶</a>14.9.3 函数匹配与重载运算符</h2>
<ul>
<li>
<p>重载的运算符也是重载函数。因此，通用的函数匹配规则同样适用于在给定的表达式中到底应该使用内置运算符还是重载的运算符</p>
</li>
<li>
<p>如果a是一种类类型，则表达式 a sym b可能是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.operatorsym(b); <span class="comment">// a有一个operatorsym成员函数</span></span><br><span class="line"></span><br><span class="line">operatorsym(a, b); <span class="comment">// operatorsym是一个普通函数</span></span><br></pre></td></tr></table></figure>
<p>和普通函数调用不同，我们不能通过调用的形式来区分当前调用的是成员函数还是非成员函数</p>
</li>
<li>
<p>当我们使用重载运算符作用于类类型的运算对象时，候选函数中包含该运算符的普通非成员版本和内置版本。除此之外，如果左侧运算对象是类类型，则定义在该类中的运算符的重载版本也包含在候选函数内</p>
<blockquote>
<p>表达式中运算符的候选函数集既应该包括成员函数，也应该包括非成员函数</p>
</blockquote>
</li>
<li>
<p>如果我们对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> A <span class="keyword">operator</span>+(<span class="keyword">const</span> A&amp;, <span class="keyword">const</span> A&amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> _x=<span class="number">0</span>):x(_x)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span><span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A <span class="keyword">operator</span>+(<span class="keyword">const</span> A &amp;lhs, <span class="keyword">const</span> A &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> A(lhs.x + rhs.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1, a2;</span><br><span class="line">    A a3 = a1 + a2; <span class="comment">// 使用重载的operator+</span></span><br><span class="line">    <span class="keyword">int</span> res = a3 + <span class="number">0</span>; <span class="comment">// 二义性错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/19/C-Primer学习笔记：第13章-拷贝控制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/19/C-Primer学习笔记：第13章-拷贝控制/" itemprop="url">C++ Primer学习笔记：第13章 拷贝控制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-19T23:17:00+08:00">2019-07-19</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>13.1 拷贝、赋值与销毁</h1>
<blockquote>
<p>实现拷贝控制最困难的地方首先是认识到什么时候需要定义这些操作</p>
</blockquote>
<h2 id="13-1-1-拷贝构造函数"><a class="header-anchor" href="#13-1-1-拷贝构造函数">¶</a>13.1.1 拷贝构造函数</h2>
<p>​    拷贝构造函数第一个参数传自身类类型引用；</p>
<p>​    不是explicit的；</p>
<p>​    接受的几乎总是const引用；</p>
<p>​    额外参数有默认值</p>
<ul>
<li>合成拷贝构造函数
<ul>
<li>不管定义或没定义其他构造函数，编译器也会合成一个</li>
<li>有些用来阻止拷贝，一般用来拷贝非static成员到创建的对象</li>
</ul>
</li>
<li>拷贝初始化
<ul>
<li>发生时机
<ul>
<li>=定义变量</li>
<li>非引用传参</li>
<li>非引用返回</li>
<li>花括号列表初始化数组的元素或聚合类的成员</li>
<li>某些类类型会对分配的对象使用拷贝初始化（如vector的insert和push成员，而emplace是值初始化）</li>
</ul>
</li>
</ul>
</li>
<li>参数和返回值
<ul>
<li>必须是引用类型，因为为了调用拷贝构造函数，必须拷贝实参，为了拷贝实参，又需要调用拷贝构造</li>
</ul>
</li>
<li>拷贝初始化限制
<ul>
<li>传递实参或返回值，不能隐式使用explicit构造函数</li>
</ul>
</li>
<li>编译器可以绕过拷贝构造函数
<ul>
<li>虽然略过，但是拷贝和移动必须存在并可访问</li>
</ul>
</li>
</ul>
<h2 id="13-1-2-拷贝赋值运算符"><a class="header-anchor" href="#13-1-2-拷贝赋值运算符">¶</a>13.1.2 拷贝赋值运算符</h2>
<p>  如果未定义编译器会合成一个；</p>
<p>  必须返回左侧对象的引用；</p>
<h2 id="13-1-3-析构函数"><a class="header-anchor" href="#13-1-3-析构函数">¶</a>13.1.3 析构函数</h2>
<ul>
<li>不接收参数，不返回值</li>
<li>内置类型没有析构函数</li>
<li>执行时机
<ul>
<li>变量在离开其作用域的时候</li>
<li>当一个对象被销毁时，其成员被销毁</li>
<li>容器被销毁时</li>
<li>当对指向它的指针应用delete运算符时被销毁</li>
<li>对于临时对象，当创建它的完整表达式结束时被销毁</li>
</ul>
</li>
<li>当指向对象的引用或指针离开作用域，析构函数不会执行</li>
<li>合成析构函数
<ul>
<li>析构函数自身并不直接销毁成员</li>
<li>成员是在析构函数体之后隐含的析构阶段中被销毁的</li>
<li>析构函数体是作为成员销毁步骤之外的另一部分进行的</li>
</ul>
</li>
</ul>
<h2 id="13-1-4-三-五法则"><a class="header-anchor" href="#13-1-4-三-五法则">¶</a>13.1.4 三/五法则</h2>
<ul>
<li>需要析构函数的类也需要拷贝和赋值操作</li>
<li>需要拷贝操作的类也需要赋值操作，反之亦然；但是不一定需要析构函数</li>
</ul>
<h2 id="13-1-5-使用-default"><a class="header-anchor" href="#13-1-5-使用-default">¶</a>13.1.5 使用=default</h2>
<p>​    可以通过将拷贝控制成员定义为=default显示要求编译器生成合成版本</p>
<p>​    类内用=default，则隐式声明为内联；不希望内联，则只对类外定义使用=default；</p>
<p>​    只能对有合成版本的成员函数使用=default（如默认构造函数或拷贝控制成员）</p>
<h2 id="13-1-6-阻止拷贝"><a class="header-anchor" href="#13-1-6-阻止拷贝">¶</a>13.1.6 阻止拷贝</h2>
<blockquote>
<p>大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是显示还是隐式</p>
</blockquote>
<ul>
<li>
<p>定义删除的函数</p>
<ul>
<li>=delete必须出现在函数第一次声明的时候</li>
<li>可以对任何函数指定=default</li>
</ul>
</li>
<li>
<p>析构函数不能是删除的成员</p>
<p>对于删除了析构函数的类型，虽然不能定义这种类型的变量或成员，但可以动态分配这种类型的对象。但是，不能释放这些对象</p>
</li>
<li>
<p>合成的拷贝控制成员可能是删除的</p>
<ul>
<li>如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的</li>
<li>一个成员有删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数定义为删除的</li>
<li>对于有引用成员或无法默认构造的const成员的类，编译器不会为其合成默认构造函数</li>
<li>如果一个类有const成员，则它不能使用合成的拷贝赋值运算符</li>
<li>具有引用成员或无法默认构造的const成员的类，编译器不会为其合成默认构造函数</li>
<li>本质上，当不可能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的</li>
</ul>
</li>
<li>
<p>private拷贝控制</p>
<ul>
<li>我们可以将这些拷贝控制成员声明为private的以阻止用户代码拷贝这个类型的对象。但是，友元和成员函数依旧可以拷贝对象，为了阻止这一点可以声明为private但并不定义他们。声明但并不定义一个成员函数是合法的</li>
<li>通过声明（但不定义）private的拷贝构造函数，可以阻止任何拷贝该类对象的企图：试图拷贝对象的用户代码将在编译阶段报错，成员函数或友元函数中的拷贝操作将在链接时报错</li>
<li>需要阻止拷贝的类应该使用=delete来定义它们自己的拷贝构造函数和拷贝赋值运算符，而不应该将它们声明为private的</li>
</ul>
</li>
</ul>
<h1>13.2 拷贝控制和资源管理</h1>
<ul>
<li>通常，管理类外资源的类必须定义拷贝控制成员。为了定义这些成员，我们首先必须确定此对象的拷贝语义。一般来讲，有两种选择：
<ul>
<li>
<p>使类的行为看起来像<strong>一个值</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类的行为像一个值：意味着它有自己的状态。当我们拷贝一个像值的对象时，副本和原对象是完全对立的。改变副本不会对对原对象有任何影响。反之亦然。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使类的行为看起来像<strong>一个指针</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">行为像指针的类则共享状态。当我们拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="13-2-1-行为像值的类"><a class="header-anchor" href="#13-2-1-行为像值的类">¶</a>13.2.1 行为像值的类</h2>
<ul>
<li>
<p>为了提供类值的行为，对于类管理的资源，每个对象应该都拥有一份自己的拷贝。</p>
</li>
<li>
<p>类值拷贝赋值运算符</p>
<ul>
<li>
<p>通常组合了析构函数和构造函数的操作。类似析构函数，赋值操作会销毁左侧运算对象的资源。类似构造函数，赋值操作会从右侧运算对象拷贝数据。</p>
</li>
<li>
<p>编写赋值运算符时，有两点需要注意：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 如果将一个对象赋予它自身，赋值运算符必须能正确工作</span><br><span class="line">2. 大多数赋值运算符组合了析构函数和拷贝构造函数的工作</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>当编写一个赋值运算符时，一个好的方法是先将右侧运算对象拷贝到一个局部临时对象中，然后再销毁左侧运算对象就是安全的了。</p>
</li>
</ul>
</li>
</ul>
<h2 id="13-2-2-定义行为像指针的类"><a class="header-anchor" href="#13-2-2-定义行为像指针的类">¶</a>13.2.2 定义行为像指针的类</h2>
<ul>
<li>
<p>引用计数</p>
<ol>
<li>除了初始化对象之外，每个构造函数(拷贝构造函数除外)还要创建一个引用计数，用来记录有多少对象正在与创建的对象共享状态。当我们创建一个对象时，只有一个对象共享状态，因此计数器初始化为1。</li>
<li>拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器，指出给定对象的状态又被一个新用户共享。</li>
<li>析构函数递减计数器，指出共享状态的用户少了一个。如果计数器变为0，则析构函数释放状态。</li>
<li>拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，意味着它的共享状态没有用户了，拷贝赋值运算符就必须销毁状态。</li>
</ol>
</li>
<li>
<p>引用计数的存放位置</p>
<p>  只保存在动态内存中。当创建一个对象时，我们也分配一个计数器。当拷贝或赋值对象时，我们拷贝指向计时器的指针。使用这种方法，副本和原对象都会指向相同的计数器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	HasPtr(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>()):</span><br><span class="line">	ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(s)), i(<span class="number">0</span>), use(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>(<span class="number">1</span>)) &#123; &#125;</span><br><span class="line">	HasPtr(<span class="keyword">const</span> HasPtr &amp;p):</span><br><span class="line">	ps(p.ps), i(p.i), use(p.use) &#123; ++*use; &#125;</span><br><span class="line">	HasPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr&amp;);</span><br><span class="line">	~HasPtr();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> *ps;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">std</span>::<span class="keyword">size_t</span> *use;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HasPtr::~HasPtr()&#123;</span><br><span class="line">	<span class="keyword">if</span> ( --*use == <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="keyword">delete</span> ps;</span><br><span class="line">		<span class="keyword">delete</span> use;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;rhs)&#123;</span><br><span class="line">	++*rhs.use;</span><br><span class="line">	<span class="keyword">if</span>( --*use == <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="keyword">delete</span> ps;</span><br><span class="line">		<span class="keyword">delete</span> use;</span><br><span class="line">	&#125;</span><br><span class="line">	ps = rhs.ps;</span><br><span class="line">	i = rhs.i;</span><br><span class="line">	use = rhs.use;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>13.3 交换操作</h1>
<ul>
<li>
<p>为了交换两个对象我们需要进行一次拷贝和两次赋值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HasPtr temp = v1;</span><br><span class="line">v1 = v2;</span><br><span class="line">v2 = temp;</span><br></pre></td></tr></table></figure>
<p>我们更希望交换指针，而不用分配string的新副本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string *temp = v1.ps;</span><br><span class="line">v1.ps = v2.ps;</span><br><span class="line">v2.ps = temp;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>swap函数应该调用swap，而不是std::swap</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果存在特定类型的swap版本，swap调用会与之匹配；如果不存在类型特定的版本，则会使用std中的版本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Foo &amp;lhs, Foo &amp;rhs)</span></span>&#123;</span><br><span class="line"> <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line"> swap(lhs.h, rhs.h);<span class="comment">//使用HasPtr版本的swap</span></span><br><span class="line"> <span class="comment">//交换类型Foo的其他成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>编写自己的swap函数：</strong></p>
<p>  swap就是为了优化代码，所以声明为inline，在swap内部逐个交换内置类型，所以使用std::swap.</p>
<p>  swap并不是必要的，但是对于分配了资源的类，定义swap可能是一种很重要的优化手段。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr&amp;, HasPtr&amp;)</span></span>;</span><br><span class="line">	<span class="comment">//其他成员定义</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp;lhs, HasPtr &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">	swap(lhs.ps, rhs.ps);</span><br><span class="line">	swap(lhs.i, rhs.i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在赋值运算符中使用swap，使用了一种名为拷贝并交换的技术，将左侧运算对象的一个对象和右侧运算对象的一个对象进行交换。使用拷贝和交换的赋值运算符自动就是异常安全的，且能正确处理自赋值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(HasPtr rhs)</span><br><span class="line">&#123;</span><br><span class="line">	swap(*<span class="keyword">this</span>, rhs);</span><br><span class="line">	<span class="comment">//rhs里的指针指向了*this里面指针原来指向的位置，函数结束之后自动销毁</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>13.4 拷贝控制示例</h1>
<blockquote>
<p>定义两个类，用于邮件处理应用。Message和Folder，代表邮件消息和消息目录。</p>
<p>为了记录每个Message位于哪些Folder中，每个Message保存一个它所在的Folder的指针的set。同样，每个Folder也保存一个它包含的Message的指针的set。</p>
<p>Message提供save和remove操作，向folder添加和删除一个message</p>
</blockquote>
<ul>
<li>
<p>Message类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Folder</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//folders被隐式初始化为空集合</span></span><br><span class="line">    explicit Message(const std::string &amp;str = ""): contents(str) &#123; &#125;</span><br><span class="line">    Message(<span class="keyword">const</span> Message&amp;);</span><br><span class="line">    Message&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Message&amp;);</span><br><span class="line">    ~Message();</span><br><span class="line">    <span class="comment">//从给定的Folder中添加/删除本Message</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(Folder&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Folder&amp;)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> contents; <span class="comment">//包含消息文本</span></span><br><span class="line">    <span class="comment">//folders被隐式初始化为空集合</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;Folder*&gt; folders;   <span class="comment">//包含本Message的Folder</span></span><br><span class="line">    <span class="comment">//拷贝构造函数、拷贝赋值运算符和析构函数所使用的工具函数</span></span><br><span class="line">    <span class="comment">//将本Message添加到指定参数的Folder中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_to_Folders</span><span class="params">(<span class="keyword">const</span> Message&amp;)</span></span>;</span><br><span class="line">    <span class="comment">//从folders中的每个Folder中删除本Message</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove_from_Folders</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Save和Remove成员函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Message::save(Folder &amp;f)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在Message中添加Folder的指针，然后在Folder中添加Message的指针</span></span><br><span class="line">    folders.insert(&amp;f);  <span class="comment">//将给定Folder的指针添加到我们的Folder列表中</span></span><br><span class="line">    f.addMsg(<span class="keyword">this</span>);   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Message::remove(Folder &amp;f)</span><br><span class="line">&#123;</span><br><span class="line">    folders.erase(&amp;f);    <span class="comment">//对应上面的insert</span></span><br><span class="line">    f.remMsg(<span class="keyword">this</span>);       <span class="comment">//对应上面的addMsg</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Message类的析构函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Message::remove_from_Folders()<span class="comment">//析构和赋值都会用到这个工具函数</span></span><br><span class="line">&#123;    <span class="keyword">for</span>(<span class="keyword">auto</span> f : folders)</span><br><span class="line">        f-&gt;remMsg(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Message::~Message()</span><br><span class="line">&#123;</span><br><span class="line">    remove_from_Folders();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Message类的拷贝构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Message::add_to_Folders(<span class="keyword">const</span> Message &amp;m)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> f : m.folders)</span><br><span class="line">        f-&gt;addMsg(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Message::Message(<span class="keyword">const</span> Message &amp;m):contents(m.contents),folders(m.folders)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for(auto f : m.folders) //也可以，不过使用工具函数更方便</span></span><br><span class="line"><span class="comment">        f-&gt;addMsg(this);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//使用上一个工具函数</span></span><br><span class="line">    add_to_Folders(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Message的拷贝赋值运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Message&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Message&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//通过先删除指针再插入它们来处理自赋值情况</span></span><br><span class="line">    remove_from_Folders();<span class="comment">//更新已有Folder</span></span><br><span class="line">    folders = rhs.folders;    </span><br><span class="line">    contents = rhs.contents;</span><br><span class="line">    add_to_Folders(rhs);<span class="comment">//将本Message添加到那些Folder中</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Swap类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">const</span> Message&amp; lhs, <span class="keyword">const</span> Message&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将每个Msg从原来的Folder中删除</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> f : lhs.folder)</span><br><span class="line">        f-&gt;remMsg(&amp;lhs);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> f : rhs.folder)</span><br><span class="line">        f-&gt;remMsg(&amp;rhs);</span><br><span class="line">    <span class="comment">//交换Folders</span></span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">    swap(lhs.content, rhs.content); <span class="comment">//使用swap(string&amp;, string&amp;);</span></span><br><span class="line">    swap(lhs.folders, rhs.folders); <span class="comment">//使用swap(set&amp;, set&amp;);</span></span><br><span class="line">    <span class="comment">//将每个Msg添加到新的Folder中。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> f : lhs.folder)</span><br><span class="line">        f-&gt;addMsg(&amp;lhs);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> f : rhs.folder)</span><br><span class="line">        f-&gt;addMsg(&amp;rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>13.5 动态内存管理类</h1>
<ul>
<li>
<p>StrVec类定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// simplified implementation of the memory allocation strategy for a vector-like class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StrVec(): <span class="comment">// the allocator member is default initialized</span></span><br><span class="line">        elements(<span class="literal">nullptr</span>), first_free(<span class="literal">nullptr</span>), cap(<span class="literal">nullptr</span>) &#123; &#125;</span><br><span class="line">    StrVec(<span class="keyword">const</span> StrVec&amp;); <span class="comment">// copy constructor</span></span><br><span class="line">    StrVec &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> StrVec&amp;); <span class="comment">// copy assignment</span></span><br><span class="line">    ~StrVec(); <span class="comment">// destructor</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>; <span class="comment">// copy the element</span></span><br><span class="line">    <span class="keyword">size_t</span> size() <span class="keyword">const</span> &#123; <span class="keyword">return</span> first_free - elements; &#125;</span><br><span class="line">    <span class="keyword">size_t</span> capacity() <span class="keyword">const</span> &#123; <span class="keyword">return</span> cap - elements; &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> *<span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> elements; &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> *<span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> first_free; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::allocator&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; alloc; <span class="comment">// 默认初始化</span></span><br><span class="line">    <span class="comment">// used by the functions that add elements to the StrVec</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">chk_n_alloc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">if</span> (size() == capacity()) reallocate(); &#125;</span><br><span class="line">    <span class="comment">// utilities used by the copy constructor, assignment operator, and destructor</span></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">string</span>*, <span class="built_in">std</span>::<span class="built_in">string</span>*&gt; alloc_n_copy </span><br><span class="line">        			(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>*, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>*);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">()</span></span>; <span class="comment">// destroy the elements and free the space</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reallocate</span><span class="params">()</span></span>; <span class="comment">// get more space and copy the existing elements</span></span><br><span class="line">    <span class="comment">//以下指针都是显示初始化为nullptr</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *elements; <span class="comment">// pointer to the first element in the array</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *first_free; <span class="comment">// pointer to the first free element in the array</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *cap; <span class="comment">// pointer to one past the end of the array</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用construct</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> StrVec::push_back(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)&#123;</span><br><span class="line">	chk_n_alloc();</span><br><span class="line">	alloc.construct(first_free++, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>alloc_n_copy</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分配足够内存保存给定范围的元素，并将元素拷贝到新分配的内存中。返回一个pair，分别指向新空间的开始位置和拷贝的尾后的位置</span></span><br><span class="line">pair&lt;<span class="built_in">string</span> *, <span class="built_in">string</span> *&gt; </span><br><span class="line">strVec::alloc_n_copy(<span class="keyword">const</span> <span class="built_in">string</span> *b, <span class="keyword">const</span> <span class="built_in">string</span> *e)&#123;</span><br><span class="line">	<span class="keyword">auto</span> data = alloc.allocate(e - b);</span><br><span class="line">    <span class="keyword">return</span> &#123;data, uninitialized_copy(b, e, data)&#125;;<span class="comment">//uninitialized返回最后一个构造元素之后的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>free成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> StrVec::<span class="built_in">free</span>()&#123;</span><br><span class="line">	<span class="keyword">if</span> (elements) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = first_free; p != elements; <span class="comment">/* 空 */</span>)</span><br><span class="line">            alloc.destroy(--p);</span><br><span class="line">        alloc.deallocate(elements, cap - elements);</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>拷贝控制成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">StrVec::StrVec(<span class="keyword">const</span> StrVec &amp;s)&#123;</span><br><span class="line">    <span class="keyword">auto</span> newdata = alloc_n_copy(s.begin(), s.end());</span><br><span class="line">    element = newdata.first;</span><br><span class="line">    first_free = cap = newdata.second;</span><br><span class="line">    <span class="comment">//由于alloc_n_copy分配的空间恰好容纳给定元素，cap也指向最后一个构造元素之后的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数调用</span></span><br><span class="line">StrVec::~StrVec()&#123; <span class="built_in">free</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝赋值运算符</span></span><br><span class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>=(<span class="keyword">const</span> StrVec &amp;rhs)&#123;</span><br><span class="line">    <span class="keyword">auto</span> data = alloc_n_copy(rhs.begin(), rhs.end());</span><br><span class="line">    <span class="built_in">free</span>();<span class="comment">//释放左侧对象管理的内存</span></span><br><span class="line">    elements = data.first;</span><br><span class="line">    first_free = cap = data.second;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>重新分配内存的过程中移动而不是拷贝元素</p>
<ul>
<li>为一个新的、更大的string数组分配内存</li>
<li>在内存空间前一部分构造对象，保存现有元素</li>
<li>销毁原内存空间中的元素，并释放这块内存</li>
</ul>
</li>
</ul>
<blockquote>
<p>为StrVec重新分配内存空间会引起旧内存空间到新内存空间逐个拷贝string。拷贝一个string必须为字符分配内存空间，而销毁一个string必须释放所占用的内存。但是对于deallocate来说，拷贝这些string中的数据是多余的，重新分配内存空间，如果我们能避免分配和释放string的额外开销，StrVec的性能会好得多</p>
</blockquote>
<ul>
<li>
<p>移动构造函数和std::move</p>
<ul>
<li>有一些标准库类，包括string，都定义了所谓的&quot;移动构造函数&quot;。给定资源移动到而不是拷贝到正在创建的对象。保证移后源string仍然是一个有效的、可析构的状态。对于string，可以想象每个string都有一个指向char数组的指针，可以假定string的移动构造函数进行了指针的拷贝，而不是为字符分配内存空间然后拷贝字符</li>
<li>utility头文件中的move标准库函数。关于move，首先，当reallocate在新内存中构造string时，必须调用move来表示希望使用string的移动构造函数。其次，通常不为move提供一个using声明，当我们使用move，直接调用std::move而不是move</li>
</ul>
</li>
<li>
<p>reallocate成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> StrVec::reallocate()&#123;</span><br><span class="line">    <span class="keyword">auto</span> newcapacity = size() ? <span class="number">2</span> * size() : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> newdata = alloc.allocate(newcapacity);<span class="comment">//分配新内存</span></span><br><span class="line">    <span class="keyword">auto</span> dest = newdata;<span class="comment">//指向新数组下一个空闲位置</span></span><br><span class="line">    <span class="keyword">auto</span> elem = elements;<span class="comment">//指向旧数组下一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != size(); i++)</span><br><span class="line">        alloc.construct(dest++, <span class="built_in">std</span>::move(*elem++));</span><br><span class="line">    <span class="built_in">free</span>();<span class="comment">//一旦移动完元素就释放旧内存空间</span></span><br><span class="line">    elements = newdata;</span><br><span class="line">    first_free = dest;</span><br><span class="line">    cap = elements + newcapacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//元素移动完毕后，string成员不再管理它们曾经指向的内存，其数据管理的职责已经转移给新StrVec内存中的元素。不知道旧StrVec内存中的string包含什么值，但我们保证对它们执行string的析构函数是安全的</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>13.6 对象移动</h1>
<blockquote>
<p>使用移动而不是拷贝的另一个原因源于IO类或unique_ptr这样的类。这些类都包含不能被共享的资源，所以这类型的对象不能拷贝但是可以移动；</p>
<p>在旧版本C++中，即使不必拷贝对象，也不得不进行拷贝，如果对象较大，或者对象本身要求分配内存空间，进行不必要的拷贝代价非常高</p>
<p>在旧版本标准库中，容器中所保存的类必须是可拷贝的；但在新标准中，我们可以用容器保存不可拷贝的类型，只要它们能被移动即可；</p>
<p>标准库容器、string和shared_ptr类既支持移动也支持拷贝。IO类和unique_ptr类可以移动但不能拷贝</p>
</blockquote>
<h2 id="13-6-1-右值引用"><a class="header-anchor" href="#13-6-1-右值引用">¶</a>13.6.1 右值引用</h2>
<ul>
<li>
<p>在需要右值的地方可以使用左值代替，但是不能把右值当做左值使用。当一个左值被当做右值使用时，实际使用的是它的内容。</p>
</li>
<li>
<p>所谓右值引用就是<strong>必须绑定到右值的引用</strong>。我们可以通过**&amp;&amp;而不是&amp;**来获得右值引用。<strong>右值引用有一个很重要的特性——只能绑定到一个将要销毁的对象。</strong></p>
</li>
<li>
<p>对于常规的引用，我们可以称之为<strong>左值引用</strong>，我们不能将其绑定到要求转换的表达式、字面值常量或者返回右值的表达式（除非它是一个const引用）。而右值引用有这完全相反的特性：我们可以将一个右值绑定到这类表达式上，但是不可以将一个右值引用绑定到一个左值上。</p>
</li>
<li>
<p><strong>返回左值引用的函数，连同赋值、下标、解引用和前置递增递减运算符</strong>，都是返回左值的表达式的例子。不能将左值引用绑定到这类表达式上，但我们可以将一个const的左值引用或一个右值引用绑定到这类表达式上</p>
</li>
<li>
<p>左值持久；右值短暂</p>
<p>右值引用只能绑定到临时对象，我们得知</p>
<ul>
<li>
<p>所引用的对象将要被销毁</p>
</li>
<li>
<p>该对象没有其他用户</p>
</li>
</ul>
<p>这两个特性意味着使用右值引用的代码可以自由地接管所有引用的对象的资源</p>
</li>
<li>
<p>变量是左值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;rr1 = <span class="number">42</span>;<span class="comment">//正确：字面常量是右值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = rr1;<span class="comment">//错误：表达式rr1是左值</span></span><br><span class="line"><span class="comment">//不能将右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>标准库move函数</p>
<p>  我们可以显式的将一个左值转换成对应的右值引用类型，我们还可以通过标准库函数std::move来获得绑定到左值上的右值引用，此函数定义在头文件utility头文件中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;rr3 = <span class="built_in">std</span>::move(rr1); <span class="comment">//ok</span></span><br></pre></td></tr></table></figure>
<p>  <strong>在对一个对象调用move操作后，我们不能对移后源对象的值做任何假设</strong>。我们可以销毁一个移后源对象，也可以赋予它新值，但是不能使用它</p>
</li>
</ul>
<h2 id="13-6-2-移动构造函数和移动赋值运算符"><a class="header-anchor" href="#13-6-2-移动构造函数和移动赋值运算符">¶</a>13.6.2 移动构造函数和移动赋值运算符</h2>
<ul>
<li>
<p>移动操作、标准库容器和异常</p>
<p>  我们必须先认清两个事实：首先，虽然移动操作通常不抛出异常，但是抛出异常也是允许的；<strong>其次，标准库容器能对异常发生时其自身的行为提供保障</strong>，例如vector保证，如果我们push_back时抛出异常，则vector自身将不发生改变。<br>
  <strong>现在我们假设vector在push_back的过程需要重新分配资源，所以其会把旧元素移动到新内存中，就像StrVec中那样。如果此过程中使用了移动构造函数，而移动构造函数在移动了部分元素后抛出了异常，那么旧空间中的元素已经被改变，而新空间中未构造的元素尚不存在，此时vector将不能保证抛出异常时保持自身不变的要求。但是如果此过程使用的是拷贝构造函数而非移动构造函数，那么即使拷贝构造函数抛出异常，旧元素的值仍未发生任何变化，vector可以满足保持自身不变的要求。所以为了避免这种潜在问题，除非vector知道元素的移动构造函数不会抛出异常，否则其在重新分配内存的时候，它将使用拷贝构造函数而非移动构造函数。所以如果我们希望vector这类的容器在重新分配内存时对自定义类型使用移动构造函数而非拷贝构造函数，那么我们必须将自定义类型的移动构造函数（以及移动赋值操作符）标记为noexcept（不会抛出异常）。</strong></p>
</li>
<li>
<p>移动赋值运算符</p>
<p>  移动赋值运算符执行与析构函数和移动构造函数相同的工作，而且要注意的是其也必须正确处理自赋值的情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">StrVec &amp;<span class="keyword">operator</span>=(StrVec &amp;&amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断是否是自赋值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>();</span><br><span class="line">        elements = rhs.elements;</span><br><span class="line">        first_free = rhs.first_free;</span><br><span class="line">        cap = rhs.cap;</span><br><span class="line">        <span class="comment">//使移后源对象处于可以安全销毁的状态</span></span><br><span class="line">        rhs.cap = rhs.elements = rhs.first_free = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <strong>进行检查的原因是此右值可能是move调用的返回结果</strong>，关键点在于我们不能在使用右侧运算对象的资源之前就释放左侧对象的资源。</p>
</li>
<li>
<p>移后源对象必须可以析构</p>
<p>  当我们编写一个移动操作后，**必须要确保移后源对象进入一个可安全析构的状态，并且移动操作还必须保证移后源对象仍然是有效的。**有效是指可以安全的对其赋新值或者可以安全使用而不依赖其当前值。但是用户不能对移后源对象的值做任何假设，一般在对其重新赋值之前不要使用它。</p>
</li>
<li>
<p>合成的移动操作</p>
<p>  与处理拷贝构造函数和拷贝赋值运算符一样，编译器也会合成移动构造函数和移动赋值运算符，但是其合成的条件不同：<strong>只有当一个类没有定义任何自己版本的拷贝控制成员，且它的所有非static数据成员都能够移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//X的成员都可以被移动，所以编译器会为其合成移动操作</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;          <span class="comment">//内置类型可以被移动</span></span><br><span class="line">    <span class="built_in">string</span> s;       <span class="comment">//string定义了自己的移动操作</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hasX</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    X mem;          <span class="comment">//X可以被移动，所以hasX也有合成的移动操作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  在以下情况下，编译器会将移动操作定义为删除的函数：（如果我们显式地将移动操作声明为default，且编译器不能移动所有成员，那么编译器会将移动操作定义为删除的函数）</p>
<ol>
<li>类成员定义了自己的拷贝构造函数而未定义移动构造函数，或者有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。移动赋值运算符的情况类似。</li>
<li>有类成员的移动构造函数或者移动赋值运算符被定义为删除的或者是不可访问时。</li>
<li>如果一个类的析构函数定义为删除的或者是不可访问的，则类的移动操作被定义为删除的。</li>
<li>如果有类的成员是const或者const引用，则类的移动赋值运算符被定义为删除的。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hasY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    hasY() = <span class="keyword">default</span>;</span><br><span class="line">    hasY(hasY &amp;&amp;) = <span class="keyword">default</span>;   <span class="comment">//vs2013尚不支持将移动构造函数声明为default</span></span><br><span class="line">    Y mem;      <span class="comment">//假设Y是一个类，其移动构造函数是删除，则hasY的移动构造函数也会被定义为删除的</span></span><br><span class="line">&#125;;</span><br><span class="line">hasY hy, hy2 = <span class="built_in">std</span>::move(hy); <span class="comment">//错误：移动构造函数是删除的</span></span><br><span class="line"><span class="comment">//如果hasY忽略移动构造函数的声明，则编译器根本不能为它合成一个。如果移动操作可能被定义为删除的函数，编译器就不会合成它们。</span></span><br></pre></td></tr></table></figure>
<p>  移动操作和合成的拷贝控制成员还有最后一个相互关系：<strong>如果一个类定义了一个移动构造函数或一个移动赋值操作符，则该类的合成拷贝构造函数或合成拷贝赋值运算符会被定义为删除的函数。</strong></p>
</li>
<li>
<p>移动右值，拷贝左值</p>
<p>  当一个类既有移动构造函数，也有拷贝构造函数，编译器会使用<strong>普通的函数匹配机制</strong>来确定使用哪个构造函数，<strong>左值匹配拷贝构造函数，右值匹配移动构造函数。</strong></p>
</li>
<li>
<p>但如果没有移动构造函数，右值也被拷贝</p>
<p>  <strong>如果一个类没有移动构造函数，那么即使右值也会被拷贝，即使我们试图通过move来移动它们</strong>。用拷贝构造函数代替移动构造函数几乎总是安全的。</p>
</li>
<li>
<p>拷贝并交换赋值运算符和移动操作</p>
<p>  更新三/五原则：所有五个拷贝控制成员都应看做一个整体：**一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作，**特别是对于要在类内管理资源的类型。</p>
</li>
<li>
<p>Message类的移动操作</p>
</li>
<li>
<p>移动迭代器</p>
<p>  新标准中定义了一种移动迭代器适配器，<strong>移动迭代器的解引用运算符将生成一个右值引用</strong>。我们可以通过<strong>make_move_iterator</strong>将一个普通迭代器转换为移动迭代器，然后我们可以将一对移动迭代器传递给算法。于是我们可以重写StrVec的reallocate函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> StrVec::reallocate()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> newcapacity = size() ? <span class="number">2</span> * size() : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = alloc.allocate(newcapacity);</span><br><span class="line">    <span class="comment">//使用移动迭代器，将旧元素移动到新分配的内存中</span></span><br><span class="line">    <span class="keyword">auto</span> last = uninitialized_copy(make_move_iterator(begin()), make_move_iterator(end()), first);</span><br><span class="line">    <span class="built_in">free</span>();         <span class="comment">//释放旧内存</span></span><br><span class="line">    elements = first;</span><br><span class="line">    first_free = last;</span><br><span class="line">    cap = elements + newcapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <strong>不要随意进行移动操作</strong>：由于一个移后源对象具有不确定的状态，所有我们必须确信对某对象移动后不再使用其值才对其进行移动操作，否则可能造成莫名其妙的错误。在代码小心的使用std::move操作，可以大幅度提升性能。</p>
</li>
</ul>
<h2 id="13-6-3-右值引用和成员函数"><a class="header-anchor" href="#13-6-3-右值引用和成员函数">¶</a>13.6.3 右值引用和成员函数</h2>
<ul>
<li>
<p>除了移动操作外，我们也可以普通的成员函数提供拷贝和移动两种版本，通常一个版本接受<strong>一个const的左值引用</strong>为参数，令一个版本接受一个<strong>非const的右值引用</strong>。比如我们可以为StrVec的push_back定义两个版本，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拷贝版本，可绑定任意类型的string值</span></span><br><span class="line"><span class="keyword">void</span> StrVec::push_back(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">    chk_n_alloc();</span><br><span class="line">    alloc.construct(first_free++, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移动版本，只能绑定到一个string右值</span></span><br><span class="line"><span class="keyword">void</span> StrVec::push_back(<span class="built_in">string</span> &amp;&amp;s)</span><br><span class="line">&#123;</span><br><span class="line">    chk_n_alloc();</span><br><span class="line">    alloc.construct(first_free++, <span class="built_in">std</span>::move(s));    <span class="comment">//差别只在此处使用移动操作而非拷贝操作    </span></span><br><span class="line">&#125;</span><br><span class="line">StrVec sv;</span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"copy"</span>;</span><br><span class="line">sv.push_back(s);    <span class="comment">//调用拷贝版本的成员函数</span></span><br><span class="line">sv.push_back(<span class="string">"move"</span>);  <span class="comment">//调用移动版本的成员函数</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>右值和左值引用成员函数</p>
<p>  在c++11之前，我们在一个对象上调用成员函数，不会判断该对象是一个左值还是右值，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">"a value"</span>, s2 = <span class="string">"another"</span>;</span><br><span class="line"><span class="keyword">auto</span> n = (s1 + s2).find(<span class="string">'a'</span>); <span class="comment">//s1+s2返回了一个右值，然后在右值对象上调用find函数`</span></span><br></pre></td></tr></table></figure>
<p>然而有时我们可以以一种令人惊讶的方式使用右值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 + s2 = <span class="string">"wow!"</span>;<span class="comment">//对一个右值进行赋值操作！！！</span></span><br></pre></td></tr></table></figure>
<p>在旧标准中我们无法阻止这种使用方式。为了维持向后兼容，c<ins>11仍然允许向右值赋值，但是c</ins>11增加了一种阻止这种用法的方法，即使用<strong>引用限定符</strong>。我们通过在函数声明与定义中加入引用限定符来限定调用对象的左右值属性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo <span class="keyword">operator</span>=(<span class="keyword">const</span> Foo &amp;) &amp;;<span class="comment">//限定只能向可修改的左值赋值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>引用限定符实际作用和const的声明一样，我们知道<strong>const实际上是声明this指针的类型，而引用限定符实际上也是声明this指针的类型，&amp;声明this指针指向一个左值，&amp;&amp;声明this指针指向一个右值。</strong><br>
		一个函数可以同时使用const和引用限定，引用限定符必须跟随在const限定符之后。</p>
</li>
<li>
<p>重载和引用函数</p>
<p>  就像一个成员函数可以根据是否有const来区分其重载版本一样，引用限定符也可以区分重载版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//以下函数会构成重载函数</span></span><br><span class="line">    <span class="function">Foo <span class="title">sort</span><span class="params">()</span> &amp;</span>;   </span><br><span class="line">    <span class="function">Foo <span class="title">sort</span><span class="params">()</span> &amp;&amp;</span>;  </span><br><span class="line">    <span class="function">Foo <span class="title">sort</span><span class="params">()</span> <span class="keyword">const</span> &amp;</span>;</span><br><span class="line">    <span class="function">Foo <span class="title">sort</span><span class="params">()</span> <span class="keyword">const</span> &amp;&amp;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>需要注意的是如果我们定义了两个或者两个以上的<strong>具有相同名字和相同参数列表的成员函数（注意并非所有重载函数集）</strong>，就必须对所有函数加上引用限定符，或者所有都不加：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误，两个sort函数要不都有引用限定符，要不都没有引用限定符</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Foo <span class="title">sort</span><span class="params">()</span> &amp;</span>;</span><br><span class="line">    <span class="function">Foo <span class="title">sort</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正确</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Foo <span class="title">sort</span><span class="params">()</span> &amp;</span>;</span><br><span class="line">    <span class="function">Foo <span class="title">sort</span><span class="params">()</span> <span class="keyword">const</span> &amp;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正确</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Foo <span class="title">sort</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Foo <span class="title">sort</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//与上面的函数参数列表不同</span></span><br><span class="line">    <span class="function">Foo <span class="title">sort</span><span class="params">(<span class="keyword">int</span> *)</span> &amp;</span>;</span><br><span class="line">    <span class="function">Foo <span class="title">sort</span><span class="params">(<span class="keyword">int</span> *)</span> <span class="keyword">const</span> &amp;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/18/C-Primer学习笔记：第12章-动态内存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/18/C-Primer学习笔记：第12章-动态内存/" itemprop="url">C++ Primer学习笔记：第12章 动态内存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-18T18:51:00+08:00">2019-07-18</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>12.1 动态内存与智能指针</h1>
<ul>
<li>定义在memory头文件中的三种智能指针
<ul>
<li>shared_ptr允许多个指针指向同一个对象</li>
<li>unique_ptr则独占所指向的对象</li>
<li>weak_ptr是弱引用，指向shared_ptr所管理的对象</li>
</ul>
</li>
</ul>
<h2 id="12-1-1-shared-ptr类"><a class="header-anchor" href="#12-1-1-shared-ptr类">¶</a>12.1.1 shared_ptr类</h2>
<ul>
<li>shared和unique都支持
<ul>
<li>shared_ptr<t> sp</t></li>
<li>unique_ptr<t> up</t></li>
<li>p //用作条件判断</li>
<li>*p</li>
<li>p-&gt;mem</li>
<li>p.get()</li>
<li>swap(p,q)</li>
<li>p.swap(q)</li>
</ul>
</li>
<li>shared_ptr独有的
<ul>
<li>make_shared<t>(args)</t></li>
<li>shared_ptr<t>p(q)</t></li>
<li>p=q</li>
<li>p.unique()</li>
<li>p.use_count()</li>
</ul>
</li>
<li>make_shared函数
<ul>
<li>最安全的分配和使用动态内存的方法</li>
<li>使用方法<code>shared_ptr&lt;int&gt; p3 = make_shared&lt;int&gt;(42);</code>
<ul>
<li>不传参，对象会值初始化</li>
<li>用auto定义对象，保存make_shared的结果</li>
</ul>
</li>
</ul>
</li>
<li>shared_ptr的拷贝和赋值
<ul>
<li>当进行拷贝或赋值，每个shared_ptr会记录有多少其他shared_ptr指向相同对象</li>
<li>每个shared_ptr有引用计数
<ul>
<li>用一个初始化另一个、作为参数传递、作为函数返回值会递增</li>
<li>离开局部作用域、销毁、赋予新值会递减</li>
<li>一旦变为0，它就会释放管理的对象</li>
</ul>
</li>
<li>shared_ptr自动销毁管理的对象
<ul>
<li>通过析构函数实现销毁工作</li>
</ul>
</li>
<li>shared_ptr还会自动释放相关联的内存
<ul>
<li>如果将shared_ptr存放于容器中，而后不需要某些元素（比如重排了容器），此时要用erase删除不再需要的元素</li>
</ul>
</li>
<li>使用了动态生存期的资源的类
<ul>
<li>程序使用动态内存的原因
<ul>
<li>程序不知道自己需要使用多少对象</li>
<li>程序不知道所需对象的准确类型</li>
<li>程序需要在多个对象间共享数据</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="12-1-2-直接管理内存"><a class="header-anchor" href="#12-1-2-直接管理内存">¶</a>12.1.2 直接管理内存</h2>
<p><strong>自己直接管理内存的类与使用智能指针的类不同，不能依赖类对对象拷贝、赋值和销毁操作的任何默认定义</strong></p>
<ul>
<li>
<p>使用new动态分配和初始化对象</p>
<ul>
<li>
<p>动态分配的对象是默认初始化的，内置类型和组合类型的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化</p>
</li>
<li>
<p>为动态分配的对象进行值初始化，只需在类型名后跟一对空括号即可；对于定义了自己构造函数的类类型，要求值初始化没有意义，不管采用什么形式，对象都会通过默认构造函数来初始化；对于内置类型，值初始化的内置类型对象有良好的定义的值，默认初始化的对象的值则是未定义的。对于类中的依赖于合成默认构造函数的内置类型成员，如果未在类内初始化，则它们的值也是未定义的</p>
</li>
<li>
<p>如果提供一个括号包围的初始化器，就可以使用auto从此初始化器推断我们想要分配的对象类型，要求括号中仅有单一初始化器才可以使用auto</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p1 = <span class="keyword">new</span> <span class="keyword">auto</span>(obj);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>动态分配的const对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> *pcs = <span class="keyword">new</span> <span class="keyword">const</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="comment">//必须初始化，有默认构造函数的类类型，其const动态对象可以隐式初始化，其他类型必须显示初始化。返回的是指向const的指针</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>内存耗尽</p>
<ul>
<li>bad_alloc异常</li>
<li>定位new:<code>int *p2 = new (nothrow) int;//不能抛出异常，如果不能分配所需内存，会返回空指针</code></li>
</ul>
</li>
<li>
<p>释放动态内存（delete表达式）</p>
<ul>
<li>销毁指针指向的对象</li>
<li>释放对应内存</li>
</ul>
</li>
<li>
<p>指针值和delete</p>
<ul>
<li><strong>释放空指针总是没有错误的</strong></li>
<li>const对象可以被销毁</li>
</ul>
</li>
<li>
<p>动态对象的生存期直到被释放时为止</p>
<ul>
<li>内置指针管理的动态内存必须显示释放</li>
</ul>
</li>
<li>
<p>delete之后重置指针值</p>
<ul>
<li>空悬指针问题</li>
<li>delete后，将nullptr赋予指针</li>
</ul>
</li>
<li>
<p>只提供了有限的保护</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line"><span class="keyword">auto</span> q = p;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">p = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="12-1-3-shared-ptr和new结合使用"><a class="header-anchor" href="#12-1-3-shared-ptr和new结合使用">¶</a>12.1.3 shared_ptr和new结合使用</h2>
<ul>
<li>
<p>接收指针参数的智能指针构造函数是explicit的，必须用直接初始化形式初始化智能指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;T&gt; p(q); <span class="comment">//q必须指向new分配的内存，能够转换为T*类型，p管理q指向的对象</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;T&gt; p(u); <span class="comment">//u代表unique_ptr，p从u接管所有权，将u置位空</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;T&gt; p(q, d); <span class="comment">//p接管q对象的所有权，q必须能够转为T*类型，p将使用可调用对象d代替delete  </span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;T&gt; p(p2, d);</span><br><span class="line"></span><br><span class="line">p.reset();</span><br><span class="line">p.reset(q);</span><br><span class="line">p.reset(q, d);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>不要混合使用普通指针和智能指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr)</span></span>&#123;</span><br><span class="line">	<span class="comment">//使用ptr</span></span><br><span class="line">&#125;<span class="comment">//ptr离开作用域，被销毁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">x</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>))</span></span>; <span class="comment">//危险：x是普通指针，不是智能指针</span></span><br><span class="line">process(x); <span class="comment">//错误，不能将int *转换为一个shared_ptr&lt;int&gt;</span></span><br><span class="line">process(<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;(x)); <span class="comment">//合法的，但内存会被释放</span></span><br><span class="line"><span class="keyword">int</span> j = *x; <span class="comment">//未定义：x是悬空指针</span></span><br></pre></td></tr></table></figure>
<p>使用一个内置指针访问一个智能指针所负责的对象是很危险的，因为不知道对象何时会被销毁</p>
</li>
<li>
<p>不要用get初始化另一个智能指针或为智能指针赋值</p>
<ul>
<li>使用get返回的指针的代码不要delete此指针</li>
<li>永远不要用get初始化另一个智能指针或者为另一个智能指针赋值</li>
</ul>
</li>
<li>
<p>其他shared_ptr操作</p>
<p>用reset将一个新的指针赋予一个shared_ptr</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!p.unique())</span><br><span class="line">	p.reset(<span class="keyword">new</span> <span class="built_in">string</span>(*p));</span><br><span class="line">*p += newVal;</span><br><span class="line"><span class="comment">//reset和unique一起使用，控制多个shared_ptr共享的对象</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="12-1-4-智能指针和异常"><a class="header-anchor" href="#12-1-4-智能指针和异常">¶</a>12.1.4 智能指针和异常</h2>
<ul>
<li>
<p>智能指针和哑类</p>
<ul>
<li>分配了资源又没定义析构函数来释放资源的类，可能会遇到与使用动态内存相同的错误——忘记释放资源</li>
<li>使用shared_ptr保证资源的释放</li>
</ul>
</li>
<li>
<p>使用自己的释放操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">end_connection</span><span class="params">(connection *p)</span> </span>&#123; disconnect(*p) &#125;; <span class="comment">//定义自己的删除器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(destination &amp;d <span class="comment">/* 其他参数 */</span>)</span></span>&#123;</span><br><span class="line">    connection c = connect(&amp;d);</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;connection&gt; p(&amp;c, end_connection);</span><br><span class="line">    <span class="comment">//使用连接</span></span><br><span class="line">    <span class="comment">//即使由于异常而退出，connection也会被正确关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不使用相同的内置指针值(reset)初始化多个智能指针</li>
<li>不delete get()返回的指针</li>
<li>不使用get()初始化或reset另一个智能指针</li>
<li>如果使用get()返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了</li>
<li>如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器</li>
</ul>
</li>
</ul>
<h2 id="12-1-5-unique-ptr"><a class="header-anchor" href="#12-1-5-unique-ptr">¶</a>12.1.5 unique_ptr</h2>
<blockquote>
<p>一个unique_ptr独占它所指向的对象</p>
</blockquote>
<ul>
<li>
<p>unique_ptr必须使用直接初始化形式</p>
</li>
<li>
<p>没有类似make_shared的标准库函数返回一个unique_ptr</p>
</li>
<li>
<p>unique_ptr不支持普通的拷贝或赋值操作</p>
</li>
<li>
<p>可以通过release或reset将指针所有权从一个（非const）unique_ptr转移给另一个unique</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p1(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Stegosaurus"</span>));</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p2(p1.release()); <span class="comment">//所有权从p1转移给p2</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p3(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Trex"</span>));</span><br><span class="line">p2.reset(p3.release()); <span class="comment">//将所有权从p3转移给p2，reset释放了p2原来指向的内存</span></span><br><span class="line"></span><br><span class="line">p2.release(); <span class="comment">//错误：p2不释放内存，而且我们丢失了指针</span></span><br><span class="line"><span class="keyword">auto</span> p = p2.release(); <span class="comment">//正确，必须记得delete(p)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>传递unique_ptr参数和返回unique_ptr</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; clone(<span class="keyword">int</span> p)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="keyword">int</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; clone(<span class="keyword">int</span> p)&#123;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; ret(<span class="keyword">new</span> <span class="keyword">int</span>(p));</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译器知道要返回的对象将被销毁，所以会执行特殊的拷贝</span></span><br><span class="line"><span class="comment">//向后兼容：auto_ptr具有unique_ptr部分特性，但不是全部。不能在容器中保存auto_ptr，也不能从函数中返回auto_ptr</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>向unique_ptr传递删除器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;objT, delT&gt; p(<span class="keyword">new</span> objT, fcn);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(destination &amp;d <span class="comment">/* 其他需要的参数 */</span>)</span></span>&#123;</span><br><span class="line">    connection c = connect(&amp;d);</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;connection, delctype(end_connection)*&gt; p(&amp;c, end_connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="12-1-6-weak-ptr"><a class="header-anchor" href="#12-1-6-weak-ptr">¶</a>12.1.6 weak_ptr</h2>
<blockquote>
<p>不控制所指对象生存期的智能指针，指向一个由shared_ptr管理的对象，将weak_ptr绑定到shared_ptr不会改变shared_ptr的引用计数</p>
</blockquote>
<p>由于对象可能不存在，不能使用weak_ptr直接访问对象，必须调用lock</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">weak_ptr&lt;<span class="keyword">int</span>&gt; wp(p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; np = wp.lock())&#123;</span><br><span class="line">	<span class="comment">//在if中，np与p共享对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>核查指针类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlob</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> size_type = <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::size_type;</span><br><span class="line">    StrBlob();</span><br><span class="line">    StrBlob(<span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; il);</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;size(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;empty(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回string的引用，是因为调用点会使用该string</span></span><br><span class="line">    <span class="comment">//如b.front() = "first";</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span>&amp; <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span>&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//只有const StrBlob对象才会调用以下函数</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">StrBlobPtr <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">StrBlobPtr <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; data;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="keyword">const</span> <span class="built_in">string</span> &amp;msg)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">StrBlob::StrBlob(): data(make_shared&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;())</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">StrBlob::StrBlob(<span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; il): data(make_shared&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;(il))</span><br><span class="line">&#123;   </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> StrBlob::check(size_type i, <span class="keyword">const</span> <span class="built_in">string</span> &amp;msg) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= data-&gt;size())</span><br><span class="line">        <span class="keyword">throw</span> out_of_range(msg);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> StrBlob::push_back(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">    data-&gt;push_back(s);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> StrBlob::pop_back()</span><br><span class="line">&#123;</span><br><span class="line">    check(<span class="number">0</span>, <span class="string">"此StrBlob对象指向一个空vector！\n"</span>);</span><br><span class="line">    data-&gt;pop_back();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">string</span>&amp; StrBlob::front()</span><br><span class="line">&#123;</span><br><span class="line">    check(<span class="number">0</span>, <span class="string">"此StrBlob对象指向一个空vector！\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> data-&gt;front();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">string</span>&amp; StrBlob::back()</span><br><span class="line">&#123;</span><br><span class="line">    check(<span class="number">0</span>, <span class="string">"此StrBlob对象指向一个空vector！\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> data-&gt;back();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span>&amp; StrBlob::front() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    check(<span class="number">0</span>, <span class="string">"此StrBlob对象指向一个空vector！\n"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用对象为const StrBlob！\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> data-&gt;front();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span>&amp; StrBlob::back() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    check(<span class="number">0</span>, <span class="string">"此StrBlob对象指向一个空vector！\n"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用对象为const StrBlob！\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> data-&gt;back();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StrBlobPtr(): curr(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    StrBlobPtr(StrBlob &amp;b, <span class="keyword">size_t</span> sz = <span class="number">0</span>): wptr(b.data), curr(sz) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span>&amp; <span class="title">deref</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">StrBlobPtr&amp; <span class="title">incr</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    weak_ptr&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; wptr;</span><br><span class="line">    <span class="keyword">size_t</span> curr;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; check(<span class="keyword">size_t</span> i, <span class="keyword">const</span> <span class="built_in">string</span> &amp;msg) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; StrBlobPtr::check(<span class="keyword">size_t</span> i, <span class="keyword">const</span> <span class="built_in">string</span> &amp;msg) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = wptr.lock();</span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">        <span class="keyword">throw</span> runtime_error(<span class="string">"要访问的vector&lt;string&gt;对象不存在！\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= ret-&gt;size())</span><br><span class="line">        <span class="keyword">throw</span> out_of_range(msg);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">string</span>&amp; StrBlobPtr::deref() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = check(curr, <span class="string">"当前下标不合法！\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> (*p)[curr];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::incr()</span><br><span class="line">&#123;</span><br><span class="line">    check(curr, <span class="string">"不能继续递增了\n"</span>);</span><br><span class="line">    ++curr;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">StrBlobPtr StrBlob::begin()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> StrBlobPtr(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">StrBlobPtr StrBlob::end()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> StrBlobPtr(*<span class="keyword">this</span>, data-&gt;size());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StrBlob b1&#123;<span class="string">"mon"</span>, <span class="string">"tue"</span>, <span class="string">"wed"</span>, <span class="string">"thu"</span>, <span class="string">"fri"</span>&#125;;</span><br><span class="line">    <span class="function">StrBlobPtr <span class="title">p</span><span class="params">(b1, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p.deref() &lt;&lt; <span class="built_in">endl</span>;            <span class="comment">//访问p当前指向的元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p.incr().deref() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//先递增p，再访问元素</span></span><br><span class="line">    p = b1.begin();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p.deref() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>12.2 动态数组</h1>
<h2 id="12-2-1-new和数组"><a class="header-anchor" href="#12-2-1-new和数组">¶</a>12.2.1 new和数组</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[get_size()];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">42</span>];</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> arrT;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>分配一个数组会得到一个元素类型的指针</p>
<p>当用new分配一个数组，并未得到一个数组类型的对象，而是得到一个数组元素类型的指针。所以不能对动态数组调用begin或end（这些函数使用数组维度返回首元素和尾后元素的指针）。也不能用for处理动态数组</p>
</li>
<li>
<p>初始化动态分配对象的数组</p>
<p>new分配的都是默认初始化。</p>
<p>可以在大小之后跟一对空括号进行值初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pia2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]();</span><br></pre></td></tr></table></figure>
<p>还可以提供初始化器花括号列表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pia3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>动态分配一个空数组是合法</p>
<ul>
<li>类比尾后指针，可以像使用尾后迭代器一样使用这个指针</li>
</ul>
</li>
<li>
<p>释放动态数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">delete</span> [] pa; </span><br><span class="line"><span class="comment">//数组中元素逆序销毁</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>智能指针和动态数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>[]&gt; up(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]);</span><br><span class="line">up.release();</span><br><span class="line"><span class="comment">//当一个unique_ptr指向数组时，不能使用点和箭头成员运算符</span></span><br><span class="line"><span class="comment">//unique_ptr指向的是一个数组，而不是单个对象</span></span><br><span class="line"><span class="comment">//可以用下标来访问数组元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">    up[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//shared_ptr不支持直接管理动态数组，必须提供一个删除器。因为默认情况下，shared_ptr使用delete销毁它指向的对象</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>], [](<span class="keyword">int</span> *p) &#123; <span class="keyword">delete</span>[] p; &#125;);</span><br><span class="line">sp.reset(); <span class="comment">//使用提供的delete</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//shared_ptr不直接支持动态数组管理，不支持指针算术运算，未定义下标运算符</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">0</span>; ++i)</span><br><span class="line">    *(sp.get() + i) = i;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="12-2-2-allocator类"><a class="header-anchor" href="#12-2-2-allocator类">¶</a>12.2.2 allocator类</h2>
<ul>
<li>
<p>内存分配和对象构造组合在一起可能导致不必要的浪费</p>
</li>
<li>
<p>两次初始化，第一次在默认初始化，第二次在赋值时。没有默认构造函数的类就不能动态分配数组</p>
</li>
<li>
<p>allocator类</p>
<ul>
<li>
<p>头文件memory</p>
</li>
<li>
<p>将内存分配和对象构造分开</p>
</li>
<li>
<p>提供类型感知的内存分配，它分配的内存是原始的、未构造的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allocator&lt;<span class="built_in">string</span>&gt; alloc;</span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">const</span> p = alloc.allocate(n);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>allocator分配未构造的内存</p>
<ul>
<li>不能在未构造的情况下直接使用</li>
<li>用完对象必须用destroy来销毁它们</li>
<li>我们只能对真正构造了的元素进行destroy操作，元素销毁后可以重新构造对象，也可以通过deallocate归还给系统</li>
<li>释放内存通过deallocate完成，deallocate的大小参数必须和allocated分配内存时提供的大小具有一样的值</li>
</ul>
</li>
<li>
<p>拷贝和填充未初始化内存的算法</p>
<blockquote>
<p>用来在未初始化内存中创建对象。在目的位置创建元素，而不是由系统分配内存给它们。</p>
</blockquote>
<ul>
<li>uninitialized_copy(b,e,b2);</li>
<li>uninitialized_copy_n(b,n,b2)</li>
<li>uninitialized_fill(b,e,t)</li>
<li>uninitialized_fill_n(b,n,t)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1>12.3 使用标准库：文本查询程序</h1>
<h2 id="12-3-1-文本查询程序设计"><a class="header-anchor" href="#12-3-1-文本查询程序设计">¶</a>12.3.1 文本查询程序设计</h2>
<ul>
<li>
<p>列出程序操作</p>
<ul>
<li>逐行读取，分解为独立单词</li>
<li>输出时要能提取每个单词关联的行号，行号必须升序出现且无重复，必须能打印给定行号中的文本</li>
</ul>
</li>
<li>
<p>数据结构</p>
<ul>
<li>TextQuery类
<ul>
<li>成员：包含保存输入文件文本的vector，用来关联每个单词和它出现的行号的set的map</li>
<li>操作：用来读取给定输入文件的构造函数和一个执行查询的操作</li>
<li>查询操作：查找map，检查给定单词是否出现。一旦找到单词，需要知道它出现了多少次、行号以及每行的文本。</li>
</ul>
</li>
<li>QueryResult类，保存查询结果。这个类有一个print函数，打印结果</li>
</ul>
</li>
<li>
<p>类之间共享数据</p>
<ul>
<li>QueryResult需要知道给定单词的行号set和行对应的文本</li>
<li>返回指向TextQuery对象内部的迭代器或指针避免拷贝。考虑到TextQuery在QueryResult之前被销毁的情况和两种对象生存期应该同步的观察结果，可以使用shared_ptr反映这种共享关系</li>
</ul>
</li>
<li>
<p>使用TextQuery类</p>
<ul>
<li>
<p>实现之前先编写程序使用这个类，是很有用的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runQueries</span><span class="params">(ifstream &amp;infile)</span></span>&#123;</span><br><span class="line">	<span class="function">TextQuery <span class="title">tq</span><span class="params">(infile)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"enter word to query or q to quit: "</span>;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">if</span> (!(<span class="built_in">cin</span> &gt;&gt; s) || s == <span class="string">"q"</span>) <span class="keyword">break</span>;</span><br><span class="line">        print(<span class="built_in">cout</span>, tq.query(s)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="12-3-2-文本查询程序类的定义"><a class="header-anchor" href="#12-3-2-文本查询程序类的定义">¶</a>12.3.2 文本查询程序类的定义</h2>
<p>QueryResult需要共享保存输入文件的vector和保存单词关联行号的set。所以，TextQuery需要有一个指向动态分配的vector的shared_ptr和一个string到shared_ptr<set>的map</set></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryResult</span>;</span> <span class="comment">// declaration needed for return type in the query function</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextQuery</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> line_no = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::size_type;</span><br><span class="line">	TextQuery(<span class="built_in">std</span>::ifstream&amp;);</span><br><span class="line">	<span class="function">QueryResult <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt; file; <span class="comment">// input file</span></span><br><span class="line">	<span class="comment">// map of each word to the set of the lines in which that word appears</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;line_no&gt;&gt;&gt; wm;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>TextQuery构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read the input file and build the map of lines to line numbers</span></span><br><span class="line">TextQuery::TextQuery(ifstream &amp;is): file(<span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">string</span> text;</span><br><span class="line">	<span class="keyword">while</span> (getline(is, text)) &#123; <span class="comment">// for each line in the file</span></span><br><span class="line">		file-&gt;push_back(text); <span class="comment">// remember this line of text</span></span><br><span class="line">		<span class="keyword">int</span> n = file-&gt;size() - <span class="number">1</span>; <span class="comment">// the current line number</span></span><br><span class="line">		<span class="function"><span class="built_in">istringstream</span> <span class="title">line</span><span class="params">(text)</span></span>; <span class="comment">// separate the line into words</span></span><br><span class="line">		<span class="built_in">string</span> word;</span><br><span class="line">		<span class="keyword">while</span> (line &gt;&gt; word) &#123; <span class="comment">// for each word in that line</span></span><br><span class="line">            <span class="comment">// if word isn't already in wm, subscripting adds a new entry</span></span><br><span class="line">			<span class="keyword">auto</span> &amp;lines = wm[word]; <span class="comment">// lines is a shared_ptr</span></span><br><span class="line">			<span class="keyword">if</span> (!lines) <span class="comment">// that pointer is null the first time we see word</span></span><br><span class="line">				lines.reset(<span class="keyword">new</span> <span class="built_in">set</span>&lt;line_no&gt;); <span class="comment">// allocate a new set</span></span><br><span class="line">			lines-&gt;insert(n); <span class="comment">// insert this line number</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>QueryResult类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryResult</span> &#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="built_in">std</span>::<span class="function">ostream&amp; <span class="title">print</span><span class="params">(<span class="built_in">std</span>::ostream&amp;, <span class="keyword">const</span> QueryResult&amp;)</span></span>;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		QueryResult(<span class="built_in">std</span>::<span class="built_in">string</span> s,</span><br><span class="line">					<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;line_no&gt;&gt; p,</span><br><span class="line">						<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt; f): </span><br><span class="line">    			sought(s), lines(p), file(f) &#123; &#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> sought; <span class="comment">// word this query represents</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;line_no&gt;&gt; lines; <span class="comment">// lines it's on</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt; file; <span class="comment">// input file</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造函数唯一工作是将参数保存在对应的数据成员中</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>query函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">QueryResult</span><br><span class="line">TextQuery::query(<span class="keyword">const</span> <span class="built_in">string</span> &amp;sought) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// we'll return a pointer to this set if we don't find sought</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">shared_ptr</span>&lt;<span class="built_in">set</span>&lt;line_no&gt;&gt; nodata(<span class="keyword">new</span> <span class="built_in">set</span>&lt;line_no&gt;);</span><br><span class="line">    <span class="comment">// use find and not a subscript(下标) to avoid adding words to wm!</span></span><br><span class="line">    <span class="keyword">auto</span> loc = wm.find(sought);</span><br><span class="line">	<span class="keyword">if</span> (loc == wm.end())</span><br><span class="line">		<span class="keyword">return</span> QueryResult(sought, nodata, file); <span class="comment">// not found</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> QueryResult(sought, loc-&gt;second, file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>print函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp; os, <span class="keyword">const</span> QueryResult &amp;qr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// if the word was found, print the count and all occurrences</span></span><br><span class="line">    os &lt;&lt; qr.sought &lt;&lt; <span class="string">" occurs "</span> &lt;&lt; qr.lines-&gt;size() &lt;&lt; <span class="string">" "</span></span><br><span class="line">    	&lt;&lt; make_plural(qr.lines-&gt;size(), <span class="string">"time"</span>, <span class="string">"s"</span>) &lt;&lt;</span><br><span class="line">    		<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// print each line in which the word appeared</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> num : *qr.lines) <span class="comment">// for every element in the set</span></span><br><span class="line">		<span class="comment">// don't confound the user with text lines starting at 0</span></span><br><span class="line">		os &lt;&lt; <span class="string">"\t(line "</span> &lt;&lt; num + <span class="number">1</span> &lt;&lt; <span class="string">") "</span></span><br><span class="line">			&lt;&lt; *(qr.file-&gt;begin() + num) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/18/C-Primer学习笔记：第11章-关联容器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/18/C-Primer学习笔记：第11章-关联容器/" itemprop="url">C++ Primer学习笔记：第11章 关联容器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-18T12:21:00+08:00">2019-07-18</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>8个容器，3个维度，4个头文件</p>
<ul>
<li>或是set，或是map</li>
<li>或是要求不重复关键字，或是允许重复关键字</li>
<li>或是按顺序保存，或是无序保存</li>
</ul>
<h1>11.1 使用关联容器</h1>
<ul>
<li>
<p>使用map</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count;</span><br><span class="line"><span class="built_in">string</span> word;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; word)</span><br><span class="line">    ++word_count[word];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : word_count)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; w.first &lt;&lt; <span class="string">"occurs "</span> &lt;&lt; w.second &lt;&lt; ((w.second &gt; <span class="number">1</span>) ? <span class="string">" times"</span> : <span class="string">" time"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>从map提取元素，得到pair类型对象，保存两个名为first和second的公有数据成员，first是关键字，second是对应的值</p>
</li>
<li>
<p>使用set</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; exclude = &#123;<span class="string">"The"</span>, <span class="string">"But"</span>, <span class="string">"And"</span>, <span class="string">"Or"</span>, <span class="string">"An"</span>, <span class="string">"A"</span>, </span><br><span class="line">					<span class="string">"the"</span>, <span class="string">"but"</span>, <span class="string">"and"</span>, <span class="string">"or"</span>, <span class="string">"an"</span>, <span class="string">"a"</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> word;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; word)</span><br><span class="line">    <span class="comment">//find调用返回一个迭代器，如果给定关键字在set中，迭代器指向该关键字，否则返回尾后迭代器</span></span><br><span class="line">	<span class="keyword">if</span>(exclude.find(word) == exclude.end())</span><br><span class="line">		++word_count[word];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>11.2 关联容器概述</h1>
<h2 id="11-2-1-定义关联容器"><a class="header-anchor" href="#11-2-1-定义关联容器">¶</a>11.2.1 定义关联容器</h2>
<ul>
<li>默认构造函数，创建空容器</li>
<li>初始化为另一个同类型容器的拷贝</li>
<li>从一个值范围初始化关联容器，只要可以转化为容器所需类型即可</li>
<li>对关联容器进行值初始化</li>
</ul>
<h2 id="11-2-2-关键字类型的要求"><a class="header-anchor" href="#11-2-2-关键字类型的要求">¶</a>11.2.2 关键字类型的要求</h2>
<ul>
<li>
<p>有序容器的关键字类型</p>
<ul>
<li>所提供的的操作必须在关键字类型上定义一个严格弱序</li>
</ul>
</li>
<li>
<p>使用关键字类型的比较函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">multiset</span>&lt;Sales_data, <span class="keyword">decltype</span>(compareIsbn) *&gt; bookstore(compareIsbn);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="11-2-3-pair类型"><a class="header-anchor" href="#11-2-3-pair类型">¶</a>11.2.3 pair类型</h2>
<ul>
<li>默认构造函数对数据成员进行值初始化</li>
<li>创建pair对象的函数
<ul>
<li>返回pair，可以返回隐式构造的pair对象，也可以对返回值进行列表初始化，还可以用make_pair生成pair对象</li>
</ul>
</li>
</ul>
<h1>11.3 关联容器操作</h1>
<p>关联容器额外类型别名</p>
<ul>
<li>key_type</li>
<li>mapped_type
<ul>
<li>只有map才有这种类型</li>
</ul>
</li>
<li>value_type
<ul>
<li>set:和key_type同</li>
<li>map:pair&lt;const key_type, mapped_type&gt;</li>
</ul>
</li>
</ul>
<h2 id="11-3-1-关联容器迭代器"><a class="header-anchor" href="#11-3-1-关联容器迭代器">¶</a>11.3.1 关联容器迭代器</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> map_it = word_count.begin();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; map_it-&gt;first;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; map_it-&gt;second;</span><br><span class="line">map_it-&gt;first = <span class="string">"new key"</span>; <span class="comment">//错误:关键字是const的</span></span><br><span class="line">++map_it-&gt;second;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>set的迭代器是const的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; iset = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator set_it = iset.begin();</span><br><span class="line"><span class="keyword">if</span> (set_it != iset.end()) &#123;</span><br><span class="line">    *set_it = <span class="number">42</span>;<span class="comment">//错误:set中的关键字是只读的</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *set_it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>遍历关联容器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> map_it = word_count.cbegin();</span><br><span class="line"><span class="keyword">while</span>(map_it != word_count.cend())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;map_it-&gt;first&lt;&lt;<span class="string">" occurs "</span>&lt;&lt;map_it-&gt;second&lt;&lt;<span class="string">" times"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    ++map_it;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序的输出是按字典序排列的，按关键字升序遍历元素</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>关联容器和算法</p>
<ul>
<li>通常不对关联容器使用泛型算法，因为关联容器关键字是const的</li>
<li>关联容器的可以用自己的find成员通过给定关键字直接获取元素</li>
<li>可以对关联容器使用copy算法，也可以调用inserter绑定插入器到关联容器</li>
</ul>
</li>
</ul>
<h2 id="11-3-2-添加元素"><a class="header-anchor" href="#11-3-2-添加元素">¶</a>11.3.2 添加元素</h2>
<ul>
<li>insert和emplace</li>
<li>检测insert的返回值
<ul>
<li>返回指向具有给定关键字的元素的迭代器和插入是否成功的布尔值的pair</li>
</ul>
</li>
<li>向multiset或multimap添加元素
<ul>
<li>对于允许重复关键字的容器，接受单个元素的insert操作只返回一个指向新元素的迭代器</li>
</ul>
</li>
</ul>
<h2 id="11-3-3-删除元素"><a class="header-anchor" href="#11-3-3-删除元素">¶</a>11.3.3 删除元素</h2>
<ul>
<li>接收一个迭代器或一个迭代器对的erase返回void</li>
<li>接收key_type的erase，返回实际删除的元素数量</li>
</ul>
<h2 id="11-3-4-map的下标操作"><a class="header-anchor" href="#11-3-4-map的下标操作">¶</a>11.3.4 map的下标操作</h2>
<ul>
<li>如果关键字不在map中，会为它创建一个元素并插入map中，关联值将进行值初始化</li>
<li><strong>只可以对非const的map使用下标操作</strong></li>
<li><a href="http://c.at" target="_blank" rel="noopener">c.at</a>(k)是带参数检查的版本，k不在c中抛出out_of_range异常</li>
<li>与vector与string不同，map下标运算符返回的类型（mapped_type）与解引用map迭代器得到的类型（value_type）不同</li>
</ul>
<h2 id="11-3-5-访问元素"><a class="header-anchor" href="#11-3-5-访问元素">¶</a>11.3.5 访问元素</h2>
<ul>
<li>不想改变map，而只是想知道给定关键字是否在map中，不能用下标运算符，而应该用find成员函数</li>
<li>在multimap或multiset中查找，结合count和find成员函数</li>
<li>用lower_bound和upper_bound可以得到迭代器范围，表示具有该关键字的元素的范围
<ul>
<li>lower_bound返回的迭代器可能指向一个具有给定关键字的元素，但也可能不指向</li>
<li>如果关键字不在容器中，则lower_bound会返回关键字的第一个安全插入点</li>
</ul>
</li>
<li>equal_range接受一个关键字，返回一个迭代器pair，第一个迭代器指向第一个与关键字匹配的元素，第二个迭代器指向最后一个匹配元素之后的位置</li>
</ul>
<h2 id="11-3-6-一个单词转换的map"><a class="header-anchor" href="#11-3-6-一个单词转换的map">¶</a>11.3.6 一个单词转换的map</h2>
<ul>
<li>void word_transfrom(ifstream &amp;map_file, ifstream &amp;input)</li>
<li>map&lt;string, string&gt; buildMap(ifstream &amp;map_file)</li>
<li>const string &amp;transform(const string &amp;s, const map&lt;string, string&gt; &amp;m)</li>
</ul>
<h1>11.4 无序容器</h1>
<ul>
<li>
<p>管理桶</p>
<ul>
<li>桶接口
<ul>
<li>c.bucket_count()</li>
<li>c.max_bucket_count()</li>
<li>c.bucket_size(n)</li>
<li>c.bucket(k)</li>
</ul>
</li>
<li>桶迭代
<ul>
<li>local_iterator</li>
<li>const_local_iterator</li>
<li>c.begin(n), c.end(n)</li>
<li>c.cbegin(n), c.cend(n)</li>
</ul>
</li>
<li>哈希策略
<ul>
<li>c.load_factor()</li>
<li>c.max_load_factor()</li>
<li>c.rehash(n)</li>
<li>c.reserve(n)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>对关键字的要求</p>
<ul>
<li>
<p>无序容器使用关键字类型的==运算符比较元素，还用hash&lt;key_type&gt;类型的对象生成每个元素的哈希值</p>
</li>
<li>
<p>不能直接定义关键字类型为自定义类类型的无序容器。需要提供自己的hash模板版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> hasher(<span class="keyword">const</span> Sales_data &amp;sd)&#123;</span><br><span class="line">	<span class="keyword">return</span> hash&lt;<span class="built_in">string</span>&gt;()(sd.isbn());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">eqOp</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.isbn() == rhs.isbn();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> SD_multiset = <span class="built_in">unordered_multiset</span>&lt;Sales_data, <span class="keyword">decltype</span>(hasher)*, <span class="keyword">decltype</span>(eqOp)*&gt;;</span><br><span class="line"><span class="comment">//参数是桶大小，哈希函数指针，相等性判断运算符指针</span></span><br><span class="line"><span class="function">SD_multiset <span class="title">bookstore</span><span class="params">(<span class="number">42</span>, hasher, eqOp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用FooHash生成哈希值；Foo必须有==运算符</span></span><br><span class="line"><span class="built_in">unordered_set</span>&lt;Foo, <span class="keyword">decltype</span>(FooHash)* fooSet(10, FooHash);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/17/C-Primer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lidanyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just a blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/17/C-Primer/" itemprop="url">C++ Primer学习笔记：第10章 泛型算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-17T22:51:00+08:00">2019-07-17</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>10.1 概述</h1>
<ul>
<li>只要有一个迭代器可用来返回元素，find就完全不依赖容器类型（甚至无须理会保存元素的是不是容器）</li>
<li>迭代器令算法不依赖于容器，但算法依赖于元素类型的操作</li>
<li>算法永远不会执行容器的操作，只会执行迭代器的操作
<ul>
<li>算法永远不会改变底层容器的大小</li>
<li>插入器（特殊的迭代器）可以改变容器大小，但是算法自身永远不会做这样的操作</li>
</ul>
</li>
</ul>
<h1>10.2 初识泛型算法</h1>
<blockquote>
<p>理解算法最基本方法是了解它们是否读取元素、改变元素或者重排元素顺序</p>
</blockquote>
<h2 id="10-2-1-只读算法"><a class="header-anchor" href="#10-2-1-只读算法">¶</a>10.2.1 只读算法</h2>
<ul>
<li>
<p>注意算法执行的操作在元素类型上是否可行</p>
</li>
<li>
<p>accumulate求和算法</p>
</li>
<li>
<p>equal比较两个序列，假定第二个序列至少和第一个序列一样长</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>只接受单一迭代器来表示第二个序列的算法，都假定第二个序列至少和第一个序列一样长</p>
</li>
</ul>
<h2 id="10-2-2-写容器元素的算法"><a class="header-anchor" href="#10-2-2-写容器元素的算法">¶</a>10.2.2 写容器元素的算法</h2>
<ul>
<li>
<p>fill范围写值函数，只要传递有效输入序列，写入就是安全的</p>
</li>
<li>
<p>算法不检查写操作</p>
<ul>
<li>向目的位置迭代器写入数据的算法假定目的位置足够大</li>
</ul>
</li>
<li>
<p>back_inserter</p>
<ul>
<li>
<p>定义在头文件iterator中</p>
</li>
<li>
<p>接收容器引用，返回与该容器绑定的插入迭代器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">fill_n(back_inserter(vec), <span class="number">10</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>拷贝算法</p>
<ul>
<li>
<p>copy实现内置数组拷贝</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a2[<span class="keyword">sizeof</span>(a1)/<span class="keyword">sizeof</span>(*a1)];</span><br><span class="line"><span class="keyword">auto</span> ret = copy(begin(a1), end(a1), a2);<span class="comment">//把a1拷贝给a2，返回a2尾元素之后的位置</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>多个算法都提供拷贝版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">replace_copy(ilst.begin(), ilst.end(), back_inserter(ivec), <span class="number">0</span>, <span class="number">42</span>);</span><br><span class="line"><span class="comment">//ilst未改变，ivec包含ilst的替换值后的一份拷贝</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="10-2-3-重排容器元素的算法"><a class="header-anchor" href="#10-2-3-重排容器元素的算法">¶</a>10.2.3 重排容器元素的算法</h2>
<ul>
<li>
<p>排序并去重</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">elimDups</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words)</span></span>&#123;</span><br><span class="line">	sort(words.begin(), words.end());</span><br><span class="line">	<span class="keyword">auto</span> end_unique = unique(words.begin(), words.end());</span><br><span class="line">	words.erase(end_unique, words.end());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//unique并不删除元素，只是覆盖重复元素，使得不重复元素出现在序列开始部分</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>10.3 定制操作</h1>
<h2 id="10-3-1-向算法传递函数"><a class="header-anchor" href="#10-3-1-向算法传递函数">¶</a>10.3.1 向算法传递函数</h2>
<ul>
<li>stable_sort稳定排序算法，维持相等元素原有顺序</li>
</ul>
<h2 id="10-3-2-lambda表达式"><a class="header-anchor" href="#10-3-2-lambda表达式">¶</a>10.3.2 lambda表达式</h2>
<ul>
<li>
<p>find_if算法第三个参数接收一个谓词，对每个元素调用这个谓词，这个谓词只能接受一个参数</p>
</li>
<li>
<p>可调用对象，除了函数和函数指针，还有重载了函数调用运算符的类和lambda表达式</p>
</li>
<li>
<p>lambda表达式</p>
<ul>
<li>
<p><code>[capture list](parameter list)-&gt;return type{funtion body}</code></p>
<ul>
<li><code>capture list</code>是lambda所在函数中定义的局部变量的列表</li>
<li><code>return type</code>是返回类型</li>
<li><code>parameter list</code>是参数列表</li>
<li><code>function body</code>是函数体</li>
</ul>
</li>
<li>
<p>lambda必须用尾置返回指定返回类型</p>
</li>
<li>
<p>可以忽略参数列表和返回类型，但是必须永远包含捕获列表和函数体</p>
</li>
<li>
<p>如果lambda函数体包含任何单一return之外的内容，且未指定返回类型，则返回void</p>
</li>
<li>
<p>向lambda传递参数</p>
<ul>
<li>lambda不能有默认参数</li>
</ul>
</li>
<li>
<p>使用捕获列表</p>
<ul>
<li>
<p>使用lambda所在函数的局部变量需要将其包含在捕获列表中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[sz](<span class="keyword">const</span> <span class="built_in">string</span> &amp;a)&#123; <span class="keyword">return</span> a.size() &gt;= sz; &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>我们只对lambda所在函数中定义的（非static）变量使用捕获列表。lambda可以直接使用定义在当前函数之外的名字和局部static变量</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="10-3-3-lambda捕获和返回"><a class="header-anchor" href="#10-3-3-lambda捕获和返回">¶</a>10.3.3 lambda捕获和返回</h2>
<ul>
<li>
<p>lambda生成一个新的匿名类类型</p>
</li>
<li>
<p>lambda生成的类都包含一个对应该lambda所捕获的变量的数据成员，在lambda对象创建时初始化这些数据成员</p>
</li>
<li>
<p>值捕获</p>
<ul>
<li>前提是变量可拷贝</li>
<li>被捕获变量的值在创建时拷贝，而不是调用时拷贝</li>
</ul>
</li>
<li>
<p>引用捕获</p>
<ul>
<li>流对象不能拷贝，所以要捕获流对象的引用</li>
<li>函数返回lambda，则此lambda也不能包含引用捕获</li>
<li>引用方式捕获一个变量，必须保证lambda执行时变量时存在的</li>
</ul>
</li>
<li>
<p>隐式捕获</p>
<ul>
<li>
<p>在捕获列表中写一个=或者&amp;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc = find_if(words.begin(), words.end(), [=](<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)&#123; <span class="keyword">return</span> s.size() &gt;= sz; &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>混合隐式捕获，捕获列表中第一个元素必须是一个&amp;或=，此符号指定了默认捕获方式为引用或者值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">biggies</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::size_type sz, ostream &amp;os = <span class="built_in">cout</span>, <span class="keyword">char</span> c = <span class="string">' '</span>)</span></span>&#123;</span><br><span class="line">	for_each(words.begin(), words.end(), [&amp;, c](<span class="keyword">const</span> <span class="built_in">string</span> &amp;s) &#123; os &lt;&lt; s &lt;&lt; c; &#125;);</span><br><span class="line">	for_each(words.begin(), words.end(), [=, &amp;os](<span class="keyword">const</span> <span class="built_in">string</span> &amp;s) &#123; os &lt;&lt; s &lt;&lt; c; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示捕获的变量必须使用与隐式捕获不同的方式</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>可变lambda</p>
<ul>
<li>
<p>希望改变一个被捕获的变量的值，必须在参数列表首加上关键字mutable，所以可变lambda不能省略参数列表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [v1]() <span class="keyword">mutable</span> &#123;<span class="keyword">return</span> ++v1;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>引用捕获的变量是否可改依赖于是const还是非const引用</p>
</li>
</ul>
</li>
<li>
<p>指定lambda返回类型</p>
<ul>
<li>
<p>默认情况下，如果lambda包含return之外的任何语句，则编译器假定此lambda返回void</p>
</li>
<li>
<p>当我们需要为一个lambda定义返回类型，必须使用尾置返回类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform(vi.begin(), vi.end(), vi.begin(), [](<span class="keyword">int</span> i)-&gt;<span class="keyword">int</span>&#123;<span class="keyword">if</span>(i &lt; <span class="number">0</span>) <span class="keyword">return</span> -i; <span class="keyword">else</span> <span class="keyword">return</span> i; &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="10-3-4-参数绑定"><a class="header-anchor" href="#10-3-4-参数绑定">¶</a>10.3.4 参数绑定</h2>
<blockquote>
<p>解决如何向多出的形参传参的问题</p>
</blockquote>
<ul>
<li>
<p>标准库bind函数</p>
<ul>
<li>
<p>定义在functional头文件中</p>
</li>
<li>
<p>auto newCallable = bind(callable, arg_list); //arg_list是给定的callable的参数，当调用newCallable，newCallable会调用callable，并传给它arg_list中的参数。arg_list中参数可能包含形如**_n**的名字，其中n是整数，它们占据了传递给newCallable的参数的位置。n代表生成的可调用对象中参数的位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> wc = find_if(words.begin(), words.end(), [sz](<span class="keyword">const</span> <span class="built_in">string</span> &amp;a));</span><br><span class="line"><span class="keyword">auto</span> wc = find_if(words.begin(), words.end(), bind(check_size, _1, sz));</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>使用placeholders名字</p>
<ul>
<li>
<p><strong>_n</strong>都定义在在placeholders命名空间中，而placeholders定义在std命名空间中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>bind的参数</p>
<p>可以用bind重新安排参数顺序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> g = bind(f, a, b, _2, c, _1);</span><br><span class="line"><span class="comment">//将g(_1, _2)映射为f(a, b, _2, c, _1);</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>绑定引用参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for_each(words.begin(), words.end(), bind(print, ref(os), <span class="number">1</span>, <span class="string">' '</span>));</span><br><span class="line"><span class="comment">//ref(os)以引用方式绑定参数</span></span><br><span class="line"><span class="comment">//ref返回一个对象，包含给定的引用，此对象可拷贝</span></span><br><span class="line"><span class="comment">//cref生成一个保存const引用的类</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>10.4 再探迭代器</h1>
<blockquote>
<p>插入迭代器、流迭代器、反向迭代器、移动迭代器</p>
</blockquote>
<h2 id="10-4-1-插入迭代器"><a class="header-anchor" href="#10-4-1-插入迭代器">¶</a>10.4.1 插入迭代器</h2>
<ul>
<li>
<p>插入迭代器操作</p>
<ul>
<li>it=t</li>
<li>*it，it++，++it //不会对it做任何事情，每个操作都返回it</li>
</ul>
</li>
<li>
<p>三种类型，差异在于元素插入的位置</p>
<ul>
<li>
<p>back_inserter创建一个使用push_back的迭代器</p>
</li>
<li>
<p>front_inserter创建一个使用push_front的迭代器</p>
</li>
<li>
<p>inserter创建一个使用insert的迭代器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*it = val;</span><br><span class="line"></span><br><span class="line">it = c.insert(it, val);</span><br><span class="line">++it;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>front_inserter和inserter</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst2, lst3;</span><br><span class="line"><span class="comment">//拷贝完成后，lst2包含4 3 2 1</span></span><br><span class="line">copy(lst.cbegin(), lst.cend(), front_inserter(lst2));</span><br><span class="line"><span class="comment">//拷贝完成后，lst3包含1 2 3 4</span></span><br><span class="line">copy(lst.cbegin(), lst.cend(), inserter(lst3, lst3.begin()));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="10-4-2-iostream迭代器"><a class="header-anchor" href="#10-4-2-iostream迭代器">¶</a>10.4.2 iostream迭代器</h2>
<ul>
<li>
<p>istream_iterator</p>
<p>istream_iterator要读取的类型必须定义了输入运算符；</p>
<p>当创建一个istream_iterator，可以将它绑定到一个流；</p>
<p>默认初始化迭代器创建一个可以当做尾后值使用的迭代器；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; in_iter(<span class="built_in">cin</span>);</span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; eof;</span><br><span class="line"><span class="keyword">while</span> (in_iter != eof)</span><br><span class="line">    vec.push_back(*in_iter++);</span><br><span class="line"></span><br><span class="line"><span class="comment">//以上程序可以重写为如下形式</span></span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; in_iter(<span class="built_in">cin</span>), eof;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(in_iter, eof);</span><br><span class="line"><span class="comment">//直到遇到一个不是int的数据为止或者遇到文件尾</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用算法操作流迭代器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; in(<span class="built_in">cin</span>), eof;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; accumulate(in, eof, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>istream_iterator允许使用懒惰求值</p>
<p>绑定流时，标准库并不保证迭代器立即读取数据，具体实现可以推迟读，直到使用时才真正读；</p>
<p>标准库保证第一次解引用迭代器之前，从流中读取数据的操作已经完成；</p>
<p>创建一个istream_iterator，没有使用就销毁或者正在从两个不同对象同步读取同一个流，何时读取可能就很重要了；</p>
</li>
<li>
<p>ostream_iterator操作</p>
<ul>
<li>
<p>不允许空的或者尾后位置的ostream_iterator</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ostream_iterator&lt;<span class="keyword">int</span>&gt; out_iter(<span class="built_in">cout</span>, <span class="string">" "</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> e : vec)</span><br><span class="line">    *out_iter++ = e;<span class="comment">//也可以写成out_iter = e，因为*和++实际上对ostream_iterator对象不做任何事情</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用流迭代器处理类类型</p>
</li>
</ul>
</li>
</ul>
<h2 id="10-4-3-反向迭代器"><a class="header-anchor" href="#10-4-3-反向迭代器">¶</a>10.4.3 反向迭代器</h2>
<ul>
<li>只能从支持++也支持–的迭代器来定义反向迭代器</li>
<li>可以用base函数将反向迭代器转为普通迭代器，使之正向移动，但是rit.base()和rit指向的元素不同</li>
<li>从普通迭代器初始化反向迭代器，或是给一个反向迭代器赋值，结果迭代器和原迭代器指向的不是相同元素</li>
</ul>
<h1>10.5 泛型算法结构</h1>
<ul>
<li>按算法要求的迭代器操作可将迭代器分为5个类别
<ul>
<li>输入迭代器</li>
<li>输出迭代器</li>
<li>前向迭代器</li>
<li>双向迭代器</li>
<li>随机访问迭代器</li>
</ul>
</li>
<li>按照是否读写或是重排元素分类</li>
</ul>
<h2 id="10-5-1-5类迭代器"><a class="header-anchor" href="#10-5-1-5类迭代器">¶</a>10.5.1 5类迭代器</h2>
<ul>
<li>
<p>输入迭代器（==，!=，++，*，-&gt;)</p>
<p>只能用于单遍扫描算法</p>
</li>
<li>
<p>输出迭代器（++，*）</p>
<p>用作目的位置的迭代器通常都是输出迭代器</p>
</li>
<li>
<p>前向迭代器（支持所有输入输出迭代器操作）</p>
<p>可以多次读写同一个元素，所以可以保存前向迭代器的状态，可以对序列多遍扫描。replace要求前向，forward_list上的是前向迭代器</p>
</li>
<li>
<p>双向迭代器（支持所有前向迭代器操作，还支持–）</p>
<p>reverse要求双向迭代器，除了forward_list之外，其他标准库都提供符合双向迭代器要求的迭代器</p>
</li>
<li>
<p>随机访问迭代器（支持双向迭代器所有操作，还支持比较运算，整数加减，两迭代器相减，下标运算符）</p>
<p>sort要求随机访问迭代器，array、deque、string和vector的迭代器都是随机访问迭代器，用于访问内置数组元素的指针也是</p>
</li>
</ul>
<h2 id="10-5-2-算法形参模式"><a class="header-anchor" href="#10-5-2-算法形参模式">¶</a>10.5.2 算法形参模式</h2>
<ul>
<li>alg(beg,end,other args);</li>
<li>alg(beg,end,dest,other args); //接受单个目标迭代器，dest是一个直接指向容器的迭代器或者绑定到一个插入迭代器</li>
<li>alg(beg,end,beg2,other args); //接受第二个输入序列的算法</li>
<li>alg(beg,end,beg2,end2,other args);</li>
</ul>
<h2 id="10-5-3-算法命名规范"><a class="header-anchor" href="#10-5-3-算法命名规范">¶</a>10.5.3 算法命名规范</h2>
<p>如何提供一个操作代替默认的&lt;或==运算符以及算法是将输出数据写入输入序列还是一个分离的目的位置</p>
<ul>
<li>
<p>一些算法使用重载形式传递一个谓词</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unique(beg, end);</span><br><span class="line">unique(beg, end, comp);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>_if版本的算法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find(beg, end, val);</span><br><span class="line">find_if(beg, end, pred); <span class="comment">//谓词版本</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>区分拷贝元素的版本和不拷贝的版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">reverse(beg, end);</span><br><span class="line">reverse_copy(beg, end, dest);</span><br><span class="line"></span><br><span class="line">remove_if(v1.begin(), v1.end(), [](<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> i % <span class="number">2</span>; &#125;);</span><br><span class="line">remove_copy_if(v1.begin(), v1.end(), back_inserter(v2), [](<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> i % <span class="number">2</span>; &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>10.6 特定容器算法</h1>
<p>链表类型list和forward_list定义了几个成员函数形式的算法。它们定义了独有的sort、merge、remove、reverse和unique。</p>
<p>通用版本sort要求随机访问迭代器，因此不能用于list和forward_list，因为这两个类型分别提供双向迭代器和前向迭代器</p>
<p>通用版本代价太高，成员函数版通过改变元素间的链接而不是真的交换它们的值来快速交换元素</p>
<ul>
<li>list和forward_list成员函数版本的算法
<ul>
<li>lst.merge(lst2) //lst和lst2都必须是有序的，元素将从lst2删除，合并之后，lst2变为空</li>
<li>lst.merge(lst2, comp)</li>
<li>lst.remove(val)</li>
<li>lst.remove_if(pred)</li>
<li>lst.reverse()</li>
<li>lst.sort()</li>
<li>lst.sort(comp)</li>
<li>lst.unique()</li>
<li>lst.unique(pred)</li>
</ul>
</li>
<li>splice（链表数据结构特有的，不需要通用版本）
<ul>
<li>lst.splice(args)或flst.splice_after(args)</li>
<li>参数
<ul>
<li>(p,lst2) //lst2不能和lst或flst是同一个链表，移动所有</li>
<li>(p,lst2,p2) //lst2可以是与lst或flst相同的链表，移动一个</li>
<li>(p,lst2,b,e) //lst2可以是与lst或flst相同的链表,但p不能指向给定范围中的元素，移动范围</li>
</ul>
</li>
</ul>
</li>
<li>链表特有的操作会改变底层容器</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">lidanyang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">74</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">40</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/lidanyang" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1261727840@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lidanyang</span>

  

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.0.0</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.0"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
